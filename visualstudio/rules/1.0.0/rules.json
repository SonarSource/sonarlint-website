[
  {
    "Key": "S2278",
    "Title": "Neither DES (Data Encryption Standard) nor DESede (3DES) should be used",
    "Description": "<p>\r\n    According to the US National Institute of Standards and Technology (NIST), the Data Encryption Standard (DES) is no longer\r\n    considered secure:\r\n</p>\r\n<blockquote>\r\n    <p>\r\n        Adopted in 1977 for federal agencies to use in protecting sensitive, unclassified information, the DES is being withdrawn \r\n        because it no longer provides the security that is needed to protect federal government information.\r\n    </p>\r\n    <p>\r\n        Federal agencies are encouraged to use the Advanced Encryption Standard, a faster and stronger algorithm approved as FIPS \r\n        197 in 2001.\r\n    </p>\r\n</blockquote>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nusing (var tripleDES = new TripleDESCryptoServiceProvider()) //Noncompliant\r\n{\r\n  //...\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nusing (var aes = new AesCryptoServiceProvider())\r\n{\r\n  //...\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li><a href=\"http://cwe.mitre.org/data/definitions/326.html\">MITRE CWE-326</a> - Inadequate Encryption Strength</li>\r\n    <li><a href=\"https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure\">OWASP Top Ten 2013 Category A6</a> - Sensitive Data Exposure</li>\r\n    <li>Derived from FindSecBugs rule <a href=\"http://h3xstream.github.io/find-sec-bugs/bugs.htm#DES_USAGE\">DES / DESede Unsafe</a></li>\r\n</ul>",
    "Tags": "cwe, owasp-a6, security"
  },
  {
    "Key": "S2437",
    "Title": "Silly bit operations should not be performed",
    "Description": "<p>\r\n    Certain bit operations are just silly and should not be performed because their results are predictable.\r\n</p>\r\n<p>\r\n    Specifically, using <code>&amp; -1</code> with any value will always result in the original value, as will\r\n    <code>anyValue ^ 0</code> and <code>anyValue | 0</code>.\r\n</p>\r\n",
    "Tags": "bug"
  },
  {
    "Key": "S1699",
    "Title": "Constructors should only call non-overridable methods",
    "Description": "<p>\r\n    Calling an overridable method from a constructor could result in failures or strange behaviors when instantiating a subclass which overrides the method.\r\n</p>\r\n<p>\r\n    For example:\r\n</p>\r\n<ul>\r\n    <li>The subclass class constructor starts by calling the parent class constructor.</li>\r\n    <li>The parent class constructor calls the method, which has been overridden in the child class.</li>\r\n    <li>\r\n        If the behavior of the child class method depends on fields that are initialized in the child class constructor,\r\n        unexpected behavior (like a <code>NullReferenceException</code>) can result, because the fields aren't initialized yet.\r\n    </li>\r\n</ul>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class Parent \r\n{\r\n  public Parent () \r\n  {\r\n    DoSomething();  // Noncompliant\r\n  }\r\n\r\n  public virtual void DoSomething() // can be overridden\r\n  {  \r\n    ...\r\n  }\r\n}\r\n\r\npublic class Child : Parent \r\n{\r\n  private string foo;\r\n\r\n  public Child(string foo) // leads to call DoSomething() in Parent constructor which triggers a NullReferenceException as foo has not yet been initialized\r\n  {\r\n    this.foo = foo;\r\n  }\r\n\r\n  public override void DoSomething() \r\n  {\r\n    Console.WriteLine(this.foo.Length);\r\n  }\r\n}\r\n</pre>\r\n",
    "Tags": "bug"
  },
  {
    "Key": "S2387",
    "Title": "Child class members should not shadow parent class members",
    "Description": "<p>\r\n    Having a variable with the same name in two unrelated classes is fine, but do the same thing within a class hierarchy\r\n    and you'll get confusion at best, chaos at worst. Perhaps even worse is the case where a child class field varies from \r\n    the name of a parent class only by case.\r\n</p>\r\n<p>\r\n    This rule ignores <code>private</code> parent class members, but in all other such cases, the child class field should \r\n    be renamed.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class Fruit \r\n{\r\n  protected Season ripe;\r\n  protected Color flesh;\r\n\r\n  // ...\r\n}\r\n\r\npublic class Raspberry : Fruit \r\n{\r\n  private bool ripe;  // Noncompliant\r\n  private static Color FLESH; // Noncompliant\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class Fruit \r\n{\r\n  protected Season ripe;\r\n  protected Color flesh;\r\n\r\n  // ...\r\n}\r\n\r\npublic class Raspberry : Fruit \r\n{\r\n  private bool ripened;\r\n  private static Color FLESH_COLOR;\r\n}\r\n</pre>\r\n",
    "Tags": "confusing"
  },
  {
    "Key": "S2696",
    "Title": "Instance members should not write to \"static\" fields",
    "Description": "<p>\r\n    Correctly updating a <code>static</code> field from a non-static method is tricky to get right and could easily lead to \r\n    bugs if there are multiple class instances and/or multiple threads in play.\r\n</p>\r\n<p>\r\n    This rule raises an issue each time a <code>static</code> field is updated from a non-static method or property.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class MyClass \r\n{\r\n  private static int count = 0;\r\n\r\n  public void DoSomething() \r\n  {\r\n    //...\r\n    count++;  // Noncompliant\r\n  }\r\n}\r\n</pre>\r\n",
    "Tags": "bug, multi-threading"
  },
  {
    "Key": "S1694",
    "Title": "An abstract class should have both abstract and concrete methods",
    "Description": "<p>\r\n    The purpose of an abstract class is to provide some heritable behaviors while also defining methods which must be \r\n    implemented by sub-classes.\r\n</p>\r\n<p>\r\n    A class with no abstract methods that was made abstract purely to prevent instantiation should be converted to a\r\n    concrete class (i.e. remove the <code>abstract</code> keyword) with a private constructor.\r\n</p>\r\n<p>\r\n    A class with only abstract methods and no inheritable behavior should be converted to an interface.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic abstract class Animal \r\n{\r\n  abstract void Move();\r\n  abstract void Feed();\r\n}\r\n\r\npublic abstract class Color \r\n{\r\n  private int red = 0;\r\n  private int green = 0;\r\n  private int blue = 0;\r\n\r\n  public int GetRed() \r\n  {\r\n    return red;\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic interface Animal \r\n{\r\n  void Move();\r\n  void Feed();\r\n}\r\n\r\npublic class Color \r\n{\r\n  private int red = 0;\r\n  private int green = 0;\r\n  private int blue = 0;\r\n\r\n  private Color ()\r\n  {}\r\n\r\n  public int GetRed() \r\n  {\r\n    return red;\r\n  }\r\n}\r\n\r\npublic abstract class Lamp \r\n{\r\n  private bool switchLamp = false;\r\n\r\n  public abstract void Glow();\r\n\r\n  public void FlipSwitch()\r\n  {\r\n    switchLamp = !switchLamp;\r\n    if (switchLamp)\r\n    {\r\n      Glow();\r\n    }\r\n  }\r\n}\r\n</pre>\r\n",
    "Tags": "convention"
  },
  {
    "Key": "S2197",
    "Title": "Modulus results should not be checked for direct equality",
    "Description": "<p>\r\n    When the modulus of a negative number is calculated, the result will either be negative or zero. Thus, comparing the \r\n    modulus of a variable for equality with a positive number (or a negative one) could result in false negatives.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic bool isOdd(int x) {\r\n  return x % 2 == 1;  // Noncompliant; if x is negative, x % 2 == -1\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic bool isOdd(int x)\r\n{\r\n  return x %2 != 0;\r\n}\r\n</pre>\r\nor\r\n<pre>\r\npublic bool isOdd(int x) \r\n{\r\n  return Math.Abs(x%2) == 1;\r\n}\r\n</pre>\r\n",
    "Tags": "bug"
  },
  {
    "Key": "S2692",
    "Title": "\"IndexOf\" checks should not be for positive numbers",
    "Description": "<p>\r\n    Most checks against an <code>IndexOf</code> value compare it with -1 because 0 is a valid index. Any checks which look for\r\n    values <code>&gt;0</code> ignore the first element, which is likely a bug. If the intent is merely to check inclusion of a\r\n    value in a <code>string</code>, <code>List</code>, or an array, consider using the <code>Contains</code> method instead.\r\n</p>\r\n<p>\r\n    This rule raises an issue when an <code>IndexOf</code> value retrieved from a <code>string</code>, <code>List</code>, \r\n    or array is tested against <code>&gt;0</code>.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nstring color = \"blue\";\r\nstring name = \"ishmael\";\r\n\r\nList&lt;string&gt; strings = new List&lt;string&gt; ();\r\nstrings.add(color);\r\nstrings.add(name);\r\nstring[] stringArray = strings.ToArray();\r\n\r\nif (strings.IndexOf(color) &gt; 0) // Noncompliant\r\n{  \r\n  // ...\r\n}\r\nif (name.IndexOf(\"ish\") &gt; 0) // Noncompliant\r\n{ \r\n  // ...\r\n}\r\nif (name.IndexOf(\"ae\") &gt; 0) // Noncompliant\r\n{ \r\n  // ...\r\n}\r\nif (Array.IndexOf(stringArray, color) &gt; 0) // Noncompliant\r\n{  \r\n  // ...\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nstring color = \"blue\";\r\nstring name = \"ishmael\";\r\nList&lt;string&gt; strings = new List&lt;string&gt; ();\r\nstrings.add(color);\r\nstrings.add(name);\r\nstring[] stringArray = strings.ToArray();\r\nif (strings.IndexOf(color) &gt; -1) \r\n{\r\n  // ...\r\n}\r\nif (name.IndexOf(\"ish\") &gt;= 0) \r\n{\r\n  // ...\r\n}\r\nif (name.Contains(\"ae\") \r\n{\r\n  // ...\r\n}\r\nif (Array.IndexOf(stringArray, color) &gt;= 0)\r\n{  \r\n  // ...\r\n}\r\n</pre>\r\n",
    "Tags": "pitfall"
  },
  {
    "Key": "S2952",
    "Title": "Classes should \"Dispose\" of members from the classes' own \"Dispose\" methods",
    "Description": "<p>\r\n    It is possible in an <code>IDisposable</code> to call <code>Dispose</code> on class members from any method, but the\r\n    contract of <code>Dispose</code> is that it will clean up all unmanaged resources. Move disposing of members to some \r\n    other method, and you risk resource leaks.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class ResourceHolder : IDisposable\r\n{\r\n  private FileStream fs;  \r\n  public void OpenResource(string path)\r\n  {\r\n    this.fs = new FileStream(path, FileMode.Open);\r\n  }\r\n  public void CloseResource()\r\n  {\r\n    this.fs.Close();\r\n  }\r\n\r\n  public void CleanUp() \r\n  {\r\n    this.fs.Dispose(); // Noncompliant; Dispose not called in class' Dispose method\r\n  }\r\n\r\n  public void Dispose() \r\n  {\r\n    // method added to satisfy demands of interface\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class ResourceHolder : IDisposable\r\n{\r\n  private FileStream fs;\r\n  public void OpenResource(string path)\r\n  {\r\n    this.fs = new FileStream(path, FileMode.Open);\r\n  }\r\n  public void CloseResource()\r\n  {\r\n    this.fs.Close();\r\n  }\r\n\r\n  public void Dispose() \r\n  {\r\n    this.fs.Dispose();\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n<ul>\r\n    <li><a href=\"http://cwe.mitre.org/data/definitions/459.html\">MITRE, CWE-459</a> - Incomplete Cleanup</li>\r\n</ul>\r\n",
    "Tags": "bug, cwe, denial-of-service, security"
  },
  {
    "Key": "S2953",
    "Title": "Methods named \"Dispose\" should implement \"IDisposable.Dispose\"",
    "Description": "<p>\r\n    <code>Dispose</code> as a method name should be used exclusively to implement <code>IDisposable.Dispose</code> to prevent \r\n    any confusion.\r\n</p>\r\n<p>\r\n    It may be tempting to create a <code>Dispose</code> method for other purposes, but doing so will result in confusion and \r\n    likely lead to problems in production.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class GarbageDisposal \r\n{\r\n  private int Dispose()  // Noncompliant\r\n  {\r\n    // ...\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class GarbageDisposal : IDisposable\r\n{\r\n  public void Dispose() \r\n  {\r\n    // ...\r\n  }\r\n}\r\n</pre>\r\nor\r\n<pre>\r\npublic class GarbageDisposal \r\n{\r\n  private int Grind()\r\n  {\r\n    // ...\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    Methods named <code>Dispose</code> and invoked from the <code>IDisposable.Dispose</code> implementation are not reported.\r\n</p>\r\n<pre>\r\npublic class GarbageDisposal : IDisposable\r\n{\r\n  protected virtual void Dispose(bool disposing)\r\n  {\r\n    //...\r\n  }\r\n  public void Dispose() \r\n  {\r\n    Dispose(true);\r\n    GC.SuppressFinalize(this);\r\n  }\r\n}\r\n</pre>\r\n",
    "Tags": "pitfall"
  },
  {
    "Key": "S1118",
    "Title": "Utility classes should not have public constructors",
    "Description": "<p>\r\n    Utility classes, which are collections of <code>static</code> members, are not meant to be instantiated. Even\r\n    <code>abstract</code> utility classes, which can be extended, should not have <code>public</code> constructors.\r\n</p>\r\n<p>\r\n    C# adds an implicit public constructor to every class which does not explicitly define at least one constructor. Hence, at\r\n    least one <code>protected</code> constructor should be defined if you wish to subclass this utility class. Or the \r\n    <code>static</code> keyword should be added to the class declaration to prevent subclassing.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class StringUtils // Noncompliant\r\n{ \r\n  public static string Concatenate(string s1, string s2) \r\n  {\r\n    return s1 + s2;\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic static class StringUtils\r\n{ \r\n  public static string Concatenate(string s1, string s2) \r\n  {\r\n    return s1 + s2;\r\n  }\r\n}\r\n</pre>\r\nor\r\n<pre>\r\npublic class StringUtils\r\n{ \r\n  protected StringUtils()\r\n  {\r\n  }\r\n  public static string Concatenate(string s1, string s2) \r\n  {\r\n    return s1 + s2;\r\n  }\r\n}\r\n</pre>\r\n",
    "Tags": "design"
  },
  {
    "Key": "S1905",
    "Title": "Redundant casts should not be used",
    "Description": "<p>\r\n    Unnecessary casting expressions make the code harder to read and understand.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic int Example(int i) \r\n{\r\n  return (int) (i + 42); // Noncompliant\r\n}\r\npublic IEnumerable&lt;int&gt; ExampleCollection(IEnumerable&lt;int&gt; coll) \r\n{\r\n  return coll.Reverse().OfType&lt;int&gt;(); // Noncompliant\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic int Example(int i) \r\n{\r\n  return i + 42;\r\n}\r\npublic IEnumerable&lt;int&gt; ExampleCollection(IEnumerable&lt;int&gt; coll) \r\n{\r\n  return coll.Reverse();\r\n}\r\n</pre>\r\n",
    "Tags": "clumsy, cwe, misra"
  },
  {
    "Key": "S2330",
    "Title": "Array covariance should not be used",
    "Description": "<p>\r\n    Array covariance is the principle that if an implicit or explicit reference conversion exits from type <code>A</code> to\r\n    <code>B</code>, then the same conversion exists from the array type <code>A[]</code> to <code>B[]</code>.\r\n</p>\r\n<p>\r\n    While this array conversion can be useful in readonly situations to pass instances of <code>A[]</code> wherever\r\n    <code>B[]</code> is expected, it must be used with care, since assigning an instance of <code>B</code> into an array of \r\n    <code>A</code> will cause an <code>ArrayTypeMismatchException</code> to be thrown at runtime.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nabstract class Fruit { }\r\nclass Apple : Fruit { }\r\nclass Orange : Fruit { }\r\n\r\nclass Program\r\n{\r\n  static void Main(string[] args)\r\n  {\r\n    Fruit[] fruits = new Apple[1]; // Noncompliant - array covariance is used\r\n    FillWithOranges(fruits);\r\n  }\r\n\r\n  // Just looking at the code doesn't reveal anything suspicious\r\n  static void FillWithOranges(Fruit[] fruits)\r\n  {\r\n    for (int i = 0; i < fruits.Length; i++)\r\n    {\r\n      fruits[i] = new Orange(); // Will throw an ArrayTypeMismatchException\r\n    }\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nabstract class Fruit { }\r\nclass Apple : Fruit { }\r\nclass Orange : Fruit { }\r\n\r\nclass Program\r\n{\r\n  static void Main(string[] args)\r\n  {\r\n    Orange[] fruits = new Orange[1]; // Compliant\r\n    FillWithOranges(fruits);\r\n  }\r\n\r\n  static void FillWithOranges(Orange[] fruits)\r\n  {\r\n    for (int i = 0; i < fruits.Length; i++)\r\n    {\r\n      fruits[i] = new Orange();\r\n    }\r\n  }\r\n}\r\n</pre>\r\n",
    "Tags": "pitfall"
  },
  {
    "Key": "S2971",
    "Title": "\"IEnumerable\" LINQs should be simplified",
    "Description": "<p>\r\n    In the interests of readability, code that can be simplified should be simplified. To that end, there are several\r\n    ways <code>IEnumerable LINQ</code>s can be simplified\r\n</p>\r\n<ul>\r\n    <li>Use <code>OfType</code> instead of using <code>Select</code> with <code>as</code> to type cast elements and then \r\n    null-checking in a query expression to choose elements based on type.</li>\r\n    <li>Use <code>OfType</code> instead of using <code>Where</code> and the <code>is</code> operator, followed by a cast \r\n    in a <code>Select</code></li>\r\n    <li>Use an expression in <code>Any</code> instead of <code>Where(element => [expression]).Any()</code>.</li>\r\n</ul>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nseq1.Select(element => element as T).Any(element => element != null);  // Noncompliant; use OfType\r\nseq2.Select(element => element as T).Any(element => element != null &amp;&amp; CheckCondition(element));  // Noncompliant; use OfType\r\nseq3.Where(element => element is T).Select(element => element as T); // Noncompliant; use OfType\r\nseq4.Where(element => element is T).Select(element => (T)element); // Noncompliant; use OfType\r\nseq.Where(element => [expression]).Any();  // Noncompliant; use Any([expression])\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nseq1.OfType&lt;T&gt;().Any();\r\nseq2.OfType&lt;T&gt;().Any(element => CheckCondition(element));\r\nseq3.OfType&lt;T&gt;();\r\nseq4.OfType&lt;T&gt;();\r\nseq.Any(element => [expression])\r\n</pre>\r\n",
    "Tags": "clumsy"
  },
  {
    "Key": "S2995",
    "Title": "\"Object.ReferenceEquals\" should not be used for value types",
    "Description": "<p>\r\n    Using <code>Object.ReferenceEquals</code> to compare the references of two value types simply won't return the \r\n    expected results most of the time because such types are passed by value, not by reference.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class MyClass\r\n{\r\n  private MyStruct myStruct;\r\n\r\n  public void DoSomething(MyStruct s1) {\r\n    int a = 1;\r\n    int b = 1;\r\n\r\n    if (Object.ReferenceEquals(myStruct, s1))  // Noncompliant; this can never be true\r\n    {\r\n      // ...\r\n    }\r\n    else if (Object.ReferenceEquals(a,b)) // Noncompliant\r\n    {\r\n      // ...\r\n    }\r\n  }\r\n}\r\n</pre>\r\n",
    "Tags": "bug"
  },
  {
    "Key": "S2996",
    "Title": "\"ThreadStatic\" fields should not be initialized",
    "Description": "<p>\r\n    When an object has a field annotated with <code>ThreadStatic</code>, that field is shared within a given thread,\r\n    but unique across threads. Since a class' static initializer is only invoked for the \r\n    first thread created, it also means that only the first thread will have the expected initial values.\r\n</p>\r\n<p>\r\n    Instead, allow such fields to be initialized to their default values or make the initialization lazy.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class Foo\r\n{\r\n  [ThreadStatic]\r\n  public static object PerThreadObject = new object(); // Noncompliant. Will be null in all the threads except the first one.\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class Foo\r\n{\r\n  [ThreadStatic]\r\n  public static object _perThreadObject;\r\n  public static object PerThreadObject \r\n  {\r\n    get \r\n    {\r\n      if (_perThreadObject == null) \r\n      {\r\n        _perThreadObject = new object();\r\n      }\r\n      return _perThreadObject;\r\n    }\r\n  }\r\n}\r\n</pre>\r\n",
    "Tags": "bug, multi-threading"
  },
  {
    "Key": "S3005",
    "Title": "\"ThreadStatic\" should not be used on non-static fields",
    "Description": "<p>\r\n    When a non-<code>static</code> class field is annotated with <code>ThreadStatic</code>, the code seems to show that the\r\n    field can have different values for different calling threads, but that's not the case, since the <code>ThreadStatic</code>\r\n    attribute is simply ignored on non-<code>static</code> fields.\r\n</p>\r\n<p>\r\n    So <code>ThreadStatic</code> should either be removed or replaced with a use of the <code>ThreadLocal&lt;T&gt;</code> class, \r\n    which gives a similar behavior for non-<code>static</code> fields.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class MyClass \r\n{\r\n  [ThreadStatic]  // Noncompliant\r\n  private int count = 0;\r\n\r\n  // ...\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class MyClass \r\n{\r\n  private int count = 0;\r\n\r\n  // ...\r\n}\r\n</pre>\r\nor\r\n<pre>\r\npublic class MyClass \r\n{\r\n  private readonly ThreadLocal&lt;int&gt; count = new ThreadLocal&lt;int&gt;();\r\n  public int Count\r\n  {\r\n    get { return count.Value; }\r\n    set { count.Value = value; }\r\n  }\r\n  // ...\r\n}\r\n</pre>\r\n",
    "Tags": "bug, unused"
  },
  {
    "Key": "S2290",
    "Title": "Field-like events should not be virtual",
    "Description": "<p>\r\n    Field-like events are events that do not have explicit <code>add</code> and <code>remove</code> methods. The compiler\r\n    generates a <code>private</code> <code>delegate</code> field to back the event, as well as generating the implicit \r\n    <code>add</code> and <code>remove</code> methods.\r\n</p>\r\n<p>\r\n    When a <code>virtual</code> field-like <code>event</code> is overridden by another field-like <code>event</code>,\r\n    the behavior of the C# compiler is to generate a new <code>private</code> <code>delegate</code> field in the derived\r\n    class, separate from the parent's field. This results in multiple and separate events being created, which is rarely \r\n    what's actually intended.\r\n</p>\r\n<p>\r\n    To prevent this, remove the <code>virtual</code> designation from the parent class event.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nabstract class Car\r\n{\r\n  public virtual event EventHandler OnRefueled; // Noncompliant\r\n\r\n  public void Refuel()\r\n  {\r\n    // This OnRefueld will always be null\r\n     if (OnRefueled != null)\r\n     {\r\n       OnRefueled(this, null);\r\n     }\r\n  }\r\n}\r\n\r\nclass R2 : Car\r\n{\r\n  public override event EventHandler OnRefueled;\r\n}\r\n\r\nclass Program\r\n{\r\n  static void Main(string[] args)\r\n  {\r\n    var r2 = new R2();\r\n    r2.OnRefueled += new EventHandler((o, a) =>\r\n    {\r\n      Console.WriteLine(\"This event will never be called\");\r\n    });\r\n    r2.Refuel();\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nabstract class Car\r\n{\r\n  public event EventHandler OnRefueled; // Compliant\r\n\r\n  public void Refuel()\r\n  {\r\n    if (OnRefueled != null)\r\n    {\r\n      OnRefueled(this, null);\r\n    }\r\n  }\r\n}\r\n\r\nclass R2 : Car {}\r\n\r\nclass Program\r\n{\r\n  static void Main(string[] args)\r\n  {\r\n    var r2 = new R2();\r\n    r2.OnRefueled += new EventHandler((o, a) =>\r\n    {\r\n      Console.WriteLine(\"This event will be called\");\r\n    });\r\n    r2.Refuel();\r\n  }\r\n}\r\n</pre>\r\n",
    "Tags": "bug"
  },
  {
    "Key": "S2997",
    "Title": "\"IDisposables\" created in a \"using\" statement should not be returned",
    "Description": "<p>\r\n    Typically you want to use <code>using</code> to create a local <code>IDisposable</code> variable; it will trigger\r\n    disposal of the object when control passes out of the block's scope. The exception to this rule is when your\r\n    method returns that <code>IDisposable</code>. In that case <code>using</code> disposes of the object before the\r\n    caller can make use of it, likely causing exceptions at runtime. So you should either remove <code>using</code> or \r\n    avoid returning the <code>IDisposable</code>.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic FileStream WriteToFile(string path, string text)\r\n{\r\n  using (var fs = File.Create(path)) // Noncompliant\r\n  {\r\n    var bytes = Encoding.UTF8.GetBytes(text);\r\n    fs.Write(bytes, 0, bytes.Length);\r\n    return fs; \r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic FileStream WriteToFile(string path, string text)\r\n{\r\n  var fs = File.Create(path);\r\n  var bytes = Encoding.UTF8.GetBytes(text);\r\n  fs.Write(bytes, 0, bytes.Length);\r\n  return fs;\r\n}\r\n</pre>\r\n",
    "Tags": "bug"
  },
  {
    "Key": "S907",
    "Title": "\"goto\" statement should not be used",
    "Description": "<p>\r\n    <code>goto</code> is an unstructured control flow statement. It makes code less readable and maintainable.\r\n    Structured control flow statements such as <code>if</code>, <code>for</code>, <code>while</code>, \r\n    <code>continue</code> or <code>break</code> should be used instead.\r\n</p>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li>MISRA C:2004, 14.4 - The goto statement shall not be used.</li>\r\n    <li>MISRA C:2012, 15.1 - The goto statement should not be used</li>\r\n</ul>\r\n",
    "Tags": "brain-overload, misra"
  },
  {
    "Key": "S2551",
    "Title": "Types and \"this\" should not be used for locking",
    "Description": "<p>\r\n    Locking on the current object instance (i.e. <code>this</code>), or on a <code>Type</code> object increases the chance \r\n    of deadlocks because any other thread could acquire (or attempt to acquire) the same lock for another unrelated purpose.\r\n</p>\r\n<p>\r\n    Instead, a new, private <code>object</code> should be created and used for the lock.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic void MyLockingMethod()\r\n{\r\n  lock (this) // Noncompliant\r\n  {\r\n    // ...\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nobject lockObj = new object();\r\n\r\npublic void MyLockingMethod()\r\n{\r\n  lock (lockObj)\r\n  {\r\n    // ...\r\n  }\r\n}\r\n</pre>\r\n",
    "Tags": "bug, multi-threading"
  },
  {
    "Key": "S2955",
    "Title": "Generic parameters not constrained to reference types should not be compared to \"null\"",
    "Description": "<p>\r\n    When constraints have not been applied to restrict a generic type parameter to be a reference type,\r\n    then a value type, such as a <code>struct</code>, could also be passed. In such cases, comparing the\r\n    type parameter to <code>null</code> would always be false, because a <code>struct</code> can\r\n    be empty, but never <code>null</code>. If a value type is truly what's expected, then the comparison should use\r\n    <code>default()</code>. If it's not, then constraints should be added so that no value type can be \r\n    passed.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nprivate bool IsDefault&lt;T&gt;(T value) \r\n{\r\n  if (value == null) // Noncompliant\r\n  {\r\n    // ...\r\n  }\r\n  // ...\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nprivate bool IsDefault&lt;T&gt;(T value) \r\n{\r\n  if(object.Equals(value, default(T)))\r\n  {\r\n    // ...\r\n  }\r\n  // ...\r\n}\r\n</pre>\r\nor\r\n<pre>\r\nprivate bool IsDefault&lt;T&gt;(T value) where T : class\r\n{\r\n  if (value == null) \r\n  {\r\n    // ...\r\n  }\r\n  // ...\r\n}\r\n</pre>\r\n",
    "Tags": "bug"
  },
  {
    "Key": "S2934",
    "Title": "Property assignments should not be made for \"readonly\" fields not constrained to reference types",
    "Description": "<p>\r\n    While the properties of a <code>readonly</code> reference type field can still be changed after initialization,\r\n    those of a <code>readonly</code> value field, such as a <code>struct</code>, cannot.\r\n</p>\r\n<p>\r\n    If the member could be either a <code>class</code> or a <code>struct</code> then assignment to its properties \r\n    could be unreliable, working sometimes but not others.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\ninterface IPoint\r\n{\r\n  int X { get; set; }\r\n  int Y { get; set; }\r\n}\r\n\r\nclass PointManager&lt;T&gt; where T: IPoint \r\n{\r\n  readonly T point;  // this could be a struct\r\n  public PointManager(T point)\r\n  {\r\n    this.point = point;\r\n  }\r\n\r\n  public void MovePointVertically(int newX)\r\n  {\r\n    point.X = newX; //Noncompliant; if point is a struct, then nothing happened\r\n    Console.WriteLine(point.X);\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\ninterface IPoint\r\n{\r\n  int X { get; set; }\r\n  int Y { get; set; }\r\n}\r\n\r\nclass PointManager&lt;T&gt; where T : IPoint \r\n{\r\n  readonly T point;  // this could be a struct\r\n  public PointManager(T point)\r\n  {\r\n    this.point = point;\r\n  }\r\n\r\n  public void MovePointVertically(int newX) // assignment has been removed\r\n  {\r\n    Console.WriteLine(point.X);\r\n  }\r\n}\r\n</pre>\r\nor\r\n<pre>\r\ninterface IPoint\r\n{\r\n  int X { get; set; }\r\n  int Y { get; set; }\r\n}\r\n\r\nclass PointManager&lt;T&gt; where T : class, IPoint \r\n{\r\n  readonly T point;  // this can only be a class\r\n  public PointManager(T point)\r\n  {\r\n    this.point = point;\r\n  }\r\n\r\n  public void MovePointVertically(int newX)\r\n  {\r\n    point.X = newX;  // this assignment is guaranteed to work\r\n    Console.WriteLine(point.X);\r\n  }\r\n}\r\n</pre>\r\n",
    "Tags": "bug"
  },
  {
    "Key": "S2357",
    "Title": "Fields should be private",
    "Description": "<p>\r\n    Fields should not be part of an API, and therefore should always be private. Indeed, they\r\n    cannot be added to an interface for instance, and validation cannot be added later on without\r\n    breaking backward compatiblity. Instead, developers should encapsulate their fields into\r\n    properties. Explicit property getters and setters can be introduced for validation purposes \r\n    or to smooth the transition to a newer system.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class Foo\r\n{\r\n  public int MagicNumber = 42; \r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class Foo\r\n{\r\n  public int MagicNumber \r\n  { \r\n    get { return 42; }\r\n  }\r\n}\r\n</pre>\r\nor\r\n<pre>\r\npublic class Foo\r\n{\r\n  private int MagicNumber = 42; \r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    <code>static</code> and <code>const</code> fields are ignored.\r\n</p>\r\n",
    "Tags": "pitfall"
  },
  {
    "Key": "S2223",
    "Title": "Non-constant static fields should not be visible",
    "Description": "<p>\r\n    A <code>static</code> field that is neither constant nor read-only is not thread-safe. Correctly accessing\r\n    these fields from different threads needs synchronization with <code>lock</code>s. Improper synchronization\r\n    may lead to unexpected results, thus publicly visible static fields are best suited for storing non-changing\r\n    data shared by many consumers. To enforce this intent, these fields should be marked <code>readonly</code> or\r\n    converted to a constant.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class Math\r\n{\r\n  public static double Pi = 3.14;  // Noncompliant\r\n} \r\n</pre>\r\nor\r\n<pre>\r\npublic class Shape\r\n{\r\n  public static Shape Empty = new EmptyShape();  // Noncompliant\r\n\r\n  private class EmptyShape : Shape\r\n  {\r\n  } \r\n} \r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class Math\r\n{\r\n  public const double Pi = 3.14;\r\n} \r\n</pre>\r\nor\r\n<pre>\r\npublic class Shape\r\n{\r\n  public static readonly Shape Empty = new EmptyShape(); \r\n\r\n  private class EmptyShape : Shape\r\n  {\r\n  } \r\n} \r\n</pre>",
    "Tags": "pitfall"
  },
  {
    "Key": "S2930",
    "Title": "\"IDisposables\" should be disposed",
    "Description": "<p>\r\n    You can't rely on garbage collection to clean up everything. Specifically, you can't count on\r\n    it to release non-memory resources such as <code>File</code>s. For that, there's the <code>IDisposable</code>\r\n    interface, and the contract that <code>Dispose</code> will always be called on such objects.\r\n</p>\r\n<p>\r\n    When an <code>IDisposable</code> is a class member, then it's up to that class to call <code>Dispose</code>\r\n    on it, ideally in its own <code>Dispose</code> method. If it's a local variable, then it should be instantiated\r\n    with a <code>using</code> clause to prompt automatic cleanup when it goes out of scope.\r\n</p>\r\n<p>\r\n    This rule raises issues on members that are never <code>Dispose</code>d.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class ResourceHolder \r\n{\r\n  private FileStream fs;  // Noncompliant; Dispose is never called\r\n  public void OpenResource(string path)\r\n  {\r\n    this.fs = new FileStream(path, FileMode.Open);\r\n  }\r\n  public void CloseResource()\r\n  {\r\n    this.fs.Close();\r\n  }\r\n  public void WriteToFile(string path, string text)\r\n  {\r\n    var fs = new FileStream(path, FileMode.Open);  // Noncompliant\r\n    var bytes = Encoding.UTF8.GetBytes(text);\r\n    fs.Write(bytes, 0, bytes.Length);\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class ResourceHolder : IDisposable\r\n{\r\n  private FileStream fs;\r\n  public void OpenResource(string path)\r\n  {\r\n    this.fs = new FileStream(path, FileMode.Open);\r\n  }\r\n  public void CloseResource()\r\n  {\r\n    this.fs.Close();\r\n  }\r\n\r\n  public void Dispose() \r\n  {\r\n    this.fs.Dispose();\r\n  }\r\n\r\n  public void WriteToFile(string path, string text)\r\n  {\r\n    using (var fs = new FileStream(path, FileMode.Open))\r\n    {\r\n      var bytes = Encoding.UTF8.GetBytes(text);\r\n      fs.Write(bytes, 0, bytes.Length);\r\n    }\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\nLocal <code>IDisposable</code>s returned from methods are ignored, as are local <code>IDisposable</code>s that are \r\ninitialized with non-local <code>IDisposable</code>s.\r\n<pre>\r\n  public Stream WriteToFile(string path, string text)\r\n  {\r\n    var fs = new FileStream(path, FileMode.Open); // Compliant, because it is returned\r\n    var bytes = Encoding.UTF8.GetBytes(text);\r\n    fs.Write(bytes, 0, bytes.Length);\r\n    return fs;\r\n  }\r\n\r\n  public void ReadFromStream(Stream s)\r\n  {\r\n    var sr = new StreamReader(s); // Compliant as it would close the underlying stream.\r\n    // ...\r\n  }\r\n</pre>\r\n\r\n<h2>See</h2>\r\n<ul>\r\n    <li> <a href=\"http://cwe.mitre.org/data/definitions/459.html\">MITRE, CWE-459</a> - Incomplete Cleanup</li>\r\n</ul>\r\n",
    "Tags": "bug, cwe, denial-of-service, security"
  },
  {
    "Key": "S2933",
    "Title": "Fields that are only assigned in the constructor should be \"readonly\"",
    "Description": "<p>\r\n    <code>readonly</code> fields can only be assigned in a class constructor. If a class has a field that's\r\n    not marked <code>readonly</code> but is only set in the constructor, it could cause confusion about the\r\n    field's intended use. To avoid confusion, such fields should be marked <code>readonly</code> to make their \r\n    intended use explicit, and to prevent future maintainers from inadvertently changing their use.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass Person\r\n{\r\n  int _birthYear;  // Noncompliant\r\n  Person(int birthYear) \r\n  {\r\n    _birthYear = birthYear;\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nclass Person\r\n{\r\n  readonly int _birthYear;\r\n  Person(int birthYear) \r\n  {\r\n    _birthYear = birthYear;\r\n  }\r\n}\r\n</pre>\r\n",
    "Tags": "confusing"
  },
  {
    "Key": "S1155",
    "Title": "\"Any()\" should be used to test for emptiness",
    "Description": "<p>\r\n    Using <code>.Count() > 0</code> to test for emptiness works, but using <code>.Any()</code> makes the intent clearer, \r\n    and the code more readable.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nprivate static bool HasContent(IEnumerable&lt;string&gt; strings)\r\n{\r\n  return strings.Count() > 0; // Noncompliant\r\n}\r\nprivate static bool HasContent2(&lt;string&gt; strings)\r\n{\r\n  return strings.Count() >= 1; // Noncompliant\r\n}\r\nprivate static bool IsEmpty(&lt;string&gt; strings)\r\n{\r\n  return strings.Count() == 0; // Noncompliant\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nprivate static bool HasContent(&lt;string&gt; strings)\r\n{\r\n  return strings.Any();\r\n}\r\n\r\nprivate static bool IsEmpty(&lt;string&gt; strings)\r\n{\r\n  return !strings.Any();\r\n}\r\n</pre>",
    "Tags": "clumsy"
  },
  {
    "Key": "S927",
    "Title": "\"partial\" method parameter names should match",
    "Description": "<p>\r\n    When the parameters to the implementation of a <code>partial</code> method don't match those\r\n    in the signature declaration, then confusion is almost guaranteed. Either the implementer was\r\n    confused when he renamed, swapped or mangled the parameter names in the implementation, or \r\n    callers will be confused.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npartial class Point\r\n{\r\n  partial void OnChange(int x, int y);\r\n}\r\n\r\npartial class Point\r\n{\r\n  int x = 0;\r\n  int y = 0;\r\n\r\n  partial void OnChange(int x, int yk)  // Noncompliant\r\n  {\r\n    this.x = x;\r\n    this.y = yk;\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npartial class Point\r\n{\r\n  partial void OnChange(int x, int y);\r\n}\r\n\r\npartial class Point\r\n{\r\n  int x = 0;\r\n  int y = 0;\r\n\r\n  partial void OnChange(int x, int y)\r\n  {\r\n    this.x = x;\r\n    this.y = y;\r\n  }\r\n}\r\n</pre>\r\n",
    "Tags": "cert, misra, pitfall"
  },
  {
    "Key": "S2931",
    "Title": "Classes with \"IDisposable\" members should implement \"IDisposable\"",
    "Description": "<p>\r\n    Classes with <code>IDisposable</code> members are responsible for cleaning up those members by calling\r\n    their <code>Dispose</code> methods. The best practice here is for the owning class to itself implement\r\n    <code>IDisposable</code> and call its members' <code>Dispose</code> methods from its own \r\n    <code>Dispose</code> method.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class ResourceHolder   // Noncompliant; doesn't implement IDisposable\r\n{\r\n  private FileStream fs;  // This member is never Dispose'd\r\n  public void OpenResource(string path)\r\n  {\r\n    this.fs = new FileStream(path, FileMode.Open);\r\n  }\r\n  public void CloseResource()\r\n  {\r\n    this.fs.Close();\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class ResourceHolder : IDisposable\r\n{\r\n  private FileStream fs;\r\n  public void OpenResource(string path)\r\n  {\r\n    this.fs = new FileStream(path, FileMode.Open);\r\n  }\r\n  public void CloseResource()\r\n  {\r\n    this.fs.Close();\r\n  }\r\n  public void Dispose() \r\n  {\r\n    this.fs.Dispose();\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li> <a href=\"http://cwe.mitre.org/data/definitions/459.html\">MITRE, CWE-459</a> - Incomplete Cleanup</li>\r\n</ul>\r\n",
    "Tags": "bug, cwe, denial-of-service, security"
  },
  {
    "Key": "S1066",
    "Title": "Collapsible \"if\" statements should be merged",
    "Description": "<p>\r\n    Merging collapsible <code>if</code> statements increases the code's readability.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif (condition1) \r\n{\r\n  if (condition2) \r\n  {        \r\n    ...\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (condition1 &amp;&amp; condition2) \r\n{        \r\n  ...\r\n}\r\n</pre>\r\n",
    "Tags": "clumsy"
  },
  {
    "Key": "S1117",
    "Title": "Local variables should not shadow class fields",
    "Description": "<p>\r\n    Shadowing fields with a local variable or with a method parameter is a bad practice that\r\n    reduces code readability: It makes it confusing to know whether the field or the variable \r\n    is being used.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass Foo \r\n{\r\n  public int myField;\r\n\r\n  public void doSomething() \r\n  {\r\n    int myField = 0;\r\n    ...\r\n  }\r\n\r\n  public void doSomethingElse(int myField) \r\n  {\r\n    ...\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    Constructors are exceptions; it is common practice to name arguments for the fields the \r\n    values will be assigned to. Static methods are also excepted.\r\n</p>\r\n\r\n<pre>\r\nclass Foo {\r\n  public int myField;\r\n\r\n  public Foo(int myField) \r\n  {\r\n    this.myField = myField;\r\n  }\r\n\r\n  public static Foo build(int myField) \r\n  {\r\n    ...\r\n  }\r\n}\r\n</pre>\r\n",
    "Tags": "pitfall"
  },
  {
    "Key": "S1313",
    "Title": "IP addresses should not be hardcoded",
    "Description": "<p>\r\n    Hardcoding an IP address into source code is a bad idea for several reasons:\r\n    <ul>\r\n        <li>\r\n            a recompile is required if the address changes\r\n        </li>\r\n        <li>\r\n            it forces the same address to be used in every environment (dev, sys, qa, prod)\r\n        </li>\r\n        <li>\r\n            it places the responsibility of setting the value to use in production on the shoulders of the developer\r\n        </li>\r\n        <li>\r\n            it allows attackers to decompile the code and thereby discover a potentially sensitive address\r\n        </li>\r\n    </ul>\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvar ip = \"127.0.0.1\";\r\nvar address = IPAddress.Parse(ip);\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvar ip = ConfigurationManager.AppSettings[\"myapplication.ip\"];\r\nvar address = IPAddress.Parse(ip);\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li> <a href=\"https://www.securecoding.cert.org/confluence/x/qQCHAQ\">CERT, MSC03-J</a> - Never hard code sensitive information</li>\r\n</ul>",
    "Tags": "cert, security"
  },
  {
    "Key": "S2225",
    "Title": "\"ToString()\" method should not return null",
    "Description": "<p>\r\n    Calling <code>ToString()</code> on an object should always return a string. Returning <code>null</code> instead contravenes the method's implicit contract.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic override string ToString () \r\n{\r\n  if (this.collection.Count == 0) \r\n  {\r\n    return null; // Noncompliant\r\n  } \r\n  else \r\n  {\r\n    // ...\r\n \r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic override string ToString () \r\n{\r\n  if (this.collection.Count == 0) \r\n  {\r\n    return \"\";\r\n  } \r\n  else \r\n  {\r\n    // ...\r\n \r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li><a href=\"http://cwe.mitre.org/data/definitions/476.html\">MITRE CWE-476</a> - NULL Pointer Dereference</li>\r\n</ul>\r\n",
    "Tags": "bug, cwe"
  },
  {
    "Key": "S1244",
    "Title": "Floating point numbers should not be tested for equality",
    "Description": "<p>\r\n    Floating point math is imprecise because of the challenges of storing such values in a binary\r\n    representation. Even worse, floating point math is not associative; push a <code>float</code> or a <code>double</code>\r\n    through a series of simple mathematical operations and the answer will be different based on\r\n    the order of those operation because of the rounding that takes place at each step.\r\n</p>\r\n<p>\r\n    Even simple floating point assignments are not simple:\r\n</p>\r\n<pre>\r\nfloat f = 0.1f; // 0.100000001490116119384765625\r\ndouble d = 0.1; // 0.1000000000000000055511151231257827021181583404541015625\r\n</pre>\r\n\r\n<p>\r\n    (Results will vary based on compiler and compiler settings)\r\n</p>\r\n<p>\r\n    Therefore, the use of the equality (<code>==</code>) and inequality (<code>!=</code>) operators on \r\n    <code>float</code> or <code>double</code> values is almost always an error.\r\n</p>\r\n<p>\r\n    This rule checks for the use of direct and indirect equality/inequailty tests on floats and doubles.\r\n</p>\r\n\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nfloat myNumber = 3.146f;\r\nif ( myNumber == 3.146f ) //Noncompliant. Because of floating point imprecision, this will be false\r\n{  \r\n  // ...\r\n}\r\n\r\nif (myNumber &lt;= 3.146f &amp;&amp; mNumber &gt;= 3.146f) // Noncompliant indirect equality test\r\n{ \r\n  // ...\r\n}\r\n\r\nif (myNumber &lt; 4 || myNumber &gt; 4) // Noncompliant indirect inequality test \r\n{ \r\n  // ...\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n<ul>\r\n    <li>MISRA C:2004, 13.3 - Floating-point expressions shall not be tested for equality or inequality.</li>\r\n    <li>MISRA C++:2008, 6-2-2 - Floating-point expressions shall not be directly or indirectly tested for equality or inequality</li>\r\n</ul>\r\n",
    "Tags": "bug, misra"
  },
  {
    "Key": "S1854",
    "Title": "Dead stores should be removed",
    "Description": "<p>\r\n    A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction.\r\n    Calculating or retrieving a value only to then overwrite it or throw it away, could indicate a serious error in \r\n    the code. Even if it's not an error, it is at best a waste of resources. Therefore all calculated values should be used.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvoid calculateRate(int a, int b)\r\n{\r\n  int i;\r\n  \r\n  i = a + b; // Noncompliant; calculation result not used before value is overwritten\r\n  i = doSomething();  // Noncompliant; retrieved value not used\r\n  for (i = 0; i &lt; 10; i++) \r\n  { \r\n    //  ...\r\n  }\r\n  // ...\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvoid calculateRate(int a, int b)\r\n{\r\n  int i;\r\n\r\n  i = doSomething();\r\n  i += a + b;\r\n  storeI(i)\r\n\r\n  for (i = 0; i &lt; 10; i++) \r\n  { \r\n    //  ...\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li><a href=\"http://cwe.mitre.org/data/definitions/563.html\">MITRE, CWE-563</a> - Assignment to Variable without Use ('Unused Variable')</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/QYA5\">CERT, MSC13-C</a> - Detect and remove unused values</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/S4IyAQ\">CERT, MSC13-CPP</a> - Detect and remove unused values</li>\r\n</ul>\r\n",
    "Tags": "bug, cert, cwe, unused"
  },
  {
    "Key": "S2328",
    "Title": "\"GetHashCode\" should not reference mutable fields",
    "Description": "<p>\r\n    <code>GetHashCode</code> is used to file an object in a <code>Dictionary</code> or <code>Hashtable</code>.\r\n    If <code>GetHashCode</code> uses non-<code>readonly</code> fields and those fields change after the object\r\n    is stored, the object immediately becomes mis-filed in the <code>Hashtable</code>. Any subsequent test to \r\n    see if the object is in the <code>Hashtable</code> will return a false negative.\r\n</p>\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class Person \r\n{\r\n  public int age;\r\n  public string name;\r\n\r\n  public override int GetHashCode() \r\n  {\r\n    int hash = 12;\r\n    hash += this.age.GetHashCode(); // Noncompliant\r\n    hash += this.name.GetHashCode(); // Noncompliant\r\n    return hash;\r\n  }\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class Person \r\n{\r\n  public readonly DateTime birthday;\r\n  public string name;\r\n\r\n  public override int GetHashCode() \r\n  {\r\n    int hash = 12;\r\n    hash += this.birthday.GetHashCode();\r\n    return hash;\r\n  }\r\n</pre>\r\n",
    "Tags": "bug"
  },
  {
    "Key": "S2228",
    "Title": "Console logging should not be used",
    "Description": "<p>\r\n    Debug statements are always useful during development. But include them in production code - particularly \r\n    in code that runs client-side - and you run the risk of inadvertently exposing sensitive information.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nprivate void DoSomething ()\r\n{\r\n  // ...\r\n  Console.WriteLine (\"so far, so good...\"); // Noncompliant\r\n  // ...\r\n}\r\n</pre>\r\n\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li> <a href=\"https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure\">OWASP Top Ten 2013 Category A6</a> - Sensitive Data Exposure</li>\r\n</ul>",
    "Tags": "security, owasp-a6"
  },
  {
    "Key": "S2070",
    "Title": "SHA-1 and Message-Digest hash algorithms should not be used",
    "Description": "<p>\r\n    The MD5 algorithm and its successor, SHA-1, are no longer considered secure, because it is too easy to\r\n    create hash collisions with them. That is, it takes too little computational effort to come up with a\r\n    different input that produces the same MD5 or SHA-1 hash, and using the new, same-hash value gives an\r\n    attacker the same access as if he had the originally-hashed value. This applies as well to the other\r\n    Message-Digest algorithms: MD2, MD4, MD6.\r\n</p>\r\n\r\n<p>\r\n    This rule tracks usage of the <code>System.Security.Cryptography.CryptoConfig.CreateFromName()</code>, and <code>System.Security.Cryptography.HashAlgorithm.Create()</code> methods to instantiate MD5 or SHA-1 algorithms, and of derived class instances of <code>System.Security.Cryptography.SHA1</code> and <code>System.Security.Cryptography.MD5</code>.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvar hashProvider1 = new MD5CryptoServiceProvider(); //Noncompliant\r\nvar hashProvider2 = (HashAlgorithm)CryptoConfig.CreateFromName(\"MD5\"); //Noncompliant\r\nvar hashProvider3 = new SHA1Managed(); //Noncompliant\r\nvar hashProvider4 = HashAlgorithm.Create(\"SHA1\"); //Noncompliant\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvar hashProvider1 = new SHA256Managed();\r\nvar hashProvider2 = (HashAlgorithm)CryptoConfig.CreateFromName(\"SHA256Managed\");\r\nvar hashProvider3 = HashAlgorithm.Create(\"SHA256Managed\");\r\n</pre>\r\n\r\n<ul>\r\n    <li> <a href=\"http://cwe.mitre.org/data/definitions/328\">MITRE, CWE-328</a> - Reversible One-Way Hash</li>\r\n    <li> <a href=\"http://cwe.mitre.org/data/definitions/327\">MITRE, CWE-327</a> - Use of a Broken or Risky Cryptographic Algorithm</li>\r\n    <li> <a href=\"https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure\">OWASP Top Ten 2013 Category A6</a> - Sensitive Data Exposure</li>\r\n    <li> <a href=\"http://www.sans.org/top25-software-errors/\">SANS Top 25</a> - Porous Defenses</li>\r\n    <li>Derived from FindSecBugs rule <a href=\"http://h3xstream.github.io/find-sec-bugs/bugs.htm#WEAK_MESSAGE_DIGEST\">MessageDigest Is Weak</a></li>\r\n</ul>",
    "Tags": "cwe, owasp-a6, sans-top25-porous, security"
  },
  {
    "Key": "S2123",
    "Title": "Values should not be uselessly incremented",
    "Description": "<p>\r\n    A value that is incremented or decremented and then not stored is at best wasted code and at worst a bug.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic int pickNumber() \r\n{\r\n  int i = 0;\r\n  int j = 0;\r\n\r\n  i = i++; // Noncompliant; i is still zero\r\n\r\n  return j++; // Noncompliant; 0 returned\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic int pickNumber() \r\n{\r\n  int i = 0;\r\n  int j = 0;\r\n\r\n  i++; \r\n  return ++j; \r\n}\r\n</pre>\r\n",
    "Tags": "bug"
  },
  {
    "Key": "S2326",
    "Title": "Unused type parameters should be removed",
    "Description": "<p>\r\n    Type parameters that aren't used are dead code, which can only distract and possibly confuse \r\n    developers during maintenance. Therefore, unused type parameters should be removed.\r\n</p>\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class MoreMath&lt;T&gt; // Noncompliant; &lt;T&gt;is ignored\r\n{  \r\n  public int Add&lt;T&gt;(int a, int b) // Noncompliant; &lt;T&gt; is ignored\r\n  { \r\n    return a + b; \r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class MoreMath \r\n{\r\n  public int Add (int a, int b) \r\n  {\r\n    return a + b; \r\n  }\r\n}\r\n</pre>\r\n",
    "Tags": "unused"
  },
  {
    "Key": "S2325",
    "Title": "Methods and properties that don't access instance data should be static",
    "Description": "<p>\r\n    Class methods and properties that don't access instance data can and should be <code>static</code> to prevent any misunderstanding\r\n    about the contract of the method.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class Utilities\r\n{\r\n  public int MagicNum // Noncompliant\r\n  {\r\n    get \r\n    {\r\n      return 42;\r\n    }\r\n  }\r\n\r\n  private static string magicWord = \"please\";\r\n  public string MagicWord  // Noncompliant\r\n  {\r\n    get \r\n    {\r\n      return magicWord;\r\n    }\r\n    set \r\n    {\r\n      magicWord = value;\r\n    }\r\n  }\r\n\r\n  public int Sum(int a, int b)  // Noncompliant\r\n  {\r\n    return a + b;\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class Utilities\r\n{\r\n  public static int MagicNum\r\n  {\r\n    get \r\n    {\r\n      return 42;\r\n    }\r\n  }\r\n\r\n  private static string magicWord = \"please\";\r\n  public static string MagicWord \r\n  {\r\n    get \r\n    {\r\n      return magicWord;\r\n    }\r\n    set \r\n    {\r\n      magicWord = value;\r\n    }\r\n  }\r\n\r\n  public static int Sum(int a, int b)\r\n  {\r\n    return a + b;\r\n  }\r\n}\r\n</pre>\r\n",
    "Tags": "performance"
  },
  {
    "Key": "S2234",
    "Title": "Parameters should be passed in the correct order",
    "Description": "<p>\r\n    When the names of parameters in a method call match the names of the method arguments,\r\n    it contributes to clearer, more readable code. However, when the names match, but are\r\n    passed in a different order than the method arguments, it indicates a mistake in the \r\n    parameter order which will likely lead to unexpected results.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic double divide(int divisor, int dividend) \r\n{\r\n  return divisor/dividend;\r\n}\r\n\r\npublic void doTheThing() \r\n{\r\n  int divisor = 15;\r\n  int dividend = 5;\r\n\r\n  double result = divide(dividend, divisor);  // Noncompliant; operation succeeds, but result is unexpected\r\n  //...\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic double divide(int divisor, int dividend) \r\n{\r\n  return divisor/dividend;\r\n}\r\n\r\npublic void doTheThing() \r\n{\r\n  int divisor = 15;\r\n  int dividend = 5;\r\n\r\n  double result = divide(divisor, dividend);\r\n  //...\r\n}\r\n</pre>",
    "Tags": "bug"
  },
  {
    "Key": "S1940",
    "Title": "Boolean checks should not be inverted",
    "Description": "<p>\r\n    It is needlessly complex to invert the result of a boolean comparison. The opposite comparison should be made instead.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif ( !(a == 2)) { ... }  // Noncompliant\r\nbool b = !(i < 10);  // Noncompliant\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (a != 2) { ... } \r\nbool b = (i >= 10);\r\n</pre>\r\n\r\n",
    "Tags": "pitfall"
  },
  {
    "Key": "S2758",
    "Title": "The ternary operator should not return the same value regardless of the condition",
    "Description": "<p>\r\n    When the second and third operands of a ternary operator are the same, the operator will always\r\n    return the same value regardless of the condition. Either the operator itself is pointless, or a\r\n    mistake was made in coding it.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic boolean canVote(Person person) \r\n{\r\n  return person.getAge > 18 ? true : true; // Noncompliant; is this what was intended?\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic boolean canVote(Person person) \r\n{\r\n  return person.getAge > 18 ? true : false;\r\n}\r\n</pre>",
    "Tags": "bug"
  },
  {
    "Key": "S2757",
    "Title": "Reversed operators should not be used",
    "Description": "<p>\r\n    The use of operators pairs (<code>=+</code> or <code>=-</code>) where the reversed, single operator \r\n    was meant (<code>+=</code> or <code>-=</code>) will compile and run, but not produce the expected results.\r\n</p>\r\n<p>\r\n    This rule raises an issue when <code>=+</code>, and <code>=-</code> are used, but ignores the operators \r\n    when they're spaced out: <code>= +</code>, <code>= -</code>.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nint target = -5;\r\nint num = 3;\r\n\r\ntarget =- num; // Noncompliant; target = -3. Is that really what's meant?\r\ntarget =+ num; // Noncompliant; target = 3\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nint target = -5;\r\nint num = 3;\r\n\r\ntarget = -num; // Compliant; intent to assign inverse value of num is clear\r\ntarget += num;\r\n</pre>",
    "Tags": "bug"
  },
  {
    "Key": "S1121",
    "Title": "Assignments should not be made from within sub-expressions",
    "Description": "<p>\r\n    Assignments within sub-expressions are hard to spot and therefore make the code less readable.\r\n    It is also a common mistake to write <code>=</code> when <code>==</code> was meant.\r\n    Ideally, every expression should have no more than one side-effect.\r\n    Assignments inside lambda and delegate expressions are allowed.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\ndoSomething(i = 42);\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\ni = 42;\r\ndoSomething(i);   \r\n// or\r\ndoSomething(i == 42);  // Perhaps in fact the comparison operator was expected\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>Assignments in <code>while</code> statement conditions, and assignments enclosed in relational expressions are allowed.</p>\r\n",
    "Tags": "bug, cwe, misra"
  },
  {
    "Key": "S2306",
    "Title": "\"async\" and \"await\" should not be used as identifiers",
    "Description": "<p>\r\nSince C# 5.0, <code>async</code> and <code>await</code> are contextual keywords.\r\nContextual keywords do have a particular meaning in some contexts, but can still be used as variable names for example.\r\nKeywords, on the other hand, are always reserved, and therefore are not valid variable names.\r\nTo avoid any confusion though, it is best to not use <code>async</code> and <code>await</code> as identifiers.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nint await = 42; // Noncompliant\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nint someOtherName = 42;\r\n</pre>\r\n",
    "Tags": "pitfall"
  },
  {
    "Key": "S1301",
    "Title": "\"switch\" statements should have at least 3 \"case\" clauses",
    "Description": "<p>\r\n    <code>switch</code> statements are useful when there are many different cases depending on the value of the same expression.\r\n</p>\r\n<p>\r\n    For just one or two cases however, the code will be more readable with <code>if</code> statements.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nswitch (variable) \r\n{\r\n  case 0:\r\n    doSomething();\r\n    break;\r\n  default:\r\n    doSomethingElse();\r\n    break;\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (variable == 0) \r\n{\r\n  doSomething();\r\n} else \r\n{\r\n  doSomethingElse();\r\n}\r\n</pre>\r\n",
    "Tags": "misra"
  },
  {
    "Key": "S1227",
    "Title": "break statements should not be used except for switch cases",
    "Description": "<p>\r\n<code>break;</code> is an unstructured control flow statement which makes code harder to read.\r\nIdeally, every loop should have a single termination condition.\r\n</p>\r\n\r\n<p>The following code:</p>\r\n\r\n<pre>\r\nint i = 0;\r\nwhile (true)\r\n{\r\n  if (i == 10)\r\n  {\r\n    break;      // Non-Compliant\r\n  }\r\n\r\n  Console.WriteLine(i);\r\n  i++;\r\n}\r\n</pre>\r\n\r\n<p>should be refactored into:</p>\r\n\r\n<pre>\r\nint i = 0;\r\nwhile (i != 10) // Compliant\r\n{\r\n  Console.WriteLine(i);\r\n  i++;\r\n}\r\n</pre>\r\n\r\n<p>The following code is compliant:</p>\r\n\r\n<pre>\r\nint foo = 0;\r\nswitch (foo)\r\n{\r\n  case 0:\r\n    Console.WriteLine(\"foo = 0\");\r\n    break;      // Compliant\r\n}\r\n</pre>\r\n",
    "Tags": ""
  },
  {
    "Key": "S2737",
    "Title": "\"catch\" clauses should do more than rethrow",
    "Description": "<p>\r\nA <code>catch</code> clause that only rethrows the caught exception has the same effect as omitting the <code>catch</code> altogether and letting it bubble up automatically, but with more code and the additional detrement of leaving maintainers scratching their heads.\r\nSuch clauses should either be eliminated or populated with the appropriate logic.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nstring s = \"\";\r\ntry \r\n{\r\n  s = File.ReadAllText(fileName);\r\n}\r\ncatch (Exception e) // Noncompliant\r\n{  \r\n  throw;\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nstring s = \"\";\r\ntry \r\n{\r\n  s = File.ReadAllText(fileName);\r\n}\r\ncatch (Exception e) \r\n{\r\n  logger.LogError(e);\r\n  throw;\r\n}\r\n</pre>\r\nor\r\n<pre>\r\nstring s = File.ReadAllText(fileName);\r\n</pre>",
    "Tags": "clumsy, unused"
  },
  {
    "Key": "S125",
    "Title": "Sections of code should not be \"commented out\"",
    "Description": "<p>\r\n    Programmers should not comment out code as it bloats programs and reduces readability.\r\n    Unused code should be deleted and can be retrieved from source control history if required.\r\n</p>\r\n\r\n<h2>See</h2>\r\n<ul>\r\n    <li>MISRA C:2004, 2.4 - Sections of code should not be \"commented out\".</li>\r\n    <li>MISRA C++:2008, 2-7-2 - Sections of code shall not be \"commented out\" using C-style comments.</li>\r\n    <li>MISRA C++:2008, 2-7-3 - Sections of code should not be \"commented out\" using C++ comments.</li>\r\n    <li>MISRA C:2012, Dir. 4.4 - Sections of code should not be \"commented out\"</li>\r\n</ul>\r\n",
    "Tags": "misra, unused"
  },
  {
    "Key": "S2760",
    "Title": "Sequential tests should not check the same condition",
    "Description": "<p>\r\n    When the same condition is checked twice in a row, it is either inefficient - why not combine the checks? - or an error - \r\n    some other condition should have been checked in the second test.\r\n    This rule raises an issue when sequential <code>if</code>s or <code>switch</code>es test the same condition.\r\n</p>\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif (a == b) \r\n{ \r\n  doTheThing(b);\r\n}\r\nif (a == b) // Noncompliant; is this really what was intended?\r\n{  \r\n  doTheThing(c);\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (a == b) \r\n{ \r\n  doTheThing(b);\r\n  doTheThing(c);\r\n}\r\n</pre>\r\n\r\nor\r\n\r\n<pre>\r\nif (a == b) \r\n{ \r\n  doTheThing(b);\r\n}\r\nif (b == c) \r\n{\r\n  doTheThing(c);\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    This rule ignores sequential <code>if</code> statements when any symbols checked in the condition is modified within \r\n    the first <code>if</code>.\r\n</p>",
    "Tags": "bug"
  },
  {
    "Key": "S1862",
    "Title": "Related \"if/else if\" statements should not have the same condition",
    "Description": "<p>\r\nA chain of <code>if</code>/<code>else if</code> statements is evaluated from top to bottom. At most, only one branch will be executed: the first one with a condition that evaluates to <code>true</code>.\r\nTherefore, duplicating a condition automatically leads to dead code. Usually, this is due to a copy/paste error. At best, it's simply dead code and at worst, it's a bug that is likely to induce \r\nfurther bugs as the code is maintained, and obviously it could lead to unexpected behavior.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif (param == 1)\r\n  openWindow();\r\nelse if (param == 2)\r\n  closeWindow();\r\nelse if (param == 1)  // Noncompliant\r\n  moveWindowToTheBackground();\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (param == 1)\r\n  openWindow();\r\nelse if (param == 2)\r\n  closeWindow();\r\nelse if (param == 3)\r\n  moveWindowToTheBackground();\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n<li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C</a> - Detect and remove code that has no effect</li>\r\n<li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP</a> - Detect and remove code that has no effect</li>\r\n</ul>",
    "Tags": "bug, cert, pitfall, unused"
  },
  {
    "Key": "S1871",
    "Title": "Two branches in the same conditional structure should not have exactly the same implementation",
    "Description": "<p>\r\n    Having two <code>cases</code> in the same <code>switch</code> statement or branches in the same <code>if</code> structure\r\n    with the same implementation is at best duplicate code, and at worst a coding error. If the same logic is truly needed for\r\n    both instances, then in an <code>if</code> structure they should be combined, or for a <code>switch</code>, one should fall \r\n    through to the other.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nswitch (i) \r\n{\r\n  case 1: \r\n    doSomething();\r\n    break;\r\n  case 2: \r\n    doSomethingDifferent();\r\n    break;\r\n  case 3:  // Noncompliant; duplicates case 1's implementation\r\n    doSomething(); \r\n    break;\r\n  default: \r\n    doTheRest();\r\n}\r\n\r\nif (a >= 0 && a < 10) \r\n{\r\n  doTheThing();\r\n}\r\nelse if (a >= 10 && a < 20) \r\n{\r\n  doTheOtherThing();\r\n}\r\nelse if (a >= 20 && a < 50) \r\n{\r\n  doTheThing();  // Noncompliant; duplicates first condition\r\n}\r\nelse \r\n{\r\n  doTheRest(); \r\n}\r\n\r\nif (b == 0) \r\n{\r\n  doOneMoreThing();\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nswitch (i) {\r\n  case 1: \r\n  case 3:\r\n    doSomething();\r\n    break;\r\n  case 2: \r\n    doSomethingDifferent();\r\n    break;\r\n  default: \r\n    doTheRest();\r\n}\r\n\r\nif ((a >= 0 && a < 10) || (a >= 20 && a < 50)) \r\n{\r\n  doTheThing();\r\n}\r\nelse if (a >= 10 && a < 20) \r\n{\r\n  doTheOtherThing();\r\n}\r\nelse \r\n{\r\n  doTheRest(); \r\n}\r\n\r\ndoOneMoreThing();\r\n</pre>\r\nor\r\n<pre>\r\nswitch (i) \r\n{\r\n  case 1: \r\n    doSomething();\r\n    break;\r\n  case 2: \r\n    doSomethingDifferent();\r\n    break;\r\n  case 3:\r\n    doThirdThing(); \r\n    break;\r\n  default: \r\n    doTheRest();\r\n}\r\n\r\nif (a >= 0 && a < 10) \r\n{\r\n  doTheThing();\r\n}\r\nelse if (a >= 10 && a < 20) \r\n{\r\n  doTheOtherThing();\r\n}\r\nelse if (a >= 20 && a < 50) \r\n{\r\n  doTheThirdThing();\r\n}\r\nelse \r\n{\r\n  doTheRest(); \r\n}\r\n</pre>\r\n",
    "Tags": "bug"
  },
  {
    "Key": "S126",
    "Title": "\"if ... else if\" constructs shall be terminated with an \"else\" clause",
    "Description": "<p>\r\n  This rule applies whenever an <code>if</code> statement is followed by one or\r\n  more <code>else if</code> statements, the final <code>else if</code> shall be\r\n  followed by an <code>else</code> statement.\r\n</p>\r\n\r\n<p>\r\nThe requirement for a final <code>else</code> statement is defensive programming.\r\nThe <code>else</code> statement should either take appropriate action or contain\r\na suitable comment as to why no action is taken. This is consistent with the\r\nrequirement to have a final <code>default</code> clause in a <code>switch</code>\r\nstatement.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif (x == 0)\r\n{\r\n  doSomething();\r\n} else if (x == 1)\r\n{\r\n  doSomethingElse();\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (x == 0)\r\n{\r\n  doSomething();\r\n} else if (x == 1)\r\n{\r\n  doSomethingElse();\r\n} else\r\n{\r\n  throw new IllegalStateException();\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li>MISRA C:2004, 14.10 - All if...else if constructs shall be terminated with an else clause.</li>\r\n    <li>MISRA C++:2008, 6-4-2 - All if...else if constructs shall be terminated with an else clause.</li>\r\n    <li>MISRA C:2012, 15.7 - All if...else if constructs shall be terminated with an else statement</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/YgE\">CERT, MSC01-C</a> - Strive for logical completeness</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/JoIyAQ\">CERT, MSC01-CPP</a> - Strive for logical completeness</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/PQHRAw\">CERT, MSC64-Java</a> - Strive for logical completeness</li>\r\n</ul>\r\n",
    "Tags": "cert, misra"
  },
  {
    "Key": "S2486",
    "Title": "Exceptions should not be ignored",
    "Description": "<p>\r\nWhen exceptions occur, it is usually a bad idea to simply ignore them. Instead, it is better to handle them properly, or at least to log them.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nstring text = \"\";\r\ntry \r\n{\r\n  text = File.ReadAllText(fileName);\r\n} \r\ncatch (Exception exc) // Noncompliant\r\n{  \r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nstring text = \"\";\r\ntry \r\n{\r\n  text = File.ReadAllText(fileName);\r\n} \r\ncatch (Exception exc) \r\n{\r\n  logger.Log(exc);\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li> <a href=\"http://cwe.mitre.org/data/definitions/391.html\">MITRE, CWE-391</a> - Unchecked Error Condition</li>\r\n</ul>",
    "Tags": "cwe, error-handling, security"
  },
  {
    "Key": "S1186",
    "Title": "Methods should not be empty",
    "Description": "<p>\r\nThere are several reasons for a method not to have a method body:\r\n  <ul>\r\n    <li>It is an unintentional omission, and should be fixed.</li>\r\n    <li>It is not yet, or never will be, supported. In this case an <code>NotSupportedException</code> should be thrown.</li>\r\n    <li>The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override.</li>\r\n  </ul>\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic override void DoSomething()\r\n{\r\n}\r\n\r\npublic override void doSomethingElse()\r\n{\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic override void DoSomething()\r\n{\r\n  // Do nothing because of X and Y.\r\n}\r\n\r\npublic override void doSomethingElse() \r\n{\r\n  throw new NotSupportedException();\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>An abstract class' may have empty methods, in order to provide default implementations for child classes.</p>\r\n<pre>\r\nabstract class Animal \r\n{\r\n  public void Speak() \r\n  {\r\n  }\r\n}\r\n</pre>\r\n",
    "Tags": "bug"
  },
  {
    "Key": "S108",
    "Title": "Nested blocks of code should not be left empty",
    "Description": "<p>\r\nMost of the time a block of code is empty when a piece of code is really missing. So such empty block must be either filled or removed.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nfor (int i = 0; i < 42; i++) {}  // Empty on purpose or missing piece of code ?\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    When a block contains a comment, this block is not considered to be empty.\r\n</p>\r\n",
    "Tags": "bug"
  },
  {
    "Key": "S1116",
    "Title": "Empty statements should be removed",
    "Description": "<p>\r\n  Empty statements, i.e. <code>;</code>, are usually introduced by mistake, for example because:\r\n  <ul>\r\n    <li>It was meant to be replaced by an actual statement, but this was forgotten.</li>\r\n    <li>There was a typo which lead the semicolon to be doubled, i.e. <code>;;</code>.</li>\r\n  </ul>\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvoid doSomething()\r\n{\r\n  ;                                                   // Non-Compliant - was used as a kind of TODO marker\r\n}\r\n\r\nvoid doSomethingElse()\r\n{\r\n  Console.WriteLine(\"Hello, world!\");;                // Non-Compliant - double ;\r\n  ...\r\n  for (int i = 0; i < 3; Console.WriteLine(i), i++);  // Non-Compliant - Rarely, they are used on purpose as the body of a loop. It is a bad practice to have side-effects outside of the loop body\r\n  ...\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvoid doSomething()\r\n{\r\n}\r\n\r\nvoid doSomethingElse()\r\n{\r\n  Console.WriteLine(\"Hello, world!\");\r\n  ...\r\n  for (int i = 0; i < 3; i++)\r\n  {\r\n    Console.WriteLine(i);\r\n   }\r\n  ...\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li>MISRA C:2004, 14.3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment provided that the first character following the null statement is a white-space character.</li>\r\n    <li>MISRA C++:2008, 6-2-3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided that the first character following the null statement is a white-space character.</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C</a> - Detect and remove code that has no effect</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP</a> - Detect and remove code that has no effect</li>\r\n</ul>",
    "Tags": "cert, misra, unused"
  },
  {
    "Key": "S127",
    "Title": "\"for\" loop stop conditions should be invariant",
    "Description": "<p>\r\n    <code>for</code> loop stop conditions must be invariant (i.e. true at both the beginning and ending of every loop iteration). Ideally, this means that the stop condition is set to a local variable just before the loop begins.\r\n</p>\r\n<p>\r\n    Stop conditions that are not invariant are difficult to understand and maintain, and will likely lead to the introduction of errors in the future.\r\n</p>\r\n<p>\r\n    This rule tracks three types of non-invariant stop conditions:\r\n    <ul>\r\n        <li>When the loop counters are updated in the body of the <code>for</code> loop</li>\r\n        <li>When the stop condition depend upon a method call</li>\r\n        <li>When the stop condition depends on an object property, since such properties could change during the execution of the loop.</li>\r\n    </ul>\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass Foo\r\n{\r\n    static void Main()\r\n    {\r\n        for (int i = 1; i &lt;= 5; i++)\r\n        {\r\n            Console.WriteLine(i);\r\n            if (condition)\r\n            {\r\n               i = 20;\r\n           }\r\n        }\r\n    }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nclass Foo\r\n{\r\n    static void Main()\r\n    {\r\n        for (int i = 1; i &lt;= 5; i++)\r\n        {\r\n            Console.WriteLine(i);\r\n        }\r\n    }\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li>MISRA C:2004, 13.6 - Numeric variables being used within a for loop for iteration counting shall not be modified in the body of the loop.</li>\r\n    <li>MISRA C++:2008, 6-5-3 - The loop-counter shall not be modified within condition or statement.</li>\r\n</ul>\r\n",
    "Tags": "misra, pitfall"
  },
  {
    "Key": "S1994",
    "Title": "\"for\" loop incrementers should modify the variable being tested in the loop's stop condition",
    "Description": "<p>\r\nIt is almost always an error when a <code>for</code> loop's stop condition and incrementer don't act on the same variable. Even when it is not, it could confuse future maintainers of the code, and should be avoided.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nfor (i = 0; i < 10; j++) // Noncompliant\r\n{  \r\n  // ...\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nfor (i = 0; i < 10; i++) \r\n{\r\n  // ...\r\n}\r\n</pre>",
    "Tags": "bug"
  },
  {
    "Key": "S1764",
    "Title": "Identical expressions should not be used on both sides of a binary operator",
    "Description": "<p>\r\nUsing the same value on either side of a binary operator is almost always a mistake. In the case of logical operators, it is either a copy/paste error and therefore a bug, or it is simply wasted code, and should be simplified. In the case of bitwise operators and most binary mathematical operators, having the same value on both sides of an operator yields predictable results, and should be simplified.\r\n</p>\r\n<p>\r\nThis rule ignores <code>*</code>, <code>+</code>, and <code>=</code>.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif ( a == a ) // always true\r\n{ \r\n  doZ();\r\n}\r\nif ( a != a ) // always false\r\n{ \r\n  doY();\r\n}\r\nif ( a == b && a == b ) // if the first one is true, the second one is too\r\n{ \r\n  doX();\r\n}\r\nif ( a == b || a == b ) // if the first one is true, the second one is too\r\n{ \r\n  doW();\r\n}\r\n\r\nint j = 5 / 5; //always 1\r\nint k = 5 - 5; //always 0\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\ndoZ();\r\n\r\nif ( a == b ) \r\n{\r\n  doX();\r\n}\r\nif ( a == b ) \r\n{\r\n  doW();\r\n}\r\n\r\nint j = 1;\r\nint k = 0;\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\nLeft-shifting 1 onto 1 is common in the construction of bit masks, and is ignored.\r\n<pre>\r\nint i = 1 << 1; // Compliant\r\nint j = a << a; // Noncompliant\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C</a> - Detect and remove code that has no effect</li>\r\n    <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP</a> - Detect and remove code that has no effect</li>\r\n    <li>Rule S1656 - Implements a check on <code>=</code>.</li>\r\n</ul>",
    "Tags": "bug, cert"
  },
  {
    "Key": "S1145",
    "Title": "Useless \"if(true) {...}\" and \"if(false){...}\" blocks should be removed",
    "Description": "<p>\r\n  <code>if</code> statements with conditions that are always false have the effect of making blocks of code non-functional. This can be useful during debugging, but should not be checked in. <code>if</code> statements with conditions that are always true are completely redundant, and make the code less readable.\r\n</p>\r\n<p>\r\nIn either case, unconditional <code>if</code> statements should be removed.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif (true) \r\n{\r\n  doSomething();\r\n}\r\n...\r\nif (false) \r\n{\r\n  doSomethingElse();\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\ndoSomething();\r\n...\r\n</pre>\r\n",
    "Tags": "bug, cwe, misra, security"
  },
  {
    "Key": "S2681",
    "Title": "Multiline blocks should be enclosed in curly braces",
    "Description": "<p>\r\nCurly braces can be omitted from a one-line block, such as with an <code>if</code> statement or <code>for</code> loop, but doing so can be misleading and induce bugs.\r\nThis rule raises an issue when the indention of the lines after a one-line block indicates an intent to include those lines in the block, but the omission of curly braces means the lines will be unconditionally executed once.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif (condition)\r\n  firstActionInBlock();\r\n  secondAction();  // Noncompliant; executed unconditionally\r\nthirdAction();\r\n\r\nstring str = null;\r\nfor (int i = 0; i < array.length; i++) \r\n  str = array[i];\r\n  doTheThing(str);  // Noncompliant; executed only on last array element\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (condition) \r\n{\r\n  firstActionInBlock();\r\n  secondAction();\r\n}\r\nthirdAction();\r\n\r\nstring str = null;\r\nfor (int i = 0; i < array.length; i++) \r\n{\r\n  str = array[i];\r\n  doTheThing(str);\r\n}\r\n</pre>\r\n",
    "Tags": "bug"
  },
  {
    "Key": "S1848",
    "Title": "Objects should not be created to be dropped immediately without being used",
    "Description": "<p>\r\nThere is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could lead to an unexpected behavior in production.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif (x < 0)\r\n  new ArgumentException(\"x must be nonnegative\");\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (x < 0)\r\n  throw new ArgumentException(\"x must be nonnegative\");\r\n</pre>\r\n",
    "Tags": "bug"
  },
  {
    "Key": "S1226",
    "Title": "Method parameters and caught exceptions should not be reassigned",
    "Description": "<p>\r\n    While it is technically correct to assign to parameters from within method bodies, it is better to use temporary variables to store intermediate results.\r\n    This rule will typically detect cases where a constructor parameter is assigned to itself instead of a field of the same name, i.e. when <code>this</code> was forgotten.\r\n    Allowing parameters to be assigned to also reduces the code readability as developers will not be able to know whether the original parameter or some temporary variable is being accessed without going through the whole method.\r\n    Moreover, some developers might also expect assignments of method parameters to be visible from callers, which is not the case and can confuse them.\r\n    All parameters should be treated as <code>final</code>.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass MyClass \r\n{\r\n  public String name;\r\n\r\n  public MyClass(String name) \r\n  {\r\n    name = name;                    // Noncompliant - useless identity assignment\r\n  }\r\n\r\n  public int add(int a, int b) \r\n  {\r\n    a = a + b;                      // Noncompliant\r\n\r\n    /* additional logic */\r\n\r\n    return a;                       // Seems like the parameter is returned as is, what is the point?\r\n  }\r\n\r\n  public static void main(String[] args) \r\n  {\r\n    MyClass foo = new MyClass();\r\n    int a = 40;\r\n    int b = 2;\r\n    foo.add(a, b);                  // Variable \"a\" will still hold 40 after this call\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nclass MyClass \r\n{\r\n  public String name;\r\n\r\n  public MyClass(String name) \r\n  {\r\n    this.name = name;               // Compliant\r\n  }\r\n\r\n  public int add(int a, int b) \r\n  {\r\n    return a + b;                   // Compliant\r\n  }\r\n\r\n  public static void main(String[] args) \r\n  {\r\n    MyClass foo = new MyClass();\r\n    int a = 40;\r\n    int b = 2;\r\n    foo.add(a, b);\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n<ul>\r\n    <li>MISRA C:2012, 17.8 - A function parameter should not be modified</li>\r\n</ul>\r\n",
    "Tags": "misra, pitfall"
  },
  {
    "Key": "S1109",
    "Title": "A close curly brace should be located at the beginning of a line",
    "Description": "<p>\r\nShared coding conventions make it possible for a team to efficiently collaborate. This rule makes it mandatory to place a close curly brace at the beginning of a line.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif(condition) \r\n{\r\n  doSomething();}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif(condition) \r\n{\r\n  doSomething();\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>When blocks are inlined (open and close curly braces on the same line), no issue is triggered.</p>\r\n<pre>\r\nif(condition) { doSomething(); }\r\n</pre>\r\n",
    "Tags": "convention"
  },
  {
    "Key": "S1656",
    "Title": "Variables should not be self-assigned",
    "Description": "<p>\r\nThere is no reason to re-assign a variable to itself. Either this statement is redundant and should be removed, or the re-assignment is a mistake and some other value or variable was intended for the assignment instead.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic void setName(string name) \r\n{\r\n    name = name;\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic void setName(string name) \r\n{\r\n    this.name = name;\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C</a> - Detect and remove code that has no effect</li>\r\n    <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP</a> - Detect and remove code that has no effect</li>\r\n</ul>",
    "Tags": "bug, cert"
  },
  {
    "Key": "S1697",
    "Title": "Short-circuit logic should be used to prevent null pointer dereferences in conditionals",
    "Description": "<p>\r\nWhen either the equality operator in a null test or the logical operator that follows it is reversed, the code has the appearance of safely null-testing the object before dereferencing it. \r\nUnfortunately the effect is just the opposite - the object is null-tested and then dereferenced only if it is null, leading to a guaranteed null pointer dereference.\r\n</p>\r\n\r\n<h2>Noncompliant Code Sample</h2>\r\n<pre>\r\nif (str == null && str.Length == 0) \r\n{\r\n  Console.WriteLine(\"String is empty\");\r\n}\r\n\r\nif (str != null || str.Length > 0) \r\n{\r\n  Console.WriteLine(\"String is not empty\");\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (str == null || str.Length == 0) \r\n{\r\n  Console.WriteLine(\"String is empty\");\r\n}\r\n\r\nif (str != null && str.Length > 0) \r\n{\r\n  Console.WriteLine(\"String is not empty\");\r\n}\r\n</pre>",
    "Tags": "bug"
  },
  {
    "Key": "S2743",
    "Title": "Static fields should not be used in generic types",
    "Description": "<p>\r\n    A static field in a generic type is not shared among instances of different closed constructed types, thus <code>LengthLimitedSingletonCollection&lt;int&gt;.instances</code>\r\n    and <code>LengthLimitedSingletonCollection&lt;string&gt;.instances</code> will point to different objects, even though <code>instances</code> is seemingly shared among all\r\n    <code>LengthLimitedSingletonCollection&lt;&gt;</code> generic classes.\r\n</p>\r\n<p>\r\n    If you need to have a static field shared among instances with different generic arguments, define a non-generic base class to store your static members, then set your generic type to inherit from the base class.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class LengthLimitedSingletonCollection&lt;T&gt; where T : new() \r\n{\r\n  protected const int MaxAllowedLength = 5;\r\n  protected static Dictionary&lt;Type, object&gt; instances = new Dictionary&lt;Type, object&gt;(); // Noncompliant\r\n  public static T GetInstance() \r\n  {\r\n    object instance;\r\n    if (!instances.TryGetValue(typeof(T), out instance)) \r\n    {\r\n      if (instances.Count >= MaxAllowedLength) \r\n      {\r\n        throw new Exception();\r\n      }\r\n      instance = new T();\r\n      instances.Add(typeof(T), instance);\r\n    }\r\n    return (T)instance;\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class SingletonCollectionBase \r\n{\r\n  protected static Dictionary&lt;Type, object&gt; instances = new Dictionary&lt;Type, object&gt;(); \r\n}\r\npublic class LengthLimitedSingletonCollection&lt;T&gt; : SingletonCollectionBase where T : new()\r\n{\r\n  protected const int MaxAllowedLength = 5;\r\n  public static T GetInstance() \r\n  {\r\n    object instance;\r\n    if (!instances.TryGetValue(typeof(T), out instance)) \r\n    {\r\n      if (instances.Count >= MaxAllowedLength) \r\n      {\r\n        throw new Exception();\r\n      }\r\n      instance = new T();\r\n      instances.Add(typeof(T), instance);\r\n    }\r\n    return (T)instance;\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Exception</h2>\r\n<p>\r\n    If the static field or property uses a type parameter, then the developer is assumed to understand that the static member is not shared among the closed constructed types.\r\n</p>\r\n<pre>\r\npublic class Cache&lt;T&gt; \r\n{\r\n  private static Dictionary&lt;string, T&gt; CacheDictionary { get; set; } // Compliant\r\n}\r\n</pre>\r\n",
    "Tags": ""
  },
  {
    "Key": "S131",
    "Title": "\"switch\" statements should end with a \"default\" clause",
    "Description": "<p>\r\n    The requirement for a final <code>default</code> clause is defensive programming. The clause should either take\r\n    appropriate action, or contain a suitable comment as to why no action is taken. Even when the <code>switch</code>\r\n    covers all current values of an <code>enum</code>, a <code>default</code> case should still be used because there is \r\n    no guarantee that the <code>enum</code> won't be extended.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nint foo = 42;\r\nswitch (foo) // Non-Compliant\r\n{\r\n  case 0:\r\n    Console.WriteLine(\"foo = 0\");\r\n    break;\r\n  case 42:\r\n    Console.WriteLine(\"foo = 42\");\r\n    break;\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nint foo = 42;\r\nswitch (foo) // Compliant\r\n{\r\n  case 0:\r\n    Console.WriteLine(\"foo = 0\");\r\n    break;\r\n  case 42:\r\n    Console.WriteLine(\"foo = 42\");\r\n    break;\r\n  default:\r\n    throw new InvalidOperationException(\"Unexpected value foo = \" + foo);\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li>MISRA C:2004, 15.0 - The MISRA C switch syntax shall be used.</li>\r\n    <li>MISRA C:2004, 15.3 - The final clause of a switch statement shall be the default clause</li>\r\n    <li>MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement.</li>\r\n    <li>MISRA C++:2008, 6-4-6 - The final clause of a switch statement shall be the default-clause</li>\r\n    <li>MISRA C:2012, 16.1 - All switch statements shall be well-formed</li>\r\n    <li>MISRA C:2012, 16.4 - Every switch statement shall have a default label</li>\r\n    <li>MISRA C:2012, 16.5 - A default label shall appear as either the first or the last switch label of a switch statement</li>\r\n    <li><a href=\"http://cwe.mitre.org/data/definitions/478.html\">MITRE, CWE-478</a> - Missing Default Case in Switch Statement</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/YgE\">CERT, MSC01-C</a> - Strive for logical completeness</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/JoIyAQ\">CERT, MSC01-CPP</a> - Strive for logical completeness</li>\r\n</ul>",
    "Tags": "cert, cwe, misra"
  },
  {
    "Key": "S105",
    "Title": "Tabulation characters should not be used",
    "Description": "<p>\r\nDevelopers should not need to configure the tab width of their text editors in order to be able to read source code.\r\nSo the use of tabulation character must be banned.\r\n</p>\r\n",
    "Tags": "convention"
  },
  {
    "Key": "S1125",
    "Title": "Literal boolean values should not be used in condition expressions",
    "Description": "<p>\r\nRemove literal boolean values from conditional expressions to improve readability. Anything that can be tested for equality with a boolean value must itself be a boolean value, and boolean values can be tested atomically.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif (booleanVariable == true) { /* ... */ }\r\nif (booleanVariable != true) { /* ... */ }\r\nif (booleanVariable || false) { /* ... */ }\r\ndoSomething(!false);\r\n\r\nbooleanVariable = condition ? true : exp;\r\nbooleanVariable = condition ? false : exp;\r\nbooleanVariable = condition ?  exp : true;\r\nbooleanVariable = condition ?  exp : false;\r\nbooleanVariable = condition ?  true : false;\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (booleanVariable) { /* ... */ }\r\nif (!booleanVariable) { /* ... */ }\r\nif (booleanVariable) { /* ... */ }\r\ndoSomething(true);\r\n\r\nbooleanVariable = condition || exp;\r\nbooleanVariable = !condition && exp;\r\nbooleanVariable = !condition ||  exp;\r\nbooleanVariable = condition && exp;\r\nbooleanVariable = condition;\r\n</pre>\r\n",
    "Tags": "clumsy"
  },
  {
    "Key": "S1481",
    "Title": "Unused local variables should be removed",
    "Description": "<p>\r\nIf a local variable is declared but not used, it is dead code and should be removed. Doing so will improve maintainability because developers will not wonder what the variable is used for.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic int numberOfMinutes(int hours) \r\n{\r\n  int seconds = 0;   // seconds is never used\r\n  return hours * 60;\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic int numberOfMinutes(int hours) \r\n{\r\n  return hours * 60;\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    Unused locally created resources in a <code>using</code> statement are not reported.\r\n</p>\r\n<pre>\r\nusing(var t = new Timer()) // t never used, but compliant.\r\n{\r\n  //...\r\n}\r\n</pre>\r\n",
    "Tags": "unused"
  },
  {
    "Key": "S121",
    "Title": "Control structures should always use curly braces",
    "Description": "<p>\r\n  While not technically incorrect, the omission of curly braces can be misleading, and may lead to the introduction of errors during maintenance.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\n// the two statements seems to be attached to the if statement, but that is only true for the first one:\r\nif (condition)\r\n  executeSomething();\r\n  checkSomething();\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (condition) \r\n{\r\n  executeSomething();\r\n  checkSomething();\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li>MISRA C:2004, 14.8 - The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement</li>\r\n    <li>MISRA C:2004, 14.9 - An if (expression) construct shall be followed by a compound statement. The else keyword shall be followed by either a compound statement, or another if statement</li>\r\n    <li>MISRA C++:2008, 6-3-1 - The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement</li>\r\n    <li>MISRA C++:2008, 6-4-1 - An if (condition) construct shall be followed by a compound statement. The else keyword shall be followed by either a compound statement, or another if statement</li>\r\n    <li>MISRA C:2012, 15.6 - The body of an iteration-statement or a selection-statement shall be a compound-statement</li>\r\n    <li> <a href=\"https://www.securecoding.cert.org/confluence/x/1QGMAg\">CERT, EXP19-C</a> - Use braces for the body of an if, for, or while statement</li>\r\n    <li> <a href=\"http://cwe.mitre.org/data/definitions/483.html\">MITRE, CWE-483</a> - Incorrect Block Delimitation</li>\r\n</ul>\r\n",
    "Tags": "cert, cwe, misra, pitfall"
  }
]
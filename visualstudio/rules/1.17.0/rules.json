{
  "version": "1.17.0",
  "rules": [
    {
      "key": "S3244",
      "title": "Anonymous delegates should not be used to unsubscribe from Events",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S3244",
          "language": "C#",
          "title": "Anonymous delegates should not be used to unsubscribe from Events",
          "description": "<p>\r\n    It is possible to subscribe to events with anonymous delegates, but having done so, it is impossible to unsubscribe from them.\r\n    That's because the process of subscribing adds the delegate to a list. The process of unsubscribing essentially says: remove\r\n    this item from the subscription list. But because an anonymous delegate was used in both cases, the unsubscribe attempt tries\r\n    to remove a different item from the list than was added. The result: <code>NOOP</code>.\r\n</p>\r\n<p>\r\n    Instead, save the delegate to a variable and use the variable to subscribe and unsubscribe.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nlistView.PreviewTextInput += (obj,args) =>\r\n        listView_PreviewTextInput(obj,args,listView);\r\n\r\n// ...\r\n\r\nlistView.PreviewTextInput -= (obj, args) =>\r\n        listView_PreviewTextInput(obj, args, listView); // Noncompliant; this delegate was never subscribed\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nEventHandler func = (obj,args) => listView_PreviewTextInput(obj,args,listView);\r\n\r\nlistView.PreviewTextInput += func;\r\n\r\n// ...\r\n\r\nlistView.PreviewTextInput -= func;\r\n</pre>\r\n",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S3236",
      "title": "Methods with caller info attributes should not be invoked with explicit arguments",
      "tags": [
        "suspicious"
      ],
      "implementations": [
        {
          "key": "S3236",
          "language": "C#",
          "title": "Methods with caller info attributes should not be invoked with explicit arguments",
          "description": "<p>\r\n    Caller information attributes (<code>CallerFilePathAttribute</code>, <code>CallerLineNumberAttribute</code>, and\r\n    <code>CallerMemberNameAttribute</code>) provide a way to get information about the caller of a method through optional parameters.\r\n    But the arguments for these optional parameters are only generated if they are not explicitly defined in the call. Thus, specifying\r\n    the argument values defeats the purpose of the attributes.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvoid TraceMessage(string message,\r\n  [CallerMemberName] string memberName = \"\",\r\n  [CallerFilePath] string filePath = \"\",\r\n  [CallerLineNumber] int lineNumber = 0)\r\n{\r\n  /* ... */\r\n}\r\n\r\nvoid MyMethod()\r\n{\r\n  TraceMessage(\"my message\", \"MyMethod\"); // Noncompliant\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvoid TraceMessage(string message,\r\n  [CallerMemberName] string memberName = \"\",\r\n  [CallerFilePath] string filePath = \"\",\r\n  [CallerLineNumber] int lineNumber = 0)\r\n{\r\n  /* ... */\r\n}\r\n\r\nvoid MyMethod()\r\n{\r\n  TraceMessage(\"my message\");\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "suspicious"
          ]
        }
      ]
    },
    {
      "key": "S2330",
      "title": "Array covariance should not be used",
      "tags": [
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S2330",
          "language": "C#",
          "title": "Array covariance should not be used",
          "description": "<p>\r\n    Array covariance is the principle that if an implicit or explicit reference conversion exits from type <code>A</code> to\r\n    <code>B</code>, then the same conversion exists from the array type <code>A[]</code> to <code>B[]</code>.\r\n</p>\r\n<p>\r\n    While this array conversion can be useful in readonly situations to pass instances of <code>A[]</code> wherever\r\n    <code>B[]</code> is expected, it must be used with care, since assigning an instance of <code>B</code> into an array of\r\n    <code>A</code> will cause an <code>ArrayTypeMismatchException</code> to be thrown at runtime.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nabstract class Fruit { }\r\nclass Apple : Fruit { }\r\nclass Orange : Fruit { }\r\n\r\nclass Program\r\n{\r\n  static void Main(string[] args)\r\n  {\r\n    Fruit[] fruits = new Apple[1]; // Noncompliant - array covariance is used\r\n    FillWithOranges(fruits);\r\n  }\r\n\r\n  // Just looking at the code doesn't reveal anything suspicious\r\n  static void FillWithOranges(Fruit[] fruits)\r\n  {\r\n    for (int i = 0; i < fruits.Length; i++)\r\n    {\r\n      fruits[i] = new Orange(); // Will throw an ArrayTypeMismatchException\r\n    }\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nabstract class Fruit { }\r\nclass Apple : Fruit { }\r\nclass Orange : Fruit { }\r\n\r\nclass Program\r\n{\r\n  static void Main(string[] args)\r\n  {\r\n    Orange[] fruits = new Orange[1]; // Compliant\r\n    FillWithOranges(fruits);\r\n  }\r\n\r\n  static void FillWithOranges(Orange[] fruits)\r\n  {\r\n    for (int i = 0; i < fruits.Length; i++)\r\n    {\r\n      fruits[i] = new Orange();\r\n    }\r\n  }\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S1121",
      "title": "Assignments should not be made from within sub-expressions",
      "tags": [
        "suspicious",
        "cwe",
        "misra"
      ],
      "implementations": [
        {
          "key": "S1121",
          "language": "C#",
          "title": "Assignments should not be made from within sub-expressions",
          "description": "<p>\r\n    Assignments within sub-expressions are hard to spot and therefore make the code less readable.\r\n    It is also a common mistake to write <code>=</code> when <code>==</code> was meant.\r\n    Ideally, expressions should should not have side-effects.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\ndoSomething(i = 42);\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\ni = 42;\r\ndoSomething(i);\r\n// or\r\ndoSomething(i == 42);  // Perhaps in fact the comparison operator was expected\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\nAssignments inside lambda and delegate expressions are allowed. Furthermore, the following two patterns are also accepted.\r\n<pre>\r\nwhile ((val = GetNewValue()) > 0)\r\n{\r\n...\r\n}\r\n</pre>\r\n<pre>\r\nprivate object myField;\r\npublic object MyProperty\r\n{\r\n  get { return myField ?? (myField = new object()); }\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n<ul>\r\n    <li>MISRA C:2004, 13.1 - Assignment operators shall not be used in expressions that yield a Boolean value</li>\r\n    <li>MISRA C++:2008, 6-2-1 - Assignment operators shall not be used in sub-expressions</li>\r\n    <li>MISRA C:2012, 13.4 - The result of an assignment operator should not be used</li>\r\n    <li><a href=\"http://cwe.mitre.org/data/definitions/481.html\">MITRE, CWE-481</a> - Assigning instead of Comparing</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/nYFtAg\">CERT, EXP45-C</a> - Do not perform assignments in selection statements</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/1gCTAw\">CERT, EXP51-J.</a> - Do not perform assignments in conditional expressions</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/KQvhAg\">CERT, EXP19-CPP.</a> - Do not perform assignments in conditional expressions</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/KYIyAQ\">CERT, MSC02-CPP.</a> - Avoid errors of omission</li>\r\n</ul>",
          "severity": "Major",
          "tags": [
            "suspicious",
            "cwe",
            "misra"
          ]
        }
      ]
    },
    {
      "key": "S2306",
      "title": "\"async\" and \"await\" should not be used as identifiers",
      "tags": [
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S2306",
          "language": "C#",
          "title": "\"async\" and \"await\" should not be used as identifiers",
          "description": "<p>\r\nSince C# 5.0, <code>async</code> and <code>await</code> are contextual keywords.\r\nContextual keywords do have a particular meaning in some contexts, but can still be used as variable names for example.\r\nKeywords, on the other hand, are always reserved, and therefore are not valid variable names.\r\nTo avoid any confusion though, it is best to not use <code>async</code> and <code>await</code> as identifiers.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nint await = 42; // Noncompliant\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nint someOtherName = 42;\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S3168",
      "title": "\"async\" methods should not return \"void\"",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S3168",
          "language": "C#",
          "title": "\"async\" methods should not return \"void\"",
          "description": "<p>\r\n    An async method with a void return type is a \"fire and forget\" method best reserved for event handlers because there's no way to wait for the method's execution to complete and respond accordingly. There's also no way to catch exceptions thrown from the method.\r\n</p>\r\n<p>\r\n    Having an async void method that is not an event handler could mean your program works some times and not others because of timing issues. Instead, async methods should return Task.\r\n</p>\r\n<p>\r\n    This rule raises an issue when non-event handler methods are both async and void.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass HttpPrinter\r\n{\r\n  private string content;\r\n\r\n  public async void CallNetwork(string url) //Noncompliant\r\n  {\r\n    var client = new HttpClient();\r\n    var response = await client.GetAsync(url);\r\n    content = await response.Content.ReadAsStringAsync();\r\n  }\r\n\r\n  public async Task PrintContent(string url)  // works correctly if web request finishes in under 1 second, otherwise content will be null\r\n  {\r\n    CallNetwork(url);\r\n    await Task.Delay(1000);\r\n    Console.Write(content);\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nclass HttpPrinter\r\n{\r\n  private string content;\r\n\r\n  public async Task CallNetwork(string url)\r\n  {\r\n    var client = new HttpClient();\r\n    var response = await client.GetAsync(url);\r\n    content = await response.Content.ReadAsStringAsync();\r\n  }\r\n\r\n  public async Task PrintContent(string url)\r\n  {\r\n    await CallNetwork(url); // &lt;----- call changed here. If await is not added warning CS4014 will be triggered\r\n    await Task.Delay(1000);\r\n    Console.Write(content);\r\n  }\r\n}\r\n</pre>\r\n",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S1764",
      "title": "Identical expressions should not be used on both sides of a binary operator",
      "tags": [
        "bug",
        "cert"
      ],
      "implementations": [
        {
          "key": "S1764",
          "language": "C#",
          "title": "Identical expressions should not be used on both sides of a binary operator",
          "description": "<p>\r\nUsing the same value on either side of a binary operator is almost always a mistake. In the case of logical operators, it is either a copy/paste error\r\n    and therefore a bug, or it is simply wasted code, and should be simplified. In the case of bitwise operators and most binary mathematical operators,\r\n    having the same value on both sides of an operator yields predictable results, and should be simplified.\r\n</p>\r\n<p>\r\nThis rule ignores <code>*</code>, <code>+</code>, <code>=</code>, <code>&lt;&lt;</code>, and <code>&gt;&gt;</code>.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif ( a == a ) // always true\r\n{\r\n  doZ();\r\n}\r\nif ( a != a ) // always false\r\n{\r\n  doY();\r\n}\r\nif ( a == b &amp;&amp; a == b ) // if the first one is true, the second one is too\r\n{\r\n  doX();\r\n}\r\nif ( a == b || a == b ) // if the first one is true, the second one is too\r\n{\r\n  doW();\r\n}\r\n\r\nint j = 5 / 5; //always 1\r\nint k = 5 - 5; //always 0\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\ndoZ();\r\n\r\nif ( a == b )\r\n{\r\n  doX();\r\n}\r\nif ( a == b )\r\n{\r\n  doW();\r\n}\r\n\r\nint j = 1;\r\nint k = 0;\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C</a> - Detect and remove code that has no effect</li>\r\n    <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP</a> - Detect and remove code that has no effect</li>\r\n    <li><a class=\"rule-link\" href=\"#version=1.17.0&ruleId=S1656\">Rule S1656</a> - Implements a check on <code>=</code>.</li>\r\n</ul>",
          "severity": "Critical",
          "tags": [
            "bug",
            "cert"
          ]
        }
      ]
    },
    {
      "key": "S1940",
      "title": "Boolean checks should not be inverted",
      "tags": [
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S1940",
          "language": "C#",
          "title": "Boolean checks should not be inverted",
          "description": "<p>\r\n    It is needlessly complex to invert the result of a boolean comparison. The opposite comparison should be made instead.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif ( !(a == 2)) { ... }  // Noncompliant\r\nbool b = !(i < 10);  // Noncompliant\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (a != 2) { ... }\r\nbool b = (i >= 10);\r\n</pre>\r\n\r\n<h2>Code Fixes</h2><ul><li>Invert \"Boolean\" check</li></ul>",
          "severity": "Minor",
          "tags": [
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S1125",
      "title": "Boolean literals should not be redundant",
      "tags": [
        "clumsy"
      ],
      "implementations": [
        {
          "key": "S1125",
          "language": "C#",
          "title": "Boolean literals should not be redundant",
          "description": "<p>\r\n    Redundant Boolean literals should be removed from expressions to improve readability.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif (booleanVariable == true) { /* ... */ }\r\nif (booleanVariable != true) { /* ... */ }\r\nif (booleanVariable || false) { /* ... */ }\r\ndoSomething(!false);\r\n\r\nbooleanVariable = condition ? true : exp;\r\nbooleanVariable = condition ? false : exp;\r\nbooleanVariable = condition ?  exp : true;\r\nbooleanVariable = condition ?  exp : false;\r\nbooleanVariable = condition ?  true : false;\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (booleanVariable) { /* ... */ }\r\nif (!booleanVariable) { /* ... */ }\r\nif (booleanVariable) { /* ... */ }\r\ndoSomething(true);\r\n\r\nbooleanVariable = condition || exp;\r\nbooleanVariable = !condition && exp;\r\nbooleanVariable = !condition ||  exp;\r\nbooleanVariable = condition && exp;\r\nbooleanVariable = condition;\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Remove the unnecessary Boolean literal(s)</li></ul>",
          "severity": "Minor",
          "tags": [
            "clumsy"
          ]
        }
      ]
    },
    {
      "key": "S1227",
      "title": "break statements should not be used except for switch cases",
      "tags": [],
      "implementations": [
        {
          "key": "S1227",
          "language": "C#",
          "title": "break statements should not be used except for switch cases",
          "description": "<p>\r\n<code>break;</code> is an unstructured control flow statement which makes code harder to read.\r\nIdeally, every loop should have a single termination condition.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n\r\n<pre>\r\nint i = 0;\r\nwhile (true)\r\n{\r\n  if (i == 10)\r\n  {\r\n    break;      // Non-Compliant\r\n  }\r\n\r\n  Console.WriteLine(i);\r\n  i++;\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nint i = 0;\r\nwhile (i != 10) // Compliant\r\n{\r\n  Console.WriteLine(i);\r\n  i++;\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": []
        }
      ]
    },
    {
      "key": "S3215",
      "title": "\"interface\" instances should not be cast to concrete types",
      "tags": [
        "design"
      ],
      "implementations": [
        {
          "key": "S3215",
          "language": "C#",
          "title": "\"interface\" instances should not be cast to concrete types",
          "description": "<p>\r\n    Needing to cast from an <code>interface</code> to a concrete type indicates that something is wrong with the abstractions in\r\n    use, likely that something is missing from the <code>interface</code>. Instead of casting to a discrete type, the missing\r\n    functionality should be added to the <code>interface</code>. Otherwise there is the risk of runtime exceptions.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic interface IMyInterface\r\n{\r\n  void DoStuff();\r\n}\r\n\r\npublic class MyClass1 : IMyInterface\r\n{\r\n  public int Data { get { return new Random().Next(); } }\r\n\r\n  public void DoStuff()\r\n  {\r\n    // TODO...\r\n  }\r\n}\r\n\r\npublic static class DowncastExampleProgram\r\n{\r\n  static void EntryPoint(IMyInterface interfaceRef)\r\n  {\r\n    MyClass1 class1 = (MyClass1)interfaceRef;  // Noncompliant\r\n    int privateData = class1.Data;\r\n\r\n    class1 = interfaceRef as MyClass1;  // Noncompliant\r\n    if (class1 != null)\r\n    {\r\n      // ...\r\n    }\r\n  }\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "design"
          ]
        }
      ]
    },
    {
      "key": "S2486",
      "title": "Generic exceptions should not be ignored",
      "tags": [
        "cwe",
        "error-handling"
      ],
      "implementations": [
        {
          "key": "S2486",
          "language": "C#",
          "title": "Generic exceptions should not be ignored",
          "description": "<p>\r\n    When exceptions occur, it is usually a bad idea to simply ignore them. Instead, it is better to handle them properly,\r\n    or at least to log them.\r\n</p>\r\n<p>\r\n    This rule only reports on empty catch clauses that catch generic <code>Exception</code>s.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nstring text = \"\";\r\ntry\r\n{\r\n  text = File.ReadAllText(fileName);\r\n}\r\ncatch (Exception exc) // Noncompliant\r\n{\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nstring text = \"\";\r\ntry\r\n{\r\n  text = File.ReadAllText(fileName);\r\n}\r\ncatch (Exception exc)\r\n{\r\n  logger.Log(exc);\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li> <a href=\"http://cwe.mitre.org/data/definitions/391.html\">MITRE, CWE-391</a> - Unchecked Error Condition</li>\r\n</ul>",
          "severity": "Major",
          "tags": [
            "cwe",
            "error-handling"
          ]
        }
      ]
    },
    {
      "key": "S2737",
      "title": "\"catch\" clauses should do more than rethrow",
      "tags": [
        "clumsy",
        "unused",
        "finding"
      ],
      "implementations": [
        {
          "key": "S2737",
          "language": "C#",
          "title": "\"catch\" clauses should do more than rethrow",
          "description": "<p>\r\nA <code>catch</code> clause that only rethrows the caught exception has the same effect as omitting the <code>catch</code> altogether and letting it bubble up automatically, but with more code and the additional detrement of leaving maintainers scratching their heads.\r\nSuch clauses should either be eliminated or populated with the appropriate logic.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nstring s = \"\";\r\ntry\r\n{\r\n  s = File.ReadAllText(fileName);\r\n}\r\ncatch (Exception e) // Noncompliant\r\n{\r\n  throw;\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nstring s = \"\";\r\ntry\r\n{\r\n  s = File.ReadAllText(fileName);\r\n}\r\ncatch (Exception e)\r\n{\r\n  logger.LogError(e);\r\n  throw;\r\n}\r\n</pre>\r\nor\r\n<pre>\r\nstring s = File.ReadAllText(fileName);\r\n</pre><h2>Code Fixes</h2><ul><li>Remove redundant catch</li></ul>",
          "severity": "Minor",
          "tags": [
            "clumsy",
            "unused",
            "finding"
          ]
        }
      ]
    },
    {
      "key": "S101",
      "title": "Types should be named in camel case",
      "tags": [
        "convention"
      ],
      "implementations": [
        {
          "key": "S101",
          "language": "C#",
          "title": "Types should be named in camel case",
          "description": "<p>\r\n    Shared naming conventions allow teams to collaborate efficiently. This rule checks whether or not type names are camel cased. To reduce noise, two consecutive\r\n    upper case characters are allowed unless they form the whole type name. So, <code>MyXClass</code> is compliant, but <code>XC</code> on its own is not.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass my_class {...}\r\nclass SOMEName42 {...}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nclass MyClass {...}\r\nclass SomeName42 {...}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    The rule ignores types that are marked with <code>ComImportAttribute</code> or <code>InterfaceTypeAttribute</code>. Furthermore, the rule\r\n    allows to have <code>'_'</code> characters in class names inside test projects.\r\n</p>\r\n\r\n<pre>\r\nclass Some_Name___42 {...} // valid in test\r\nclass Some_name___42 {...} // still not valid\r\nclass Some_Name_XC {...} // invalid because of XC, should be Some_Name_Xc\r\n</pre>",
          "severity": "Minor",
          "tags": [
            "convention"
          ]
        }
      ]
    },
    {
      "key": "S3453",
      "title": "Classes should not have only \"private\" constructors",
      "tags": [
        "design"
      ],
      "implementations": [
        {
          "key": "S3453",
          "language": "C#",
          "title": "Classes should not have only \"private\" constructors",
          "description": "<p>\r\n    A class with only <code>private</code> constructors can't be instantiated, thus, it seems to be pointless code.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class MyClass // Noncompliant\r\n{\r\n  private MyClass() { ... }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class MyClass\r\n{\r\n  public MyClass() { ... }\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    Classes that themselves access their private constructors (singletons or smart enums) are ignored. Classes with only\r\n    <code>static</code> members are also ignored because they are covered by <a class=\"rule-link\" href=\"#version=1.17.0&ruleId=S1118\">Rule S1118</a>.\r\n</p>",
          "severity": "Major",
          "tags": [
            "design"
          ]
        }
      ]
    },
    {
      "key": "S1694",
      "title": "An abstract class should have both abstract and concrete methods",
      "tags": [
        "convention"
      ],
      "implementations": [
        {
          "key": "S1694",
          "language": "C#",
          "title": "An abstract class should have both abstract and concrete methods",
          "description": "<p>\r\n    The purpose of an abstract class is to provide some heritable behaviors while also defining methods which must be\r\n    implemented by sub-classes.\r\n</p>\r\n<p>\r\n    A class with no abstract methods that was made abstract purely to prevent instantiation should be converted to a\r\n    concrete class (i.e. remove the <code>abstract</code> keyword) with a private constructor.\r\n</p>\r\n<p>\r\n    A class with only abstract methods and no inheritable behavior should be converted to an interface.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic abstract class Animal //Noncompliant; should be an interface\r\n{\r\n  abstract void Move();\r\n  abstract void Feed();\r\n}\r\n\r\npublic abstract class Color //Noncompliant; should be concrete with a private constructor\r\n{\r\n  private int red = 0;\r\n  private int green = 0;\r\n  private int blue = 0;\r\n\r\n  public int GetRed()\r\n  {\r\n    return red;\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic interface Animal\r\n{\r\n  void Move();\r\n  void Feed();\r\n}\r\n\r\npublic class Color\r\n{\r\n  private int red = 0;\r\n  private int green = 0;\r\n  private int blue = 0;\r\n\r\n  private Color()\r\n  {}\r\n\r\n  public int GetRed()\r\n  {\r\n    return red;\r\n  }\r\n}\r\n\r\npublic abstract class Lamp\r\n{\r\n  private bool switchLamp = false;\r\n\r\n  public abstract void Glow();\r\n\r\n  public void FlipSwitch()\r\n  {\r\n    switchLamp = !switchLamp;\r\n    if (switchLamp)\r\n    {\r\n      Glow();\r\n    }\r\n  }\r\n}\r\n</pre>\r\n",
          "severity": "Minor",
          "tags": [
            "convention"
          ]
        }
      ]
    },
    {
      "key": "S1118",
      "title": "Utility classes should not have public constructors",
      "tags": [
        "design"
      ],
      "implementations": [
        {
          "key": "S1118",
          "language": "C#",
          "title": "Utility classes should not have public constructors",
          "description": "<p>\r\n    Utility classes, which are collections of <code>static</code> members, are not meant to be instantiated. Even\r\n    <code>abstract</code> utility classes, which can be extended, should not have <code>public</code> constructors.\r\n</p>\r\n<p>\r\n    C# adds an implicit public constructor to every class which does not explicitly define at least one constructor. Hence, at\r\n    least one <code>protected</code> constructor should be defined if you wish to subclass this utility class. Or the\r\n    <code>static</code> keyword should be added to the class declaration to prevent subclassing.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class StringUtils // Noncompliant\r\n{\r\n  public static string Concatenate(string s1, string s2)\r\n  {\r\n    return s1 + s2;\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic static class StringUtils\r\n{\r\n  public static string Concatenate(string s1, string s2)\r\n  {\r\n    return s1 + s2;\r\n  }\r\n}\r\n</pre>\r\nor\r\n<pre>\r\npublic class StringUtils\r\n{\r\n  protected StringUtils()\r\n  {\r\n  }\r\n  public static string Concatenate(string s1, string s2)\r\n  {\r\n    return s1 + s2;\r\n  }\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "design"
          ]
        }
      ]
    },
    {
      "key": "S1155",
      "title": "\"Any()\" should be used to test for emptiness",
      "tags": [
        "clumsy"
      ],
      "implementations": [
        {
          "key": "S1155",
          "language": "C#",
          "title": "\"Any()\" should be used to test for emptiness",
          "description": "<p>\r\n    Using <code>.Count()</code> to test for emptiness works, but using <code>.Any()</code> makes the intent clearer,\r\n    and the code more readable.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nprivate static bool HasContent(IEnumerable&lt;string&gt; strings)\r\n{\r\n  return strings.Count() > 0; // Noncompliant\r\n}\r\nprivate static bool HasContent2(IEnumerable&lt;string&gt; strings)\r\n{\r\n  return strings.Count() >= 1; // Noncompliant\r\n}\r\nprivate static bool IsEmpty(IEnumerable&lt;string&gt; strings)\r\n{\r\n  return strings.Count() == 0; // Noncompliant\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nprivate static bool HasContent(IEnumerable&lt;string&gt; strings)\r\n{\r\n  return strings.Any();\r\n}\r\n\r\nprivate static bool IsEmpty(IEnumerable&lt;string&gt; strings)\r\n{\r\n  return !strings.Any();\r\n}\r\n</pre>",
          "severity": "Major",
          "tags": [
            "clumsy"
          ]
        }
      ]
    },
    {
      "key": "S2971",
      "title": "\"IEnumerable\" LINQs should be simplified",
      "tags": [
        "clumsy"
      ],
      "implementations": [
        {
          "key": "S2971",
          "language": "C#",
          "title": "\"IEnumerable\" LINQs should be simplified",
          "description": "<p>\r\n    In the interests of readability, code that can be simplified should be simplified. To that end, there are several\r\n    ways <code>IEnumerable LINQ</code>s can be simplified\r\n</p>\r\n<ul>\r\n    <li>Use <code>OfType</code> instead of using <code>Select</code> with <code>as</code> to type cast elements and then\r\n    null-checking in a query expression to choose elements based on type.</li>\r\n    <li>Use <code>OfType</code> instead of using <code>Where</code> and the <code>is</code> operator, followed by a cast\r\n    in a <code>Select</code></li>\r\n    <li>Use an expression in <code>Any</code> instead of <code>Where(element => [expression]).Any()</code>.</li>\r\n    <li>Use <code>Count</code> instead of <code>Count()</code> when it's available.</li>\r\n    <li>Don't call <code>ToArray()</code> or <code>ToList()</code> in the middle of a query chain.</li>\r\n</ul>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nseq1.Select(element => element as T).Any(element => element != null);  // Noncompliant; use OfType\r\nseq2.Select(element => element as T).Any(element => element != null &amp;&amp; CheckCondition(element));  // Noncompliant; use OfType\r\nseq3.Where(element => element is T).Select(element => element as T); // Noncompliant; use OfType\r\nseq4.Where(element => element is T).Select(element => (T)element); // Noncompliant; use OfType\r\nseq.Where(element => [expression]).Any();  // Noncompliant; use Any([expression])\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nseq1.OfType&lt;T&gt;().Any();\r\nseq2.OfType&lt;T&gt;().Any(element => CheckCondition(element));\r\nseq3.OfType&lt;T&gt;();\r\nseq4.OfType&lt;T&gt;();\r\nseq.Any(element => [expression])\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "clumsy"
          ]
        }
      ]
    },
    {
      "key": "S125",
      "title": "Sections of code should not be \"commented out\"",
      "tags": [
        "misra",
        "unused"
      ],
      "implementations": [
        {
          "key": "S125",
          "language": "C#",
          "title": "Sections of code should not be \"commented out\"",
          "description": "<p>\r\n    Programmers should not comment out code as it bloats programs and reduces readability.\r\n    Unused code should be deleted and can be retrieved from source control history if required.\r\n</p>\r\n\r\n<h2>See</h2>\r\n<ul>\r\n    <li>MISRA C:2004, 2.4 - Sections of code should not be \"commented out\".</li>\r\n    <li>MISRA C++:2008, 2-7-2 - Sections of code shall not be \"commented out\" using C-style comments.</li>\r\n    <li>MISRA C++:2008, 2-7-3 - Sections of code should not be \"commented out\" using C++ comments.</li>\r\n    <li>MISRA C:2012, Dir. 4.4 - Sections of code should not be \"commented out\"</li>\r\n</ul>\r\n",
          "severity": "Major",
          "tags": [
            "misra",
            "unused"
          ]
        }
      ]
    },
    {
      "key": "S1134",
      "title": "\"FIXME\" tags should be handled",
      "tags": [],
      "implementations": [
        {
          "key": "S1134",
          "language": "C#",
          "title": "\"FIXME\" tags should be handled",
          "description": "<p>\r\n    <code>FIXME</code> tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with\r\n    later.\r\n</p>\r\n<p>\r\n    Sometimes the developer will not have the time or will simply forget to get back to that tag.\r\n</p>\r\n<p>\r\n    This rule is meant to track those tags, and ensure that they do not go unnoticed.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nprivate int Divide(int numerator, int denominator)\r\n{\r\n  return numerator / denominator;              // FIXME denominator value might be  0\r\n}\r\n</pre>",
          "severity": "Major",
          "tags": []
        }
      ]
    },
    {
      "key": "S1135",
      "title": "\"TODO\" tags should be handled",
      "tags": [],
      "implementations": [
        {
          "key": "S1135",
          "language": "C#",
          "title": "\"TODO\" tags should be handled",
          "description": "<p>\r\n    <code>TODO</code> tags are commonly used to mark places where some more code is required, but which the\r\n    developer wants to implement later.\r\n</p>\r\n<p>\r\n    Sometimes the developer will not have the time or will simply forget to get back to that tag.\r\n</p>\r\n<p>\r\n    This rule is meant to track those tags, and ensure that they do not go unnoticed.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nprivate void DoSomething()\r\n{\r\n  // TODO\r\n}\r\n</pre>",
          "severity": "Info",
          "tags": []
        }
      ]
    },
    {
      "key": "S3240",
      "title": "The simplest possible condition syntax should be used",
      "tags": [
        "clumsy"
      ],
      "implementations": [
        {
          "key": "S3240",
          "language": "C#",
          "title": "The simplest possible condition syntax should be used",
          "description": "<p>\r\n    In the interests of keeping code clean, the simplest possible conditional syntax should be used. That means using\r\n    the <code>??</code> operator for an assign-if-not-null operator, and using the ternary operator <code>?:</code> for\r\n    assignment to a single variable.\r\n</p>\r\n\r\n<h2>Noncompliant Code Sample</h2>\r\n<pre>\r\nobject a = null, b = null, x;\r\n\r\nif (a != null) // Noncompliant; needlessly verbose\r\n{\r\n  x = a;\r\n}\r\nelse\r\n{\r\n  x = b;\r\n}\r\n\r\nx = a != null ? a : b; // Noncompliant; better but could still be simplified\r\n\r\nx = (a == null) ? new object() : a; // Noncompliant\r\n\r\nif (condition) // Noncompliant\r\n{\r\n  x = a;\r\n}\r\nelse\r\n{\r\n  x = b;\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nobject x;\r\n\r\nx = a ?? b;\r\nx = a ?? b;\r\nx = a ?? new object();\r\nx = condition ? a : b;\r\n</pre><h2>Code Fixes</h2><ul><li>Simplify condition</li></ul>",
          "severity": "Minor",
          "tags": [
            "clumsy"
          ]
        }
      ]
    },
    {
      "key": "S1862",
      "title": "Related \"if/else if\" statements should not have the same condition",
      "tags": [
        "bug",
        "cert",
        "pitfall",
        "unused"
      ],
      "implementations": [
        {
          "key": "S1862",
          "language": "C#",
          "title": "Related \"if/else if\" statements should not have the same condition",
          "description": "<p>\r\nA chain of <code>if</code>/<code>else if</code> statements is evaluated from top to bottom. At most, only one branch will be executed: the first one with a condition that evaluates to <code>true</code>.\r\nTherefore, duplicating a condition automatically leads to dead code. Usually, this is due to a copy/paste error. At best, it's simply dead code and at worst, it's a bug that is likely to induce\r\nfurther bugs as the code is maintained, and obviously it could lead to unexpected behavior.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif (param == 1)\r\n  openWindow();\r\nelse if (param == 2)\r\n  closeWindow();\r\nelse if (param == 1)  // Noncompliant\r\n  moveWindowToTheBackground();\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (param == 1)\r\n  openWindow();\r\nelse if (param == 2)\r\n  closeWindow();\r\nelse if (param == 3)\r\n  moveWindowToTheBackground();\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n<li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C</a> - Detect and remove code that has no effect</li>\r\n<li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP</a> - Detect and remove code that has no effect</li>\r\n</ul>",
          "severity": "Critical",
          "tags": [
            "bug",
            "cert",
            "pitfall",
            "unused"
          ]
        }
      ]
    },
    {
      "key": "S1871",
      "title": "Two branches in the same conditional structure should not have exactly the same implementation",
      "tags": [
        "design",
        "suspicious"
      ],
      "implementations": [
        {
          "key": "S1871",
          "language": "C#",
          "title": "Two branches in the same conditional structure should not have exactly the same implementation",
          "description": "<p>\r\n    Having two <code>cases</code> in the same <code>switch</code> statement or branches in the same <code>if</code> structure\r\n    with the same implementation is at best duplicate code, and at worst a coding error. If the same logic is truly needed for\r\n    both instances, then in an <code>if</code> structure they should be combined, or for a <code>switch</code>, one should fall\r\n    through to the other.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nswitch (i)\r\n{\r\n  case 1:\r\n    doSomething();\r\n    break;\r\n  case 2:\r\n    doSomethingDifferent();\r\n    break;\r\n  case 3:  // Noncompliant; duplicates case 1's implementation\r\n    doSomething();\r\n    break;\r\n  default:\r\n    doTheRest();\r\n}\r\n\r\nif (a >= 0 &amp;&amp; a < 10)\r\n{\r\n  doTheThing();\r\n}\r\nelse if (a >= 10 &amp;&amp; a < 20)\r\n{\r\n  doTheOtherThing();\r\n}\r\nelse if (a >= 20 &amp;&amp; a < 50)\r\n{\r\n  doTheThing();  // Noncompliant; duplicates first condition\r\n}\r\nelse\r\n{\r\n  doTheRest();\r\n}\r\n\r\nif (b == 0)\r\n{\r\n  doOneMoreThing();\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nswitch (i) {\r\n  case 1:\r\n  case 3:\r\n    doSomething();\r\n    break;\r\n  case 2:\r\n    doSomethingDifferent();\r\n    break;\r\n  default:\r\n    doTheRest();\r\n}\r\n\r\nif ((a >= 0 &amp;&amp; a < 10) || (a >= 20 &amp;&amp; a < 50))\r\n{\r\n  doTheThing();\r\n}\r\nelse if (a >= 10 &amp;&amp; a < 20)\r\n{\r\n  doTheOtherThing();\r\n}\r\nelse\r\n{\r\n  doTheRest();\r\n}\r\n\r\ndoOneMoreThing();\r\n</pre>\r\nor\r\n<pre>\r\nswitch (i)\r\n{\r\n  case 1:\r\n    doSomething();\r\n    break;\r\n  case 2:\r\n    doSomethingDifferent();\r\n    break;\r\n  case 3:\r\n    doThirdThing();\r\n    break;\r\n  default:\r\n    doTheRest();\r\n}\r\n\r\nif (a >= 0 &amp;&amp; a < 10)\r\n{\r\n  doTheThing();\r\n}\r\nelse if (a >= 10 &amp;&amp; a < 20)\r\n{\r\n  doTheOtherThing();\r\n}\r\nelse if (a >= 20 &amp;&amp; a < 50)\r\n{\r\n  doTheThirdThing();\r\n}\r\nelse\r\n{\r\n  doTheRest();\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "design",
            "suspicious"
          ]
        }
      ]
    },
    {
      "key": "S2760",
      "title": "Sequential tests should not check the same condition",
      "tags": [
        "clumsy",
        "suspicious"
      ],
      "implementations": [
        {
          "key": "S2760",
          "language": "C#",
          "title": "Sequential tests should not check the same condition",
          "description": "<p>\r\n    When the same condition is checked twice in a row, it is either confusing - why have separate checks? - or an error - some other condition\r\n    should have been checked in the second test.\r\n</p>\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif (a == b)\r\n{\r\n  doTheThing(b);\r\n}\r\nif (a == b) // Noncompliant; is this really what was intended?\r\n{\r\n  doTheThing(c);\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (a == b)\r\n{\r\n  doTheThing(b);\r\n  doTheThing(c);\r\n}\r\n</pre>\r\n\r\nor\r\n\r\n<pre>\r\nif (a == b)\r\n{\r\n  doTheThing(b);\r\n}\r\nif (b == c)\r\n{\r\n  doTheThing(c);\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    Since it is a common pattern to test a variable, reassign it if it fails the test, then re-test it, that pattern is ignored.\r\n</p>",
          "severity": "Major",
          "tags": [
            "clumsy",
            "suspicious"
          ]
        }
      ]
    },
    {
      "key": "S2583",
      "title": "Conditions should not unconditionally evaluate to \"true\" or to \"false\"",
      "tags": [
        "bug",
        "cert",
        "cwe",
        "misra"
      ],
      "implementations": [
        {
          "key": "S2583",
          "language": "C#",
          "title": "Conditions should not unconditionally evaluate to \"true\" or to \"false\"",
          "description": "<p>\r\n    Conditional statements using a condition which cannot be anything but <code>false</code> have the effect of making blocks of code\r\n    non-functional. If the condition cannot evaluate to anything but <code>true</code>, the conditional statement is completely\r\n    redundant, and makes the code less readable.\r\n</p>\r\n<p>\r\n    It is quite likely that the code does not match the programmer's intent.\r\n</p>\r\n<p>\r\n    Either the condition should be removed or it should be updated so that it does not always evaluate to <code>true</code> or <code>false</code>.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvar foo = true;\r\n// ...\r\nif (foo) // Noncompliant, always true\r\n{\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li>MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted.</li>\r\n    <li>MISRA C:2012, 14.3 - Controlling expressions shall not be invariant</li>\r\n    <li><a href=\"http://cwe.mitre.org/data/definitions/489\">MITRE, CWE-489</a> - Leftover Debug Code</li>\r\n    <li><a href=\"http://cwe.mitre.org/data/definitions/570\">MITRE, CWE-570</a> - Expression is Always False</li>\r\n    <li><a href=\"http://cwe.mitre.org/data/definitions/571\">MITRE, CWE-571 </a> - Expression is Always True</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never executed</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect</li>\r\n</ul>",
          "severity": "Critical",
          "tags": [
            "bug",
            "cert",
            "cwe",
            "misra"
          ]
        }
      ]
    },
    {
      "key": "S2228",
      "title": "Console logging should not be used",
      "tags": [
        "security",
        "owasp-a6"
      ],
      "implementations": [
        {
          "key": "S2228",
          "language": "C#",
          "title": "Console logging should not be used",
          "description": "<p>\r\n    Debug statements are always useful during development. But include them in production code - particularly\r\n    in code that runs client-side - and you run the risk of inadvertently exposing sensitive information.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nprivate void DoSomething ()\r\n{\r\n  // ...\r\n  Console.WriteLine (\"so far, so good...\"); // Noncompliant\r\n  // ...\r\n}\r\n</pre>\r\n\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li> <a href=\"https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure\">OWASP Top Ten 2013 Category A6</a> - Sensitive Data Exposure</li>\r\n</ul>",
          "severity": "Critical",
          "tags": [
            "security",
            "owasp-a6"
          ]
        }
      ]
    },
    {
      "key": "S1699",
      "title": "Constructors should only call non-overridable methods",
      "tags": [
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S1699",
          "language": "C#",
          "title": "Constructors should only call non-overridable methods",
          "description": "<p>\r\n    Calling an overridable method from a constructor could result in failures or strange behaviors when instantiating a subclass which overrides the method.\r\n</p>\r\n<p>\r\n    For example:\r\n</p>\r\n<ul>\r\n    <li>The subclass class constructor starts by calling the parent class constructor.</li>\r\n    <li>The parent class constructor calls the method, which has been overridden in the child class.</li>\r\n    <li>\r\n        If the behavior of the child class method depends on fields that are initialized in the child class constructor,\r\n        unexpected behavior (like a <code>NullReferenceException</code>) can result, because the fields aren't initialized yet.\r\n    </li>\r\n</ul>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class Parent\r\n{\r\n  public Parent()\r\n  {\r\n    DoSomething();  // Noncompliant\r\n  }\r\n\r\n  public virtual void DoSomething() // can be overridden\r\n  {\r\n    ...\r\n  }\r\n}\r\n\r\npublic class Child : Parent\r\n{\r\n  private string foo;\r\n\r\n  public Child(string foo) // leads to call DoSomething() in Parent constructor which triggers a NullReferenceException as foo has not yet been initialized\r\n  {\r\n    this.foo = foo;\r\n  }\r\n\r\n  public override void DoSomething()\r\n  {\r\n    Console.WriteLine(this.foo.Length);\r\n  }\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S1854",
      "title": "Dead stores should be removed",
      "tags": [
        "suspicious",
        "cert",
        "cwe",
        "unused"
      ],
      "implementations": [
        {
          "key": "S1854",
          "language": "C#",
          "title": "Dead stores should be removed",
          "description": "<p>\r\n    A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction.\r\n    Calculating or retrieving a value only to then overwrite it or throw it away, could indicate a serious error in\r\n    the code. Even if it's not an error, it is at best a waste of resources. Therefore all calculated values should be used.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvoid CalculateRate(int a, int b)\r\n{\r\n  int i;\r\n\r\n  i = a + b; // Noncompliant; calculation result not used before value is overwritten\r\n  i = DoSomething();  // Noncompliant; retrieved value not used\r\n  for (i = 0; i &lt; 10; i++)\r\n  {\r\n    //  ...\r\n  }\r\n  // ...\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvoid CalculateRate(int a, int b)\r\n{\r\n  int i;\r\n\r\n  i = DoSomething();\r\n  i += a + b;\r\n  StoreI(i)\r\n\r\n  for (i = 0; i &lt; 10; i++)\r\n  {\r\n    //  ...\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    No issue is reported when\r\n    <ul>\r\n        <li>the analyzed method body contains <code>try</code> blocks,</li>\r\n        <li>a lambda expression captures the local variables, or</li>\r\n        <li>the variable is unused (case covered by <a class=\"rule-link\" href=\"#version=1.17.0&ruleId=S1481\">Rule S1481</a>).</li>\r\n    </ul>\r\n</p>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li><a href=\"http://cwe.mitre.org/data/definitions/563.html\">MITRE, CWE-563</a> - Assignment to Variable without Use ('Unused Variable')</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/QYA5\">CERT, MSC13-C</a> - Detect and remove unused values</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/S4IyAQ\">CERT, MSC13-CPP</a> - Detect and remove unused values</li>\r\n</ul>\r\n",
          "severity": "Major",
          "tags": [
            "suspicious",
            "cert",
            "cwe",
            "unused"
          ]
        }
      ]
    },
    {
      "key": "S3172",
      "title": "Delegates should not be subtracted",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S3172",
          "language": "C#",
          "title": "Delegates should not be subtracted",
          "description": "<p>\r\n    In C#, delegates can be added together to chain their execution, and subtracted to remove their execution from the chain.\r\n</p>\r\n<p>\r\n    Subtracting a chain of delegates from another one might yield unexpected results as shown hereunder - and is likely to be a bug\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nMyDelegate first, second, third, fourth;\r\nfirst = () => Console.Write(\"1\");\r\nsecond = () => Console.Write(\"2\");\r\nthird = () => Console.Write(\"3\");\r\nfourth = () => Console.Write(\"4\");\r\n\r\nMyDelegate chain1234 = first + second + third + fourth; // Compliant - chain sequence = \"1234\"\r\nMyDelegate chain12 = chain1234 - third - fourth; // Compliant - chain sequence = \"12\"\r\n\r\n// The chain sequence of \"chain23\" will be \"1234\" instead of \"23\"!\r\n// Indeed, the sequence \"1234\" does not contain the subsequence \"14\", so nothing is subtracted\r\n// (but note that \"1234\" contains both the \"1\" and \"4\" subsequences)\r\nMyDelegate chain23 = chain1234 - (first + fourth); // Noncompliant\r\n\r\nchain23(); // will print \"1234\"!\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nMyDelegate chain23 = chain1234 - first - fourth; // Compliant - \"1\" is first removed, followed by \"4\"\r\n\r\nchain23(); // will print \"23\"\r\n</pre>\r\n",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S2931",
      "title": "Classes with \"IDisposable\" members should implement \"IDisposable\"",
      "tags": [
        "bug",
        "cwe",
        "denial-of-service",
        "security"
      ],
      "implementations": [
        {
          "key": "S2931",
          "language": "C#",
          "title": "Classes with \"IDisposable\" members should implement \"IDisposable\"",
          "description": "<p>\r\n    Classes with <code>IDisposable</code> members are responsible for cleaning up those members by calling\r\n    their <code>Dispose</code> methods. The best practice here is for the owning class to itself implement\r\n    <code>IDisposable</code> and call its members' <code>Dispose</code> methods from its own\r\n    <code>Dispose</code> method.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class ResourceHolder   // Noncompliant; doesn't implement IDisposable\r\n{\r\n  private FileStream fs;  // This member is never Dispose'd\r\n  public void OpenResource(string path)\r\n  {\r\n    this.fs = new FileStream(path, FileMode.Open);\r\n  }\r\n  public void CloseResource()\r\n  {\r\n    this.fs.Close();\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class ResourceHolder : IDisposable\r\n{\r\n  private FileStream fs;\r\n  public void OpenResource(string path)\r\n  {\r\n    this.fs = new FileStream(path, FileMode.Open);\r\n  }\r\n  public void CloseResource()\r\n  {\r\n    this.fs.Close();\r\n  }\r\n  public void Dispose()\r\n  {\r\n    this.fs.Dispose();\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li> <a href=\"http://cwe.mitre.org/data/definitions/459.html\">MITRE, CWE-459</a> - Incomplete Cleanup</li>\r\n</ul>\r\n",
          "severity": "Critical",
          "tags": [
            "bug",
            "cwe",
            "denial-of-service",
            "security"
          ]
        }
      ]
    },
    {
      "key": "S2930",
      "title": "\"IDisposables\" should be disposed",
      "tags": [
        "bug",
        "cwe",
        "denial-of-service",
        "security"
      ],
      "implementations": [
        {
          "key": "S2930",
          "language": "C#",
          "title": "\"IDisposables\" should be disposed",
          "description": "<p>\r\n    When writing managed code, you don't need to worry about allocating or freeing memory: The garbage collector takes care of it. For efficiency\r\n    reasons, some objects such as <code>Bitmap</code> use unmanaged memory, enabling for example the use of pointer arithmetic. Such objects have\r\n    potentially huge unmanaged memory footprints, but will have a tiny managed ones. Unfortunately, the garbage collector only sees the tiny\r\n    managed footprint, and fails to reclaim the unmanaged memory (by calling <code>Bitmap</code>'s finalizer method) in a timely fashion.\r\n</p>\r\n\r\n<p>\r\n    Moreover, memory is not the only system resource which needs to managed in a timely fashion: The operating system can only handle having so\r\n    many file descriptors (e.g. <code>FileStream</code>) or sockets (e.g. <code>WebClient</code>) open at any given time. Therefore, it is\r\n    important to <code>Dispose</code> of them as soon as they are no longer needed, rather than relying on the garbage collector to call these\r\n    objects' finalizers at some nondeterministic point in the future.\r\n</p>\r\n\r\n<p>\r\n    This rule tracks <code>private</code> fields and local variables of the following <code>IDisposable</code> types, which are never disposed,\r\n    closed, aliased, returned, or passed to other methods.\r\n</p>\r\n\r\n<ul>\r\n    <li>\r\n        <code>System.IO</code> namespace\r\n        <ul>\r\n            <li><code>System.IO.FileStream</code></li>\r\n            <li><code>System.IO.StreamReader</code></li>\r\n            <li><code>System.IO.StreamWriter</code></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <code>System.Net</code> namespace\r\n        <ul>\r\n            <li><code>System.Net.WebClient</code></li>\r\n        </ul>\r\n    </li>\r\n    <li>\r\n        <code>System.Net.Sockets</code> namespace\r\n        <ul>\r\n            <li><code>System.Net.Sockets.Socket</code></li>\r\n            <li><code>System.Net.Sockets.TcpClient</code></li>\r\n            <li><code>System.Net.Sockets.TcpListener</code></li>\r\n            <li><code>System.Net.Sockets.UdpClient</code></li>\r\n        </ul>\r\n    <li>\r\n        <code>System.Drawing</code> namespace\r\n        <ul>\r\n            <li><code>System.Drawing.Image</code></li>\r\n            <li><code>System.Drawing.Bitmap</code></li>\r\n        </ul>\r\n    </li>\r\n</ul>\r\n\r\nwhich are either instantiated directly using the <code>new</code> operator, or using one of the following factory methods:\r\n\r\n<ul>\r\n    <li><code>System.IO.File.Create()</code></li>\r\n    <li><code>System.IO.File.Open()</code></li>\r\n    <li><code>System.Drawing.Image.FromFile()</code></li>\r\n    <li><code>System.Drawing.Image.FromStream()</code></li>\r\n</ul>\r\n\r\non both private fields and local variables.\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class ResourceHolder\r\n{\r\n  private FileStream fs; // Noncompliant; Dispose or Close are never called\r\n  public void OpenResource(string path)\r\n  {\r\n    this.fs = new FileStream(path, FileMode.Open);\r\n  }\r\n  public void WriteToFile(string path, string text)\r\n  {\r\n    var fs = new FileStream(path, FileMode.Open); // Noncompliant\r\n    var bytes = Encoding.UTF8.GetBytes(text);\r\n    fs.Write(bytes, 0, bytes.Length);\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class ResourceHolder : IDisposable\r\n{\r\n  private FileStream fs;\r\n  public void OpenResource(string path)\r\n  {\r\n    this.fs = new FileStream(path, FileMode.Open);\r\n  }\r\n  public void Dispose()\r\n  {\r\n    this.fs.Dispose();\r\n  }\r\n  public void WriteToFile(string path, string text)\r\n  {\r\n    using (var fs = new FileStream(path, FileMode.Open))\r\n    {\r\n      var bytes = Encoding.UTF8.GetBytes(text);\r\n      fs.Write(bytes, 0, bytes.Length);\r\n    }\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    <code>IDisposable</code> variables returned from a method or passed to other methods are ignored, as are local <code>IDisposable</code>s that\r\n    are initialized with other <code>IDisposable</code>s.\r\n</p>\r\n<pre>\r\npublic Stream WriteToFile(string path, string text)\r\n{\r\n  var fs = new FileStream(path, FileMode.Open); // Compliant, because it is returned\r\n  var bytes = Encoding.UTF8.GetBytes(text);\r\n  fs.Write(bytes, 0, bytes.Length);\r\n  return fs;\r\n}\r\npublic void ReadFromStream(Stream s)\r\n{\r\n  var sr = new StreamReader(s); // Compliant as it would close the underlying stream.\r\n  // ...\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n<ul>\r\n    <li> <a href=\"http://cwe.mitre.org/data/definitions/459.html\">MITRE, CWE-459</a> - Incomplete Cleanup</li>\r\n</ul>\r\n",
          "severity": "Critical",
          "tags": [
            "bug",
            "cwe",
            "denial-of-service",
            "security"
          ]
        }
      ]
    },
    {
      "key": "S2997",
      "title": "\"IDisposables\" created in a \"using\" statement should not be returned",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S2997",
          "language": "C#",
          "title": "\"IDisposables\" created in a \"using\" statement should not be returned",
          "description": "<p>\r\n    Typically you want to use <code>using</code> to create a local <code>IDisposable</code> variable; it will trigger\r\n    disposal of the object when control passes out of the block's scope. The exception to this rule is when your\r\n    method returns that <code>IDisposable</code>. In that case <code>using</code> disposes of the object before the\r\n    caller can make use of it, likely causing exceptions at runtime. So you should either remove <code>using</code> or\r\n    avoid returning the <code>IDisposable</code>.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic FileStream WriteToFile(string path, string text)\r\n{\r\n  using (var fs = File.Create(path)) // Noncompliant\r\n  {\r\n    var bytes = Encoding.UTF8.GetBytes(text);\r\n    fs.Write(bytes, 0, bytes.Length);\r\n    return fs;\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic FileStream WriteToFile(string path, string text)\r\n{\r\n  var fs = File.Create(path);\r\n  var bytes = Encoding.UTF8.GetBytes(text);\r\n  fs.Write(bytes, 0, bytes.Length);\r\n  return fs;\r\n}\r\n</pre>\r\n",
          "severity": "Blocker",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S2952",
      "title": "Classes should \"Dispose\" of members from the classes' own \"Dispose\" methods",
      "tags": [
        "bug",
        "cwe",
        "denial-of-service",
        "security"
      ],
      "implementations": [
        {
          "key": "S2952",
          "language": "C#",
          "title": "Classes should \"Dispose\" of members from the classes' own \"Dispose\" methods",
          "description": "<p>\r\n    It is possible in an <code>IDisposable</code> to call <code>Dispose</code> on class members from any method, but the\r\n    contract of <code>Dispose</code> is that it will clean up all unmanaged resources. Move disposing of members to some\r\n    other method, and you risk resource leaks.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class ResourceHolder : IDisposable\r\n{\r\n  private FileStream fs;\r\n  public void OpenResource(string path)\r\n  {\r\n    this.fs = new FileStream(path, FileMode.Open);\r\n  }\r\n  public void CloseResource()\r\n  {\r\n    this.fs.Close();\r\n  }\r\n\r\n  public void CleanUp()\r\n  {\r\n    this.fs.Dispose(); // Noncompliant; Dispose not called in class' Dispose method\r\n  }\r\n\r\n  public void Dispose()\r\n  {\r\n    // method added to satisfy demands of interface\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class ResourceHolder : IDisposable\r\n{\r\n  private FileStream fs;\r\n  public void OpenResource(string path)\r\n  {\r\n    this.fs = new FileStream(path, FileMode.Open);\r\n  }\r\n  public void CloseResource()\r\n  {\r\n    this.fs.Close();\r\n  }\r\n\r\n  public void Dispose()\r\n  {\r\n    this.fs.Dispose();\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n<ul>\r\n    <li><a href=\"http://cwe.mitre.org/data/definitions/459.html\">MITRE, CWE-459</a> - Incomplete Cleanup</li>\r\n</ul>\r\n",
          "severity": "Critical",
          "tags": [
            "bug",
            "cwe",
            "denial-of-service",
            "security"
          ]
        }
      ]
    },
    {
      "key": "S2953",
      "title": "Methods named \"Dispose\" should implement \"IDisposable.Dispose\"",
      "tags": [
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S2953",
          "language": "C#",
          "title": "Methods named \"Dispose\" should implement \"IDisposable.Dispose\"",
          "description": "<p>\r\n    <code>Dispose</code> as a method name should be used exclusively to implement <code>IDisposable.Dispose</code> to prevent\r\n    any confusion.\r\n</p>\r\n<p>\r\n    It may be tempting to create a <code>Dispose</code> method for other purposes, but doing so will result in confusion and\r\n    likely lead to problems in production.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class GarbageDisposal\r\n{\r\n  private int Dispose()  // Noncompliant\r\n  {\r\n    // ...\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class GarbageDisposal : IDisposable\r\n{\r\n  public void Dispose()\r\n  {\r\n    // ...\r\n  }\r\n}\r\n</pre>\r\nor\r\n<pre>\r\npublic class GarbageDisposal\r\n{\r\n  private int Grind()\r\n  {\r\n    // ...\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    Methods named <code>Dispose</code> and invoked from the <code>IDisposable.Dispose</code> implementation are not reported.\r\n</p>\r\n<pre>\r\npublic class GarbageDisposal : IDisposable\r\n{\r\n  protected virtual void Dispose(bool disposing)\r\n  {\r\n    //...\r\n  }\r\n  public void Dispose()\r\n  {\r\n    Dispose(true);\r\n    GC.SuppressFinalize(this);\r\n  }\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S1186",
      "title": "Methods should not be empty",
      "tags": [
        "suspicious"
      ],
      "implementations": [
        {
          "key": "S1186",
          "language": "C#",
          "title": "Methods should not be empty",
          "description": "<p>\r\nThere are several reasons for a method not to have a method body:\r\n  <ul>\r\n    <li>It is an unintentional omission, and should be fixed.</li>\r\n    <li>It is not yet, or never will be, supported. In this case a <code>NotSupportedException</code> should be thrown.</li>\r\n    <li>The method is an intentionally-blank override. In this case a nested comment should explain the reason for the blank override.</li>\r\n  </ul>\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic override void DoSomething()\r\n{\r\n}\r\n\r\npublic override void doSomethingElse()\r\n{\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic override void DoSomething()\r\n{\r\n  // Do nothing because of X and Y.\r\n}\r\n\r\npublic override void doSomethingElse()\r\n{\r\n  throw new NotSupportedException();\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    The following methods are ignored:\r\n    <ul>\r\n        <li>empty <code>virtual</code> methods,</li>\r\n        <li>empty methods that override an <code>abstract</code> method,</li>\r\n        <li>empty overrides in test assemblies.</li>\r\n    </ul>\r\n</p>\r\n<h2>Code Fixes</h2><ul><li>Throw NotSupportedException</li><li>Add comment</li></ul>",
          "severity": "Major",
          "tags": [
            "suspicious"
          ]
        }
      ]
    },
    {
      "key": "S3261",
      "title": "Namespaces should not be empty",
      "tags": [
        "cert",
        "unused"
      ],
      "implementations": [
        {
          "key": "S3261",
          "language": "C#",
          "title": "Namespaces should not be empty",
          "description": "<p>\r\n    Namespaces with no lines of code clutter a project and should be removed.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nnamespace MyEmptyNamespace // Noncompliant\r\n{\r\n\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n<ul>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/OYIyAQ\">CERT, MSC07-CPP.</a> - Detect and remove dead code</li>\r\n</ul>\r\n<h2>Code Fixes</h2><ul><li>Remove empty namespace</li></ul>",
          "severity": "Info",
          "tags": [
            "cert",
            "unused"
          ]
        }
      ]
    },
    {
      "key": "S108",
      "title": "Nested blocks of code should not be left empty",
      "tags": [
        "suspicious"
      ],
      "implementations": [
        {
          "key": "S108",
          "language": "C#",
          "title": "Nested blocks of code should not be left empty",
          "description": "<p>\r\nMost of the time a block of code is empty when a piece of code is really missing. So such empty block must be either filled or removed.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nfor (int i = 0; i < 42; i++) {}  // Empty on purpose or missing piece of code ?\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    When a block contains a comment, this block is not considered to be empty.\r\n</p>\r\n",
          "severity": "Major",
          "tags": [
            "suspicious"
          ]
        }
      ]
    },
    {
      "key": "S3655",
      "title": "Empty nullable value should not be accessed",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S3655",
          "language": "C#",
          "title": "Empty nullable value should not be accessed",
          "description": "<p>\r\n    Nullable value types can hold either a value or <code>null</code>. The value held in the nullable type can be accessed with the\r\n    <code>Value</code> property, but <code>.Value</code> throws an <code>InvalidOperationException</code> when if the nullable type's\r\n    value is <code>null</code>. To avoid the exception, a nullable type should always be tested before <code>.Value</code> is accessed.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nint? nullable = null;\r\n...\r\nUseValue(nullable.Value); // Noncompliant\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nint? nullable = null;\r\n...\r\nif (nullable.HasValue)\r\n{\r\n  UseValue(nullable.Value);\r\n}\r\n</pre>\r\n\r\n<p>or</p>\r\n\r\n<pre>\r\nint? nullable = null;\r\n...\r\nif (nullable != null)\r\n{\r\n  UseValue(nullable.Value);\r\n}\r\n</pre>",
          "severity": "Blocker",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S1116",
      "title": "Empty statements should be removed",
      "tags": [
        "cert",
        "misra",
        "unused"
      ],
      "implementations": [
        {
          "key": "S1116",
          "language": "C#",
          "title": "Empty statements should be removed",
          "description": "<p>\r\n  Empty statements, i.e. <code>;</code>, are usually introduced by mistake, for example because:\r\n  <ul>\r\n    <li>It was meant to be replaced by an actual statement, but this was forgotten.</li>\r\n    <li>There was a typo which lead the semicolon to be doubled, i.e. <code>;;</code>.</li>\r\n  </ul>\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvoid doSomething()\r\n{\r\n  ; // Noncompliant - was used as a kind of TODO marker\r\n}\r\n\r\nvoid doSomethingElse()\r\n{\r\n  Console.WriteLine(\"Hello, world!\");;  // Noncompliant - double ;\r\n  ...\r\n  // Rarely, they are used on purpose as the body of a loop. It is a bad practice to\r\n  // have side-effects outside of the loop body\r\n  for (int i = 0; i < 3; Console.WriteLine(i), i++); // Noncompliant\r\n  ...\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvoid doSomething()\r\n{\r\n}\r\n\r\nvoid doSomethingElse()\r\n{\r\n  Console.WriteLine(\"Hello, world!\");\r\n  ...\r\n  for (int i = 0; i < 3; i++)\r\n  {\r\n    Console.WriteLine(i);\r\n   }\r\n  ...\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li>MISRA C:2004, 14.3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment provided that the first character following the null statement is a white-space character.</li>\r\n    <li>MISRA C++:2008, 6-2-3 - Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided that the first character following the null statement is a white-space character.</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C</a> - Detect and remove code that has no effect</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP</a> - Detect and remove code that has no effect</li>\r\n</ul><h2>Code Fixes</h2><ul><li>Remove empty statement</li></ul>",
          "severity": "Minor",
          "tags": [
            "cert",
            "misra",
            "unused"
          ]
        }
      ]
    },
    {
      "key": "S2291",
      "title": "Overflow checking should not be disabled for \"Enumerable.Sum\"",
      "tags": [
        "error-handling",
        "security"
      ],
      "implementations": [
        {
          "key": "S2291",
          "language": "C#",
          "title": "Overflow checking should not be disabled for \"Enumerable.Sum\"",
          "description": "<p>\r\n    <code>Enumerable.Sum()</code> always executes addition in a <code>checked</code> context, so an\r\n    <code>OverflowException</code> will be thrown if the value exceeds <code>MaxValue</code> even if an\r\n    <code>unchecked</code> context was specified. Using an <code>unchecked</code> context anyway represents\r\n    a misunderstanding of how <code>Sum</code> works.\r\n</p>\r\n<p>\r\n    This rule raises an issue when an <code>unchecked</code> context is specified for a <code>Sum</code> on\r\n    integer types.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvoid Add(List&lt;int&gt; list)\r\n{\r\n  int d = unchecked(list.Sum());  // Noncompliant\r\n\r\n  unchecked\r\n  {\r\n    int e = list.Sum();  // Noncompliant\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvoid Add(List&lt;int&gt; list)\r\n{\r\n  int d = list.Sum();\r\n\r\n  try\r\n  {\r\n    int e = list.Sum();\r\n  }\r\n  catch (System.OverflowException e)\r\n  {\r\n    // exception handling...\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    When the <code>Sum()</code> call is inside a <code>try-catch</code> block, no issues are reported.\r\n</p>\r\n\r\n<pre>\r\nvoid Add(List&lt;int&gt; list)\r\n{\r\n  unchecked\r\n  {\r\n    try\r\n    {\r\n      int e = list.Sum();\r\n    }\r\n    catch (System.OverflowException e)\r\n    {\r\n      // exception handling...\r\n    }\r\n  }\r\n}\r\n</pre>\r\n",
          "severity": "Critical",
          "tags": [
            "error-handling",
            "security"
          ]
        }
      ]
    },
    {
      "key": "S2344",
      "title": "Enumeration type names should not have \"Flags\" or \"Enum\" suffixes",
      "tags": [
        "convention"
      ],
      "implementations": [
        {
          "key": "S2344",
          "language": "C#",
          "title": "Enumeration type names should not have \"Flags\" or \"Enum\" suffixes",
          "description": "<p>\r\n    The information that an enumeration type is actually an enumeration or a set of flags should not be duplicated in its name.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nenum FooFlags // Noncompliant\r\n{\r\n    Foo = 1\r\n    Bar = 2\r\n    Baz = 4\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nenum Foo\r\n{\r\n    Foo = 1\r\n    Bar = 2\r\n    Baz = 4\r\n}\r\n</pre>\r\n",
          "severity": "Minor",
          "tags": [
            "convention"
          ]
        },
        {
          "key": "S2344",
          "language": "VB.NET",
          "title": "Enumeration type names should not have \"Flags\" or \"Enum\" suffixes",
          "description": "<p>\r\n    The information that an enumeration type is actually an enumeration or a set of flags should not be duplicated in its name.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nEnum FooFlags ' Noncompliant\r\n    Foo = 1\r\n    Bar = 2\r\n    Baz = 4\r\nEnd Enum\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nEnum Foo      ' Compliant\r\n    Foo = 1\r\n    Bar = 2\r\n    Baz = 4\r\nEnd Enum\r\n</pre>\r\n",
          "severity": "Minor",
          "tags": [
            "convention"
          ]
        }
      ]
    },
    {
      "key": "S1244",
      "title": "Floating point numbers should not be tested for equality",
      "tags": [
        "bug",
        "misra"
      ],
      "implementations": [
        {
          "key": "S1244",
          "language": "C#",
          "title": "Floating point numbers should not be tested for equality",
          "description": "<p>\r\n    Floating point math is imprecise because of the challenges of storing such values in a binary\r\n    representation. Even worse, floating point math is not associative; push a <code>float</code> or a <code>double</code>\r\n    through a series of simple mathematical operations and the answer will be different based on\r\n    the order of those operation because of the rounding that takes place at each step.\r\n</p>\r\n<p>\r\n    Even simple floating point assignments are not simple:\r\n</p>\r\n<pre>\r\nfloat f = 0.100000001f; // 0.1\r\ndouble d = 0.10000000000000001; // 0.1\r\n</pre>\r\n\r\n<p>\r\n    (Results will vary based on compiler and compiler settings)\r\n</p>\r\n<p>\r\n    Therefore, the use of the equality (<code>==</code>) and inequality (<code>!=</code>) operators on\r\n    <code>float</code> or <code>double</code> values is almost always an error.\r\n</p>\r\n<p>\r\n    This rule checks for the use of direct and indirect equality/inequailty tests on floats and doubles.\r\n</p>\r\n\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nfloat myNumber = 3.146f;\r\nif ( myNumber == 3.146f ) //Noncompliant. Because of floating point imprecision, this will be false\r\n{\r\n  // ...\r\n}\r\n\r\nif (myNumber &lt;= 3.146f &amp;&amp; mNumber &gt;= 3.146f) // Noncompliant indirect equality test\r\n{\r\n  // ...\r\n}\r\n\r\nif (myNumber &lt; 4 || myNumber &gt; 4) // Noncompliant indirect inequality test\r\n{\r\n  // ...\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n<ul>\r\n    <li>MISRA C:2004, 13.3 - Floating-point expressions shall not be tested for equality or inequality.</li>\r\n    <li>MISRA C++:2008, 6-2-2 - Floating-point expressions shall not be directly or indirectly tested for equality or inequality</li>\r\n</ul>\r\n",
          "severity": "Critical",
          "tags": [
            "bug",
            "misra"
          ]
        }
      ]
    },
    {
      "key": "S2197",
      "title": "Modulus results should not be checked for direct equality",
      "tags": [
        "suspicious"
      ],
      "implementations": [
        {
          "key": "S2197",
          "language": "C#",
          "title": "Modulus results should not be checked for direct equality",
          "description": "<p>\r\n    When the modulus of a negative number is calculated, the result will either be negative or zero. Thus, comparing the modulus\r\n    of a variable for equality with a positive number (or a negative one) could result in unexpected results.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic boo IsOdd(int x)\r\n{\r\n  return x % 2 == 1;  // Noncompliant; if x is an odd negative, x % 2 == -1\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic bool IsOdd(int x)\r\n{\r\n  return x % 2 != 0;\r\n}\r\n</pre>\r\nor\r\n<pre>\r\npublic bool IsOdd(uint x)\r\n{\r\n  return x % 2 == 1;\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "suspicious"
          ]
        }
      ]
    },
    {
      "key": "S3445",
      "title": "Exceptions should not be explicitly rethrown",
      "tags": [
        "confusing"
      ],
      "implementations": [
        {
          "key": "S3445",
          "language": "C#",
          "title": "Exceptions should not be explicitly rethrown",
          "description": "<p>\r\n    When rethrowing an exception, you should do it by simply calling <code>throw;</code> and not <code>throw exc;</code>,\r\n    because the stack trace is reset with the second syntax, making debugging a lot harder.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\ntry\r\n{}\r\ncatch(ExceptionType1 exc)\r\n{\r\n  Console.WriteLine(exc);\r\n  throw exc; // Noncompliant; stacktrace is reset\r\n}\r\ncatch (ExceptionType2 exc)\r\n{\r\n  throw new Exception(\"My custom message\", exc);  // Compliant; stack trace preserved\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\ntry\r\n{}\r\ncatch(ExceptionType1 exc)\r\n{\r\n  Console.WriteLine(exc);\r\n  throw;\r\n}\r\ncatch (ExceptionType2 exc)\r\n{\r\n  throw new Exception(\"My custom message\", exc);\r\n}\r\n</pre><h2>Code Fixes</h2><ul><li>Change to \"throw;\"</li></ul>",
          "severity": "Major",
          "tags": [
            "confusing"
          ]
        }
      ]
    },
    {
      "key": "S1067",
      "title": "Expressions should not be too complex",
      "tags": [
        "brain-overload"
      ],
      "implementations": [
        {
          "key": "S1067",
          "language": "C#",
          "title": "Expressions should not be too complex",
          "description": "<h2 class=\"param-header\">Parameters</h2><dl><dt class=\"param-key\">max</dt><dd><span class=\"param-description\">Maximum number of allowed conditional operators in an expression</span><span class=\"param-type\">INTEGER</span><span class=\"param-default\">3</span></dd></dl><p>\r\nThe complexity of an expression is defined by the number of <code>&&</code>, <code>||</code> and <code>condition ? ifTrue : ifFalse</code> operators it contains.<br/>\r\nA single expression's complexity should not become too high to keep the code readable.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<p>With the default threshold value 3</p>\r\n<pre>\r\nif (((condition1 && condition2) || (condition3 && condition4)) && condition5) { ... }\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif ( (myFirstCondition() || mySecondCondition()) && myLastCondition()) { ... }\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "brain-overload"
          ]
        }
      ]
    },
    {
      "key": "S2387",
      "title": "Child class members should not shadow parent class members",
      "tags": [
        "confusing"
      ],
      "implementations": [
        {
          "key": "S2387",
          "language": "C#",
          "title": "Child class members should not shadow parent class members",
          "description": "<p>\r\n    Having a variable with the same name in two unrelated classes is fine, but do the same thing within a class hierarchy\r\n    and you'll get confusion at best, chaos at worst. Perhaps even worse is the case where a child class field varies from\r\n    the name of a parent class only by case.\r\n</p>\r\n<p>\r\n    This rule ignores <code>private</code> parent class members, but in all other such cases, the child class field should\r\n    be renamed.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class Fruit\r\n{\r\n  protected Season ripe;\r\n  protected Color flesh;\r\n\r\n  // ...\r\n}\r\n\r\npublic class Raspberry : Fruit\r\n{\r\n  private bool ripe;  // Noncompliant\r\n  private static Color FLESH; // Noncompliant\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class Fruit\r\n{\r\n  protected Season ripe;\r\n  protected Color flesh;\r\n\r\n  // ...\r\n}\r\n\r\npublic class Raspberry : Fruit\r\n{\r\n  private bool ripened;\r\n  private static Color FLESH_COLOR;\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "confusing"
          ]
        }
      ]
    },
    {
      "key": "S2933",
      "title": "Fields that are only assigned in the constructor should be \"readonly\"",
      "tags": [
        "confusing"
      ],
      "implementations": [
        {
          "key": "S2933",
          "language": "C#",
          "title": "Fields that are only assigned in the constructor should be \"readonly\"",
          "description": "<p>\r\n    <code>readonly</code> fields can only be assigned in a class constructor. If a class has a field that's\r\n    not marked <code>readonly</code> but is only set in the constructor, it could cause confusion about the\r\n    field's intended use. To avoid confusion, such fields should be marked <code>readonly</code> to make their\r\n    intended use explicit, and to prevent future maintainers from inadvertently changing their use.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass Person\r\n{\r\n  int _birthYear;  // Noncompliant\r\n  Person(int birthYear)\r\n  {\r\n    _birthYear = birthYear;\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nclass Person\r\n{\r\n  readonly int _birthYear;\r\n  Person(int birthYear)\r\n  {\r\n    _birthYear = birthYear;\r\n  }\r\n}\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Add \"readonly\" keyword</li></ul>",
          "severity": "Major",
          "tags": [
            "confusing"
          ]
        }
      ]
    },
    {
      "key": "S2357",
      "title": "Fields should be private",
      "tags": [
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S2357",
          "language": "C#",
          "title": "Fields should be private",
          "description": "<p>\r\n    Fields should not be part of an API, and therefore should always be private. Indeed, they\r\n    cannot be added to an interface for instance, and validation cannot be added later on without\r\n    breaking backward compatiblity. Instead, developers should encapsulate their fields into\r\n    properties. Explicit property getters and setters can be introduced for validation purposes\r\n    or to smooth the transition to a newer system.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class Foo\r\n{\r\n  public int MagicNumber = 42;\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class Foo\r\n{\r\n  public int MagicNumber\r\n  {\r\n    get { return 42; }\r\n  }\r\n}\r\n</pre>\r\nor\r\n<pre>\r\npublic class Foo\r\n{\r\n  private int MagicNumber = 42;\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    <code>static</code> and <code>const</code> fields are ignored.\r\n</p>\r\n",
          "severity": "Major",
          "tags": [
            "pitfall"
          ]
        },
        {
          "key": "S2357",
          "language": "VB.NET",
          "title": "Fields should be private",
          "description": "<p>\r\n    Fields should not be part of an API, and therefore should always be private. Indeed, they\r\n    cannot be added to an interface for instance, and validation cannot be added later on without\r\n    breaking backward compatiblity. Instead, developers should encapsulate their fields into\r\n    properties. Explicit property getters and setters can be introduced for validation purposes\r\n    or to smooth the transition to a newer system.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nClass Foo\r\n    Public Foo = 42          ' Non-Compliant\r\nEnd Class\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nClass Foo\r\n    Public Property Foo = 42 ' Compliant\r\nEnd Class\r\n</pre>\r\nor\r\n<pre>\r\npublic class Foo\r\n{\r\n  private int MagicNumber = 42;\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    <code>Shared </code> and <code>Const</code> fields are ignored.\r\n</p>\r\n",
          "severity": "Major",
          "tags": [
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S104",
      "title": "Files should not have too many lines",
      "tags": [
        "brain-overload"
      ],
      "implementations": [
        {
          "key": "S104",
          "language": "C#",
          "title": "Files should not have too many lines",
          "description": "<h2 class=\"param-header\">Parameters</h2><dl><dt class=\"param-key\">maximumFileLocThreshold</dt><dd><span class=\"param-description\">Maximum authorized lines in a file.</span><span class=\"param-type\">INTEGER</span><span class=\"param-default\">1000</span></dd></dl><p>\r\nA source file that grows too much tends to aggregate too many responsibilities and inevitably becomes harder to understand and therefore to maintain.\r\nAbove a specific threshold, it is strongly advised to refactor it into smaller pieces of code which focus on well defined tasks.\r\nThose smaller files will not only be easier to understand but also probably easier to test.\r\n</p>\r\n",
          "severity": "Major",
          "tags": [
            "brain-overload"
          ]
        }
      ]
    },
    {
      "key": "S2345",
      "title": "Flags enumerations should explicitly initialize all their members",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S2345",
          "language": "C#",
          "title": "Flags enumerations should explicitly initialize all their members",
          "description": "<p>\r\n    Flags enumerations should not rely on the language to initialize the values of their members. Implicit initialization\r\n    will set the first member to 0, and increment the value by one for each subsequent member. This implicit behavior does\r\n    not allow members to be combined using the bitwise or operator.\r\n</p>\r\n<p>\r\n    Instead, 0 and powers of two values, i.e. 1, 2, 4, 8, 16, etc. should be used to explicitly initialize all the members.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\n[Flags]\r\nenum FruitType    // Noncompliant\r\n{\r\n  None,\r\n  Banana,\r\n  Orange,\r\n  Strawberry\r\n}\r\nclass Program\r\n{\r\n  static void Main()\r\n  {\r\n    var bananaAndStrawberry = FruitType.Banana | FruitType.Strawberry;\r\n    // Will display only Strawberry!\r\n    Console.WriteLine(bananaAndStrawberry.ToString());\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\n[Flags]\r\nenum FruitType\r\n{\r\n  None = 0,\r\n  Banana = 1,\r\n  Orange = 2,\r\n  Strawberry = 4\r\n}\r\nclass Program\r\n{\r\n  static void Main()\r\n  {\r\n    var bananaAndStrawberry = FruitType.Banana | FruitType.Strawberry;\r\n    // Will display Banana and Strawberry, as expected.\r\n    Console.WriteLine(bananaAndStrawberry.ToString());\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    The default initialization of 0, 1, 2, 3, 4, ... matches 0, 1, 2, 4, 8 ... in the first three values, so no issue is reported\r\n    if the first three members of the enumeration is not initialized.\r\n</p>\r\n",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        },
        {
          "key": "S2345",
          "language": "VB.NET",
          "title": "Flags enumerations should explicitly initialize all their members",
          "description": "<p>\r\n    Flags enumerations should not rely on the language to initialize the values of their members. Implicit initialization\r\n    will set the first member to 0, and increment the value by one for each subsequent member. This implicit behavior does\r\n    not allow members to be combined using the bitwise or operator.\r\n</p>\r\n<p>\r\n    Instead, 0 and powers of two values, i.e. 1, 2, 4, 8, 16, etc. should be used to explicitly initialize all the members.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\n&lt;Flags()&gt;\r\nEnum FruitType    ' Non-Compliant\r\n  None\r\n  Banana\r\n  Orange\r\n  Strawberry\r\nEnd Enum\r\n\r\nModule Module1\r\n  Sub Main()\r\n    Dim bananaAndStrawberry = FruitType.Banana Or FruitType.Strawberry\r\n\r\n    ' Will display only Strawberry!\r\n    Console.WriteLine(bananaAndStrawberry.ToString())\r\n  End Sub\r\nEnd Module\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\n&lt;Flags()&gt;\r\nEnum FruitType    ' Compliant\r\n  None = 0\r\n  Banana = 1\r\n  Orange = 2\r\n  Strawberry = 4\r\nEnd Enum\r\n\r\nModule Module1\r\n  Sub Main()\r\n    Dim bananaAndStrawberry = FruitType.Banana Or FruitType.Strawberry\r\n\r\n    ' Will display Banana and Strawberry, as expected.\r\n    Console.WriteLine(bananaAndStrawberry.ToString())\r\n  End Sub\r\nEnd Module\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    The default initialization of 0, 1, 2, 3, 4, ... matches 0, 1, 2, 4, 8 ... in the first three values, so no issue is reported\r\n    if the first three members of the enumeration is not initialized.\r\n</p>\r\n",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S2346",
      "title": "Flags enumerations zero-value members should be named \"None\"",
      "tags": [
        "convention"
      ],
      "implementations": [
        {
          "key": "S2346",
          "language": "C#",
          "title": "Flags enumerations zero-value members should be named \"None\"",
          "description": "<p>\r\n    Consisitent use of \"None\" in flags enumerations indicates that all flag values are cleared.\r\n    The value 0 should not be used to indicate any other state, since there is no way to check that the bit <code>0</code> is set.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\n[Flags]\r\nenum FruitType\r\n{\r\n    Void = 0,       // Non-Compliant\r\n    Banana = 1,\r\n    Orange = 2,\r\n    Strawberry = 4\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\n[Flags]\r\nenum FruitType\r\n{\r\n    None = 0,       // Compliant\r\n    Banana = 1,\r\n    Orange = 2,\r\n    Strawberry = 4\r\n}\r\n</pre>\r\n",
          "severity": "Minor",
          "tags": [
            "convention"
          ]
        },
        {
          "key": "S2346",
          "language": "VB.NET",
          "title": "Flags enumerations zero-value members should be named \"None\"",
          "description": "<p>\r\n    Consisitent use of \"None\" in flags enumerations indicates that all flag values are cleared.\r\n    The value 0 should not be used to indicate any other state, since there is no way to check that the bit <code>0</code> is set.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\n&lt;Flags()&gt;\r\nEnum FruitType\r\n    Void = 0        ' Non-Compliant\r\n    Banana = 1\r\n    Orange = 2\r\n    Strawberry = 4\r\nEnd Enum\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\n&lt;Flags()&gt;\r\nEnum FruitType\r\n    None = 0        ' Compliant\r\n    Banana = 1\r\n    Orange = 2\r\n    Strawberry = 4\r\nEnd Enum\r\n</pre>\r\n",
          "severity": "Minor",
          "tags": [
            "convention"
          ]
        }
      ]
    },
    {
      "key": "S3217",
      "title": "\"Explicit\" conversions of \"foreach\" loops should not be used",
      "tags": [
        "suspicious"
      ],
      "implementations": [
        {
          "key": "S3217",
          "language": "C#",
          "title": "\"Explicit\" conversions of \"foreach\" loops should not be used",
          "description": "<p>\r\n    The <code>foreach</code> statement was introduced in the C# language prior to generics. To make it easier to work with\r\n    non-generic collections available at that time such as <code>ArrayList</code>, the <code>foreach</code> statements allows\r\n    to downcast the collection's element of type <code>Object</code> into any other type. The problem is that, to achieve that,\r\n    the <code>foreach</code> statements silently performs <code>explicit</code> type conversion, which at runtime can result in\r\n    an <code>InvalidCastException</code> to be thrown.\r\n</p>\r\n<p>\r\n    C# code iterating on generic collections or arrays should not rely on <code>foreach</code> statement's silent <code>explicit</code>\r\n    conversions.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class Fruit { }\r\npublic class Orange : Fruit { }\r\npublic class Apple : Fruit { }\r\n\r\nclass MyTest\r\n{\r\n  public void Test()\r\n  {\r\n    var fruitBasket = new List&lt;Fruit&gt;();\r\n    fruitBasket.Add(new Orange());\r\n    fruitBasket.Add(new Orange());\r\n    // fruitBasket.Add(new Apple());  // uncommenting this line will make both foreach below throw an InvalidCastException\r\n\r\n    foreach (Fruit fruit in fruitBasket)\r\n    {\r\n      var orange = (Orange)fruit; // This \"explicit\" conversion is hidden within the foreach loop below\r\n      ...\r\n    }\r\n\r\n    foreach (Orange orange in fruitBasket) // Noncompliant\r\n    {\r\n      ...\r\n    }\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvar fruitBasket = new List&lt;Orange&gt;();\r\nfruitBasket.Add(new Orange());\r\nfruitBasket.Add(new Orange());\r\n// fruitBasket.Add(new Apple());  // uncommenting this line won't compile\r\n\r\nforeach (Orange orange in fruitBasket)\r\n{\r\n  ...\r\n}\r\n</pre>\r\nor\r\n<pre>\r\nvar fruitBasket = new List&lt;Fruit&gt;();\r\nfruitBasket.Add(new Orange());\r\nfruitBasket.Add(new Orange());\r\nfruitBasket.Add(new Apple());\r\n\r\nforeach (Orange orange in fruitBasket.OfType&lt;Orange&gt;())\r\n{\r\n  ...\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    The rule ignores iterations on collections of <code>object</code>s. This includes legacy code that uses\r\n    <code>ArrayList</code>. Furthermore, the rule does not report on cases when user defined conversions are\r\n    being called.\r\n</p>\r\n<h2>Code Fixes</h2><ul><li>Filter collection for the expected type</li></ul>",
          "severity": "Major",
          "tags": [
            "suspicious"
          ]
        }
      ]
    },
    {
      "key": "S127",
      "title": "\"for\" loop stop conditions should be invariant",
      "tags": [
        "misra",
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S127",
          "language": "C#",
          "title": "\"for\" loop stop conditions should be invariant",
          "description": "<p>\r\n    <code>for</code> loop stop conditions must be invariant (i.e. true at both the beginning and ending of every loop iteration). Ideally, this means that the stop condition is set to a local variable just before the loop begins.\r\n</p>\r\n<p>\r\n    Stop conditions that are not invariant are difficult to understand and maintain, and will likely lead to the introduction of errors in the future.\r\n</p>\r\n<p>\r\n    This rule tracks three types of non-invariant stop conditions:\r\n    <ul>\r\n        <li>When the loop counters are updated in the body of the <code>for</code> loop</li>\r\n        <li>When the stop condition depend upon a method call</li>\r\n        <li>When the stop condition depends on an object property, since such properties could change during the execution of the loop.</li>\r\n    </ul>\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass Foo\r\n{\r\n    static void Main()\r\n    {\r\n        for (int i = 1; i &lt;= 5; i++)\r\n        {\r\n            Console.WriteLine(i);\r\n            if (condition)\r\n            {\r\n               i = 20;\r\n           }\r\n        }\r\n    }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nclass Foo\r\n{\r\n    static void Main()\r\n    {\r\n        for (int i = 1; i &lt;= 5; i++)\r\n        {\r\n            Console.WriteLine(i);\r\n        }\r\n    }\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li>MISRA C:2004, 13.6 - Numeric variables being used within a for loop for iteration counting shall not be modified in the body of the loop.</li>\r\n    <li>MISRA C++:2008, 6-5-3 - The loop-counter shall not be modified within condition or statement.</li>\r\n</ul>\r\n",
          "severity": "Major",
          "tags": [
            "misra",
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S1994",
      "title": "\"for\" loop incrementers should modify the variable being tested in the loop's stop condition",
      "tags": [
        "suspicious"
      ],
      "implementations": [
        {
          "key": "S1994",
          "language": "C#",
          "title": "\"for\" loop incrementers should modify the variable being tested in the loop's stop condition",
          "description": "<p>\r\nIt is almost always an error when a <code>for</code> loop's stop condition and incrementer don't act on the same variable. Even when it is not, it could confuse future maintainers of the code, and should be avoided.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nfor (i = 0; i < 10; j++) // Noncompliant\r\n{\r\n  // ...\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nfor (i = 0; i < 10; i++)\r\n{\r\n  // ...\r\n}\r\n</pre>",
          "severity": "Major",
          "tags": [
            "suspicious"
          ]
        }
      ]
    },
    {
      "key": "S3376",
      "title": "Attribute, EventArgs, and Exception type names should end with the type being extended",
      "tags": [
        "convention"
      ],
      "implementations": [
        {
          "key": "S3376",
          "language": "C#",
          "title": "Attribute, EventArgs, and Exception type names should end with the type being extended",
          "description": "<p>\r\n    Adherence to the standard naming conventions makes your code not only more readable, but more usable. For instance,\r\n    <code>class FirstAttribute : Attribute</code> can be used simply with <code>First</code>, but you must use the full\r\n    name for <code>class AttributeOne : Attribute</code>.\r\n</p>\r\n<p>\r\n    This rule raises an issue when classes extending <code>Attribute</code>, <code>EventArgs</code>, or\r\n    <code>Exception</code>, do not end with their parent class names.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass AttributeOne : Attribute  // Noncompliant\r\n{\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nclass FirstAttribute : Attribute\r\n{\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    If a class' direct base class doesn't follow the convention, then no issue is reported on the class itself, regardless of\r\n    whether or not it conforms to the convention.\r\n</p>\r\n<pre>\r\nclass Timeout : Exception // Noncompliant\r\n{\r\n}\r\nclass ExtendedTimeout : Timeout // Ignored; doesn't conform to convention, but the direct base doesn't conform either\r\n{\r\n}\r\n</pre>",
          "severity": "Minor",
          "tags": [
            "convention"
          ]
        }
      ]
    },
    {
      "key": "S1541",
      "title": "Methods should not be too complex",
      "tags": [
        "brain-overload"
      ],
      "implementations": [
        {
          "key": "S1541",
          "language": "C#",
          "title": "Methods should not be too complex",
          "description": "<h2 class=\"param-header\">Parameters</h2><dl><dt class=\"param-key\">maximumFunctionComplexityThreshold</dt><dd><span class=\"param-description\">The maximum authorized complexity in function</span><span class=\"param-type\">INTEGER</span><span class=\"param-default\">10</span></dd></dl><p>The cyclomatic complexity of a function should not exceed a defined threshold.</p>\r\n<p>Complex code can perform poorly and will in any case be difficult to understand and therefore to maintain.</p>\r\n",
          "severity": "Major",
          "tags": [
            "brain-overload"
          ]
        }
      ]
    },
    {
      "key": "S134",
      "title": "Control flow statements \"if\", \"for\", \"foreach\", \"do\", \"while\", \"switch\" and \"try\" should not be nested too deeply",
      "tags": [
        "brain-overload"
      ],
      "implementations": [
        {
          "key": "S134",
          "language": "C#",
          "title": "Control flow statements \"if\", \"for\", \"foreach\", \"do\", \"while\", \"switch\" and \"try\" should not be nested too deeply",
          "description": "<h2 class=\"param-header\">Parameters</h2><dl><dt class=\"param-key\">max</dt><dd><span class=\"param-description\">Maximum allowed control flow statement nesting depth</span><span class=\"param-type\">INTEGER</span><span class=\"param-default\">3</span></dd></dl><p>\r\n    Nested <code>if</code>, <code>switch</code>, <code>for</code>, <code>foreach</code>, <code>while</code>, <code>do</code>, and <code>try</code> statements\r\n    are key ingredients for making what's known as \"Spaghetti code\". Such code is hard to read, refactor and therefore maintain.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n\r\n<p>With the default threshold of 3:</p>\r\n\r\n<pre>\r\nif (condition1) // Compliant - depth = 1\r\n{\r\n  /* ... */\r\n  if (condition2) // Compliant - depth = 2\r\n  {\r\n    /* ... */\r\n    for(int i = 0; i < 10; i++) // Compliant - depth = 3, not exceeding the limit\r\n    {\r\n      /* ... */\r\n      if (condition4) // Noncompliant - depth = 4\r\n      {\r\n        if (condition5) // Depth = 5, exceeding the limit, but issues are only reported on depth = 4\r\n        {\r\n          /* ... */\r\n        }\r\n        return;\r\n      }\r\n    }\r\n  }\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "brain-overload"
          ]
        }
      ]
    },
    {
      "key": "S2934",
      "title": "Property assignments should not be made for \"readonly\" fields not constrained to reference types",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S2934",
          "language": "C#",
          "title": "Property assignments should not be made for \"readonly\" fields not constrained to reference types",
          "description": "<p>\r\n    While the properties of a <code>readonly</code> reference type field can still be changed after initialization,\r\n    those of a <code>readonly</code> value field, such as a <code>struct</code>, cannot.\r\n</p>\r\n<p>\r\n    If the member could be either a <code>class</code> or a <code>struct</code> then assignment to its properties\r\n    could be unreliable, working sometimes but not others.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\ninterface IPoint\r\n{\r\n  int X { get; set; }\r\n  int Y { get; set; }\r\n}\r\n\r\nclass PointManager&lt;T&gt; where T: IPoint\r\n{\r\n  readonly T point;  // this could be a struct\r\n  public PointManager(T point)\r\n  {\r\n    this.point = point;\r\n  }\r\n\r\n  public void MovePointVertically(int newX)\r\n  {\r\n    point.X = newX; //Noncompliant; if point is a struct, then nothing happened\r\n    Console.WriteLine(point.X);\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\ninterface IPoint\r\n{\r\n  int X { get; set; }\r\n  int Y { get; set; }\r\n}\r\n\r\nclass PointManager&lt;T&gt; where T : IPoint\r\n{\r\n  readonly T point;  // this could be a struct\r\n  public PointManager(T point)\r\n  {\r\n    this.point = point;\r\n  }\r\n\r\n  public void MovePointVertically(int newX) // assignment has been removed\r\n  {\r\n    Console.WriteLine(point.X);\r\n  }\r\n}\r\n</pre>\r\nor\r\n<pre>\r\ninterface IPoint\r\n{\r\n  int X { get; set; }\r\n  int Y { get; set; }\r\n}\r\n\r\nclass PointManager&lt;T&gt; where T : class, IPoint\r\n{\r\n  readonly T point;  // this can only be a class\r\n  public PointManager(T point)\r\n  {\r\n    this.point = point;\r\n  }\r\n\r\n  public void MovePointVertically(int newX)\r\n  {\r\n    point.X = newX;  // this assignment is guaranteed to work\r\n    Console.WriteLine(point.X);\r\n  }\r\n}\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Remove assignment</li><li>Add reference type constraint</li></ul>",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S2955",
      "title": "Generic parameters not constrained to reference types should not be compared to \"null\"",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S2955",
          "language": "C#",
          "title": "Generic parameters not constrained to reference types should not be compared to \"null\"",
          "description": "<p>\r\n    When constraints have not been applied to restrict a generic type parameter to be a reference type,\r\n    then a value type, such as a <code>struct</code>, could also be passed. In such cases, comparing the\r\n    type parameter to <code>null</code> would always be false, because a <code>struct</code> can\r\n    be empty, but never <code>null</code>. If a value type is truly what's expected, then the comparison should use\r\n    <code>default()</code>. If it's not, then constraints should be added so that no value type can be\r\n    passed.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nprivate bool IsDefault&lt;T&gt;(T value)\r\n{\r\n  if (value == null) // Noncompliant\r\n  {\r\n    // ...\r\n  }\r\n  // ...\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nprivate bool IsDefault&lt;T&gt;(T value)\r\n{\r\n  if(object.Equals(value, default(T)))\r\n  {\r\n    // ...\r\n  }\r\n  // ...\r\n}\r\n</pre>\r\nor\r\n<pre>\r\nprivate bool IsDefault&lt;T&gt;(T value) where T : class\r\n{\r\n  if (value == null)\r\n  {\r\n    // ...\r\n  }\r\n  // ...\r\n}\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Change null checking</li></ul>",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S3246",
      "title": "Generic type parameters should be co/contravariant when possible",
      "tags": [
        "api-design"
      ],
      "implementations": [
        {
          "key": "S3246",
          "language": "C#",
          "title": "Generic type parameters should be co/contravariant when possible",
          "description": "<p>\r\n    In the interests of making code as usable as possible, interfaces and delegates with generic parameters should use the\r\n    <code>out</code> and <code>in</code> modifiers when possible to make the interfaces and delegates covariant and contravariant,\r\n    respectively.\r\n</p>\r\n<p>\r\n    The <code>out</code> keyword can be used when the type parameter is used only as a return type in the interface or delegate.\r\n    Doing so makes the parameter covariant, and allows interface and delegate instances created with a sub-type to be used as\r\n    instances created with a base type. The most notable example of this is <code>IEnumerable&lt;out T&gt;</code>, which allows\r\n    the assignment of an <code>IEnumerable&lt;string&gt;</code> instance to an <code>IEnumerable&lt;object&gt;</code> variable,\r\n    for instance.\r\n</p>\r\n<p>\r\n    The <code>in</code> keyword can be used when the type parameter is used only as a method parameter in the interface or a\r\n    parameter in the delegate. Doing so makes the parameter contravariant, and allows interface and delegate instances created\r\n    with a base type to be used as instances created with a sub-type. I.e. this is the inversion of covariance. The most notable\r\n    example of this is the <code>Action&lt;in T&gt;</code> delegate, which allows the assignment of an\r\n    <code>Action&lt;object&gt;</code> instance to a <code>Action&lt;string&gt;</code> variable, for instance.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\ninterface IConsumer&lt;T&gt;  // Noncompliant\r\n{\r\n    bool Eat(T fruit);\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\ninterface IConsumer&lt;in T&gt;\r\n{\r\n    bool Eat(T fruit);\r\n}\r\n</pre>\r\n",
          "severity": "Info",
          "tags": [
            "api-design"
          ]
        }
      ]
    },
    {
      "key": "S2326",
      "title": "Unused type parameters should be removed",
      "tags": [
        "unused"
      ],
      "implementations": [
        {
          "key": "S2326",
          "language": "C#",
          "title": "Unused type parameters should be removed",
          "description": "<p>\r\n    Type parameters that aren't used are dead code, which can only distract and possibly confuse\r\n    developers during maintenance. Therefore, unused type parameters should be removed.\r\n</p>\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class MoreMath&lt;T&gt; // Noncompliant; &lt;T&gt;is ignored\r\n{\r\n  public int Add&lt;T&gt;(int a, int b) // Noncompliant; &lt;T&gt; is ignored\r\n  {\r\n    return a + b;\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class MoreMath\r\n{\r\n  public int Add (int a, int b)\r\n  {\r\n    return a + b;\r\n  }\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "unused"
          ]
        }
      ]
    },
    {
      "key": "S3249",
      "title": "Classes directly extending \"object\" should not call \"base\" in \"GetHashCode\" or \"Equals\"",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S3249",
          "language": "C#",
          "title": "Classes directly extending \"object\" should not call \"base\" in \"GetHashCode\" or \"Equals\"",
          "description": "<p>\r\n    Making a <code>base</code> call in an overridden method is generally a good idea, but not in <code>GetHashCode</code> and\r\n    <code>Equals</code> for classes that directly extend <code>object</code> because those methods are based on the object reference.\r\n    Meaning that no two <code>objects</code> that use those <code>base</code> methods will ever be equal or have the same hash.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class Point\r\n{\r\n  private readonly int x;\r\n  public MyClass(int x)\r\n  {\r\n    this.x = x;\r\n  }\r\n  public override int GetHashCode()\r\n  {\r\n    return x.GetHashCode() ^ base.GetHashCode(); //Noncompliant\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class Point\r\n{\r\n  private readonly int x;\r\n  public MyClass(int x)\r\n  {\r\n    this.x = x;\r\n  }\r\n  public override int GetHashCode()\r\n  {\r\n    return x.GetHashCode();\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    This rule doesn't report on guard conditions checking for reference equality.\r\n</p>\r\n<pre>\r\npublic class Point\r\n{\r\n  public override bool Equals(object obj)\r\n  {\r\n    if (base.Equals(obj)) // Compliant, although it could be replaced with object.ReferenceEquals(obj, this), which is clearer\r\n    {\r\n      return true;\r\n    }\r\n    ...\r\n  }\r\n}\r\n</pre>\r\n\r\n",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S2328",
      "title": "\"GetHashCode\" should not reference mutable fields",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S2328",
          "language": "C#",
          "title": "\"GetHashCode\" should not reference mutable fields",
          "description": "<p>\r\n    <code>GetHashCode</code> is used to file an object in a <code>Dictionary</code> or <code>Hashtable</code>.\r\n    If <code>GetHashCode</code> uses non-<code>readonly</code> fields and those fields change after the object\r\n    is stored, the object immediately becomes mis-filed in the <code>Hashtable</code>. Any subsequent test to\r\n    see if the object is in the <code>Hashtable</code> will return a false negative.\r\n</p>\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class Person\r\n{\r\n  public int age;\r\n  public string name;\r\n\r\n  public override int GetHashCode()\r\n  {\r\n    int hash = 12;\r\n    hash += this.age.GetHashCode(); // Noncompliant\r\n    hash += this.name.GetHashCode(); // Noncompliant\r\n    return hash;\r\n  }\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class Person\r\n{\r\n  public readonly DateTime birthday;\r\n  public string name;\r\n\r\n  public override int GetHashCode()\r\n  {\r\n    int hash = 12;\r\n    hash += this.birthday.GetHashCode();\r\n    return hash;\r\n  }\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Make field \"readonly\"</li></ul>",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S2219",
      "title": "Runtime type checking should be simplified",
      "tags": [
        "clumsy"
      ],
      "implementations": [
        {
          "key": "S2219",
          "language": "C#",
          "title": "Runtime type checking should be simplified",
          "description": "<p>\r\n    To check the type of an object there are several options:\r\n    <ul>\r\n        <li>\r\n            <code>expr is SomeType</code> or <code>expr.GetType() == typeof(SomeType)</code> if the\r\n            type is known at compile time,</li>\r\n        <li><code>typeInstance.IsInstanceOfType(expr)</code> if the type is calculated during runtime.</li>\r\n    </ul>\r\n</p>\r\n<p>\r\n    If runtime calculated <code>Type</code>s need to be compared:\r\n    <ul>\r\n        <li><code>typeInstance1.IsAssignableFrom(typeInstance2)</code>.</li>\r\n    </ul>\r\n</p>\r\n<p>\r\n    Depending on whether the type is returned by a <code>GetType()</code> or <code>typeof()</code> call, the <code>IsAssignableFrom()</code> and\r\n    <code>IsInstanceOfType()</code> might be simplified. Similarly, if the type is sealed, the type comparison with <code>==</code> can be converted\r\n    to an <code>is</code> call. Simplifying the calls also make <code>null</code> checking unnecessary because both <code>is</code> and\r\n    <code>IsInstanceOfType</code> performs it already.\r\n</p>\r\n<p>\r\n    Finally, utilizing the most concise language constructs for type checking makes the code more readable, so\r\n    <ul>\r\n        <li><code>expr as T != null</code> checks should be simplified to <code>expr is T</code>, and</li>\r\n        <li><code>expr is T</code> should be converted to <code>expr != null</code>, when <code>expr</code> is of type <code>T</code>.</li>\r\n    </ul>\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass Fruit { }\r\nsealed class Apple : Fruit { }\r\n\r\nclass Program\r\n{\r\n  static void Main()\r\n  {\r\n    var apple = new Apple();\r\n    var b = apple != null &amp;&amp; apple.GetType() == typeof (Apple); // Noncompliant\r\n    b = typeof(Apple).IsInstanceOfType(apple); // Noncompliant\r\n    if (apple != null)\r\n    {\r\n      b = typeof(Apple).IsAssignableFrom(apple.GetType()); // Noncompliant\r\n    }\r\n    var appleType = typeof (Apple);\r\n    if (apple != null)\r\n    {\r\n      b = appleType.IsAssignableFrom(apple.GetType()); // Noncompliant\r\n    }\r\n\r\n    Fruit f = apple;\r\n    if (f as Apple != null) // Noncompliant\r\n    {\r\n    }\r\n    if (apple is Apple) // Noncompliant\r\n    {\r\n    }\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nclass Fruit { }\r\nsealed class Apple : Fruit { }\r\n\r\nclass Program\r\n{\r\n  static void Main()\r\n  {\r\n    var apple = new Apple();\r\n    var b = apple is Apple;\r\n    b = apple is Apple;\r\n    b = apple is Apple;\r\n    var appleType = typeof(Apple);\r\n    b = appleType.IsInstanceOfType(apple);\r\n\r\n    Fruit f = apple;\r\n    if (f is Apple)\r\n    {\r\n    }\r\n    if (apple != null)\r\n    {\r\n    }\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    Calling <code>GetType</code> on an object of <code>Nullable&lt;T&gt;</code> type returns the underlying generic type parameter\r\n    <code>T</code>, thus a comparison with <code>typeof(Nullable&lt;T&gt;)</code> can't be simplified to use the <code>is</code> operator,\r\n    which doesn't make difference between <code>T</code> and <code>T?</code>.\r\n</p>\r\n<pre>\r\nint? i = 42;\r\nbool condition = i.GetType() == typeof(int?); // false;\r\ncondition = i is int?; // true\r\n</pre>\r\n\r\n<p>\r\n    No issue is reported on <code>expr is T</code> expressions if either operand of the <code>is</code> operator is a value type. \r\n    In that case CS0183 or CS0184 reports.\r\n</p><h2>Code Fixes</h2><ul><li>Simplify type checking</li></ul>",
          "severity": "Minor",
          "tags": [
            "clumsy"
          ]
        }
      ]
    },
    {
      "key": "S907",
      "title": "\"goto\" statement should not be used",
      "tags": [
        "brain-overload",
        "misra"
      ],
      "implementations": [
        {
          "key": "S907",
          "language": "C#",
          "title": "\"goto\" statement should not be used",
          "description": "<p>\r\n    <code>goto</code> is an unstructured control flow statement. It makes code less readable and maintainable.\r\n    Structured control flow statements such as <code>if</code>, <code>for</code>, <code>while</code>,\r\n    <code>continue</code> or <code>break</code> should be used instead.\r\n</p>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li>MISRA C:2004, 14.4 - The goto statement shall not be used.</li>\r\n    <li>MISRA C:2012, 15.1 - The goto statement should not be used</li>\r\n</ul>\r\n",
          "severity": "Major",
          "tags": [
            "brain-overload",
            "misra"
          ]
        }
      ]
    },
    {
      "key": "S3397",
      "title": "\"base.Equals\" should not be used to check for reference equality in \"Equals\" if \"base\" is not \"object\"",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S3397",
          "language": "C#",
          "title": "\"base.Equals\" should not be used to check for reference equality in \"Equals\" if \"base\" is not \"object\"",
          "description": "<p>\r\n    <code>object.Equals()</code> overrides can be optimized by checking first for reference equality between <code>this</code> and the\r\n    parameter. This check can be implemented by calling <code>object.ReferenceEquals()</code> or <code>base.Equals()</code>, where\r\n    <code>base</code> is <code>object</code>. However, using <code>base.Equals()</code> is a maintenance hazard because while it works\r\n    if you extend <code>Object</code> directly, if you introduce a new base class that overrides <code>Equals</code>, it suddenly stops\r\n    working.\r\n</p>\r\n<p>\r\n    This rule raises an issue if <code>base.Equals()</code> is used but <code>base</code> is not <code>object</code>.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass Base\r\n{\r\n  private int baseField;\r\n\r\n  public override bool Equals(object other)\r\n  {\r\n    if (base.Equals(other)) // Okay; base is object\r\n    {\r\n      return true;\r\n    }\r\n\r\n    return this.baseField == ((Base)other).baseField;\r\n  }\r\n}\r\n\r\nclass Derived : Base\r\n{\r\n  private int derivedField;\r\n\r\n  public override bool Equals(object other)\r\n  {\r\n    if (base.Equals(other))  // Noncompliant\r\n    {\r\n      return true;\r\n    }\r\n\r\n    return this.derivedField == ((Derived)other).derivedField;\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nclass Base\r\n{\r\n  private int baseField;\r\n\r\n  public override bool Equals(object other)\r\n  {\r\n    if (object.ReferenceEquals(this, other))  // base.Equals is okay here, but object.ReferenceEquals is better\r\n    {\r\n      return true;\r\n    }\r\n\r\n    return this.baseField == ((Base)other).baseField;\r\n  }\r\n}\r\n\r\nclass Derived : Base\r\n{\r\n  private int derivedField;\r\n\r\n  public override bool Equals(object other)\r\n  {\r\n    if (object.ReferenceEquals(this, other))\r\n    {\r\n      return true;\r\n    }\r\n\r\n    return base.Equals(other) &amp;&amp; this.derivedField == ((Derived)other).derivedField;\r\n  }\r\n}\r\n</pre>",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S1313",
      "title": "IP addresses should not be hardcoded",
      "tags": [
        "cert",
        "security"
      ],
      "implementations": [
        {
          "key": "S1313",
          "language": "C#",
          "title": "IP addresses should not be hardcoded",
          "description": "<p>\r\n    Hardcoding an IP address into source code is a bad idea for several reasons:\r\n    <ul>\r\n        <li>\r\n            a recompile is required if the address changes\r\n        </li>\r\n        <li>\r\n            it forces the same address to be used in every environment (dev, sys, qa, prod)\r\n        </li>\r\n        <li>\r\n            it places the responsibility of setting the value to use in production on the shoulders of the developer\r\n        </li>\r\n        <li>\r\n            it allows attackers to decompile the code and thereby discover a potentially sensitive address\r\n        </li>\r\n    </ul>\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvar ip = \"127.0.0.1\";\r\nvar address = IPAddress.Parse(ip);\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvar ip = ConfigurationManager.AppSettings[\"myapplication.ip\"];\r\nvar address = IPAddress.Parse(ip);\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    Although \"::\" is a valid IPv6 address, the rule doesn't report on it.\r\n</p>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li> <a href=\"https://www.securecoding.cert.org/confluence/x/qQCHAQ\">CERT, MSC03-J</a> - Never hard code sensitive information</li>\r\n</ul>",
          "severity": "Major",
          "tags": [
            "cert",
            "security"
          ]
        }
      ]
    },
    {
      "key": "S126",
      "title": "\"if ... else if\" constructs should end with \"else\" clause",
      "tags": [
        "cert",
        "misra"
      ],
      "implementations": [
        {
          "key": "S126",
          "language": "C#",
          "title": "\"if ... else if\" constructs should end with \"else\" clause",
          "description": "<p>\r\n  This rule applies whenever an <code>if</code> statement is followed by one or\r\n  more <code>else if</code> statements, the final <code>else if</code> should be\r\n  followed by an <code>else</code> statement.\r\n</p>\r\n\r\n<p>\r\nThe requirement for a final <code>else</code> statement is defensive programming.\r\nThe <code>else</code> statement should either take appropriate action or contain\r\na suitable comment as to why no action is taken. This is consistent with the\r\nrequirement to have a final <code>default</code> clause in a <code>switch</code>\r\nstatement.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif (x == 0)\r\n{\r\n  doSomething();\r\n} else if (x == 1)\r\n{\r\n  doSomethingElse();\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (x == 0)\r\n{\r\n  doSomething();\r\n} else if (x == 1)\r\n{\r\n  doSomethingElse();\r\n} else\r\n{\r\n  throw new IllegalStateException();\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li>MISRA C:2004, 14.10 - All if...else if constructs shall be terminated with an else clause.</li>\r\n    <li>MISRA C++:2008, 6-4-2 - All if...else if constructs shall be terminated with an else clause.</li>\r\n    <li>MISRA C:2012, 15.7 - All if...else if constructs shall be terminated with an else statement</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/YgE\">CERT, MSC01-C</a> - Strive for logical completeness</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/JoIyAQ\">CERT, MSC01-CPP</a> - Strive for logical completeness</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/PQHRAw\">CERT, MSC64-Java</a> - Strive for logical completeness</li>\r\n</ul>\r\n",
          "severity": "Major",
          "tags": [
            "cert",
            "misra"
          ]
        }
      ]
    },
    {
      "key": "S1066",
      "title": "Collapsible \"if\" statements should be merged",
      "tags": [
        "clumsy"
      ],
      "implementations": [
        {
          "key": "S1066",
          "language": "C#",
          "title": "Collapsible \"if\" statements should be merged",
          "description": "<p>\r\n    Merging collapsible <code>if</code> statements increases the code's readability.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif (condition1)\r\n{\r\n  if (condition2)\r\n  {\r\n    ...\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (condition1 &amp;&amp; condition2)\r\n{\r\n  ...\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "clumsy"
          ]
        }
      ]
    },
    {
      "key": "S1145",
      "title": "Useless \"if(true) {...}\" and \"if(false){...}\" blocks should be removed",
      "tags": [
        "bug",
        "cwe",
        "misra",
        "security"
      ],
      "implementations": [
        {
          "key": "S1145",
          "language": "C#",
          "title": "Useless \"if(true) {...}\" and \"if(false){...}\" blocks should be removed",
          "description": "<p>\r\n  <code>if</code> statements with conditions that are always false have the effect of making blocks of code non-functional. This can be useful during debugging, but should not be checked in. <code>if</code> statements with conditions that are always true are completely redundant, and make the code less readable.\r\n</p>\r\n<p>\r\nIn either case, unconditional <code>if</code> statements should be removed.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif (true)\r\n{\r\n  doSomething();\r\n}\r\n...\r\nif (false)\r\n{\r\n  doSomethingElse();\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\ndoSomething();\r\n...\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Remove useless \"if\" statement</li></ul>",
          "severity": "Major",
          "tags": [
            "bug",
            "cwe",
            "misra",
            "security"
          ]
        }
      ]
    },
    {
      "key": "S2692",
      "title": "\"IndexOf\" checks should not be for positive numbers",
      "tags": [
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S2692",
          "language": "C#",
          "title": "\"IndexOf\" checks should not be for positive numbers",
          "description": "<p>\r\n    Most checks against an <code>IndexOf</code> value compare it with -1 because 0 is a valid index. Any checks which look for\r\n    values <code>&gt;0</code> ignore the first element, which is likely a bug. If the intent is merely to check inclusion of a\r\n    value in a <code>string</code>, <code>List</code>, or an array, consider using the <code>Contains</code> method instead.\r\n</p>\r\n<p>\r\n    This rule raises an issue when an <code>IndexOf</code> value retrieved from a <code>string</code>, <code>List</code>,\r\n    or array is tested against <code>&gt;0</code>.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nstring color = \"blue\";\r\nstring name = \"ishmael\";\r\n\r\nList&lt;string&gt; strings = new List&lt;string&gt; ();\r\nstrings.add(color);\r\nstrings.add(name);\r\nstring[] stringArray = strings.ToArray();\r\n\r\nif (strings.IndexOf(color) &gt; 0) // Noncompliant\r\n{\r\n  // ...\r\n}\r\nif (name.IndexOf(\"ish\") &gt; 0) // Noncompliant\r\n{\r\n  // ...\r\n}\r\nif (name.IndexOf(\"ae\") &gt; 0) // Noncompliant\r\n{\r\n  // ...\r\n}\r\nif (Array.IndexOf(stringArray, color) &gt; 0) // Noncompliant\r\n{\r\n  // ...\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nstring color = \"blue\";\r\nstring name = \"ishmael\";\r\nList&lt;string&gt; strings = new List&lt;string&gt; ();\r\nstrings.add(color);\r\nstrings.add(name);\r\nstring[] stringArray = strings.ToArray();\r\nif (strings.IndexOf(color) &gt; -1)\r\n{\r\n  // ...\r\n}\r\nif (name.IndexOf(\"ish\") &gt;= 0)\r\n{\r\n  // ...\r\n}\r\nif (name.Contains(\"ae\")\r\n{\r\n  // ...\r\n}\r\nif (Array.IndexOf(stringArray, color) &gt;= 0)\r\n{\r\n  // ...\r\n}\r\n</pre>\r\n",
          "severity": "Critical",
          "tags": [
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S2190",
      "title": "Recursion should not be infinite",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S2190",
          "language": "C#",
          "title": "Recursion should not be infinite",
          "description": "<p>\r\n    Recursion happens when control enters a loop that has no exit. This can happen a method invokes itself, when a pair of methods\r\n    invoke each other, or when <code>goto</code>s are used to move between two segments of code. It can be a useful tool, but unless\r\n    the method includes a provision to break out of the recursion and return, the recursion will continue until the stack overflows\r\n    and the program crashes.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nint Pow(int num, int exponent) // Noncompliant; no condition under which pow isn't re-called\r\n{\r\n  num = num * Pow(num, exponent-1);\r\n  return num;  // this is never reached\r\n}\r\nvoid InternalRecursion(int i)\r\n{\r\n  start:\r\n    goto end;\r\n  end:\r\n    goto start; // Noncompliant; there's no way to break out of this method\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nint Pow(int num, int exponent)\r\n{\r\n  if (exponent > 1) // recursion now conditional and stop-able\r\n  {\r\n    num = num * Pow(num, exponent-1);\r\n  }\r\n  return num;\r\n}\r\n</pre>\r\n",
          "severity": "Blocker",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S3444",
      "title": "Interfaces with colliding, inherited members should explicitly redefine interface members",
      "tags": [
        "design"
      ],
      "implementations": [
        {
          "key": "S3444",
          "language": "C#",
          "title": "Interfaces with colliding, inherited members should explicitly redefine interface members",
          "description": "<p>\r\n    When an interface <code>IDerived</code> inherits from two interfaces <code>IBase1</code> and <code>IBase2</code> that both \r\n    define a member <code>SomeProperty</code>, calling <code>IDerived.SomeProperty</code> will result in the compiler error \r\n    <code>CS0229 Ambiguity between 'IBase1.SomeProperty' and 'IBase2.SomeProperty'</code>.\r\n</p>\r\n<p>\r\n    Every caller will be forced to cast instances of <code>IDerived</code> to <code>IBase1</code> or <code>IBase2</code> to \r\n    resolve the ambiguity and to be able to access <code>SomeProperty</code>. Instead, it is better to resolve the ambiguity on \r\n    the definition of <code>IDerived</code> either by:\r\n    <ul>\r\n        <li>renaming one of the <code>SomeProperty</code> in <code>IBase1</code> or <code>IBase2</code> to remove the collision</li>\r\n        <li>or by also defining a new <code>SomeProperty</code> member on <code>IDerived</code>. Use this only if all \r\n        <code>SomeProperty</code> are meant to hold the same value.</li>\r\n    </ul>\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic interface IBase1\r\n{\r\n  string SomeProperty { get; set; }\r\n}\r\n\r\npublic interface IBase2\r\n{\r\n  string SomeProperty { get; set; }\r\n}\r\n\r\npublic interface IDerived : IBase1, IBase2 // Noncompliant, accessing IDerived.SomeProperty is ambiguous\r\n{\r\n}\r\n\r\npublic class MyClass : IDerived\r\n{\r\n  // Implements both IBase1.SomeProperty and IBase2.SomeProperty\r\n  public string SomeProperty { get; set; } = \"Hello\";\r\n\r\n  public static void Main()\r\n  {\r\n    MyClass myClass = new MyClass();\r\n    Console.WriteLine(myClass.SomeProperty); // Writes \"Hello\" as expected\r\n    Console.WriteLine(((IBase1)myClass).SomeProperty); // Writes \"Hello\" as expected\r\n    Console.WriteLine(((IBase2)myClass).SomeProperty); // Writes \"Hello\" as expected\r\n    Console.WriteLine(((IDerived)myClass).SomeProperty); // Error CS0229 Ambiguity between 'IBase1.SomeProperty' and 'IBase2.SomeProperty'\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic interface IDerived : IBase1, IBase2\r\n{\r\n  new string SomeProperty { get; set; }\r\n}\r\n\r\npublic class MyClass : IDerived\r\n{\r\n  // Implements IBase1.SomeProperty, IBase2.SomeProperty and IDerived.SomeProperty\r\n  public string SomeProperty { get; set; } = \"Hello\";\r\n\r\n  public static void Main()\r\n  {\r\n    MyClass myClass = new MyClass();\r\n    Console.WriteLine(myClass.SomeProperty); // Writes \"Hello\" as expected\r\n    Console.WriteLine(((IBase1)myClass).SomeProperty); // Writes \"Hello\" as expected\r\n    Console.WriteLine(((IBase2)myClass).SomeProperty); // Writes \"Hello\" as expected\r\n    Console.WriteLine(((IDerived)myClass).SomeProperty); // Writes \"Hello\" as expected\r\n  }\r\n}\r\n</pre>\r\n<p>or</p>\r\n<pre>\r\npublic interface IBase1\r\n{\r\n  string SomePropertyOne { get; set; }\r\n}\r\n\r\npublic interface IBase2\r\n{\r\n  string SomePropertyTwo { get; set; }\r\n}\r\n\r\npublic interface IDerived : IBase1, IBase2\r\n{\r\n}\r\n</pre>",
          "severity": "Major",
          "tags": [
            "design"
          ]
        }
      ]
    },
    {
      "key": "S2278",
      "title": "Neither DES (Data Encryption Standard) nor DESede (3DES) should be used",
      "tags": [
        "cwe",
        "owasp-a6",
        "security"
      ],
      "implementations": [
        {
          "key": "S2278",
          "language": "C#",
          "title": "Neither DES (Data Encryption Standard) nor DESede (3DES) should be used",
          "description": "<p>\r\n    According to the US National Institute of Standards and Technology (NIST), the Data Encryption Standard (DES) is no longer\r\n    considered secure:\r\n</p>\r\n<blockquote>\r\n    <p>\r\n        Adopted in 1977 for federal agencies to use in protecting sensitive, unclassified information, the DES is being withdrawn\r\n        because it no longer provides the security that is needed to protect federal government information.\r\n    </p>\r\n    <p>\r\n        Federal agencies are encouraged to use the Advanced Encryption Standard, a faster and stronger algorithm approved as FIPS\r\n        197 in 2001.\r\n    </p>\r\n</blockquote>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nusing (var tripleDES = new TripleDESCryptoServiceProvider()) //Noncompliant\r\n{\r\n  //...\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nusing (var aes = new AesCryptoServiceProvider())\r\n{\r\n  //...\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li><a href=\"http://cwe.mitre.org/data/definitions/326.html\">MITRE CWE-326</a> - Inadequate Encryption Strength</li>\r\n    <li><a href=\"http://cwe.mitre.org/data/definitions/327.html\">MITRE CWE-327</a> - Use of a Broken or Risky Cryptographic Algorithm</li>\r\n    <li><a href=\"https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure\">OWASP Top Ten 2013 Category A6</a> - Sensitive Data Exposure</li>\r\n    <li>Derived from FindSecBugs rule <a href=\"http://h3xstream.github.io/find-sec-bugs/bugs.htm#DES_USAGE\">DES / DESede Unsafe</a></li>\r\n</ul>",
          "severity": "Critical",
          "tags": [
            "cwe",
            "owasp-a6",
            "security"
          ]
        }
      ]
    },
    {
      "key": "S2070",
      "title": "SHA-1 and Message-Digest hash algorithms should not be used",
      "tags": [
        "cwe",
        "owasp-a6",
        "sans-top25-porous",
        "security"
      ],
      "implementations": [
        {
          "key": "S2070",
          "language": "C#",
          "title": "SHA-1 and Message-Digest hash algorithms should not be used",
          "description": "<p>\r\n    The MD5 algorithm and its successor, SHA-1, are no longer considered secure, because it is too easy to\r\n    create hash collisions with them. That is, it takes too little computational effort to come up with a\r\n    different input that produces the same MD5 or SHA-1 hash, and using the new, same-hash value gives an\r\n    attacker the same access as if he had the originally-hashed value. This applies as well to the other\r\n    Message-Digest algorithms: MD2, MD4, MD6.\r\n</p>\r\n\r\n<p>\r\n    This rule tracks usage of the <code>System.Security.Cryptography.CryptoConfig.CreateFromName()</code>, and <code>System.Security.Cryptography.HashAlgorithm.Create()</code> methods to instantiate MD5 or SHA-1 algorithms, and of derived class instances of <code>System.Security.Cryptography.SHA1</code> and <code>System.Security.Cryptography.MD5</code>.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvar hashProvider1 = new MD5CryptoServiceProvider(); //Noncompliant\r\nvar hashProvider2 = (HashAlgorithm)CryptoConfig.CreateFromName(\"MD5\"); //Noncompliant\r\nvar hashProvider3 = new SHA1Managed(); //Noncompliant\r\nvar hashProvider4 = HashAlgorithm.Create(\"SHA1\"); //Noncompliant\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvar hashProvider1 = new SHA256Managed();\r\nvar hashProvider2 = (HashAlgorithm)CryptoConfig.CreateFromName(\"SHA256Managed\");\r\nvar hashProvider3 = HashAlgorithm.Create(\"SHA256Managed\");\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li> <a href=\"http://cwe.mitre.org/data/definitions/328\">MITRE, CWE-328</a> - Reversible One-Way Hash</li>\r\n    <li> <a href=\"http://cwe.mitre.org/data/definitions/327\">MITRE, CWE-327</a> - Use of a Broken or Risky Cryptographic Algorithm</li>\r\n    <li> <a href=\"https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure\">OWASP Top Ten 2013 Category A6</a> - Sensitive Data Exposure</li>\r\n    <li> <a href=\"http://www.sans.org/top25-software-errors/\">SANS Top 25</a> - Porous Defenses</li>\r\n    <li>Derived from FindSecBugs rule <a href=\"http://h3xstream.github.io/find-sec-bugs/bugs.htm#WEAK_MESSAGE_DIGEST\">MessageDigest Is Weak</a></li>\r\n</ul>",
          "severity": "Critical",
          "tags": [
            "cwe",
            "owasp-a6",
            "sans-top25-porous",
            "security"
          ]
        }
      ]
    },
    {
      "key": "S1944",
      "title": "Inappropriate casts should not be made",
      "tags": [
        "bug",
        "cert",
        "cwe",
        "misra",
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S1944",
          "language": "C#",
          "title": "Inappropriate casts should not be made",
          "description": "<p>\r\n    Inappropriate casts are issues that will lead to unexpected behavior or runtime errors, such as\r\n    <code>InvalidCastException</code>s. The compiler will catch bad casts from one class to another, but not bad casts to\r\n    interfaces. Also, nullable values that are known to be empty can't be cast to their underlying value type.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic interface MyInterface\r\n{ /* ... */ }\r\n\r\npublic class Implementer : MyInterface\r\n{ /* ... */ }\r\n\r\npublic class MyClass\r\n{ /* ... */ }\r\n\r\npublic static class Program\r\n{\r\n  public static void Main()\r\n  {\r\n    var myclass = new MyClass();\r\n    var x = (MyInterface) myclass; // Noncompliant, InvalidCastException is being thrown\r\n    var b = myclass is MyInterface; // Noncompliant, always false\r\n\r\n    int? i = null;\r\n    var ii = (int)i; // Noncompliant, InvalidOperationException is being thrown\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    No issue is reported if the interface has no implementing class in the assembly.\r\n</p>\r\n\r\n<h2>See</h2>\r\n<ul>\r\n    <li>MISRA C:2004, 11.4 - A cast should not be performed between a pointer to object type and an integral type.</li>\r\n    <li>MISRA C++:2008, 5-2-3 - Casts to a base class from a derived class should not be performed on polymorphic types.</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/tgAV\">CERT, EXP36-C.</a> - Do not cast pointers into more strictly aligned pointer types</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/j4AyAQ\">CERT, EXP56-CPP.</a> - Do not cast pointers into more strictly aligned pointer types</li>\r\n    <li><a href=\"http://cwe.mitre.org/data/definitions/588.html\">MITRE, CWE-588</a> - Attempt to Access Child of a Non-structure Pointer</li>\r\n    <li><a href=\"http://cwe.mitre.org/data/definitions/704.html\">MITRE, CWE-704</a> - Incorrect Type Conversion or Cast</li>\r\n</ul>\r\n",
          "severity": "Critical",
          "tags": [
            "bug",
            "cert",
            "cwe",
            "misra",
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S3220",
      "title": "Method calls should not resolve ambiguously to overloads with \"params\"",
      "tags": [
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S3220",
          "language": "C#",
          "title": "Method calls should not resolve ambiguously to overloads with \"params\"",
          "description": "<p>\r\n    The rules for method resolution are complex and perhaps not properly understood by all coders. The <code>params</code> keyword can make\r\n    method declarations overlap in non-obvious ways, so that slight changes in the argument types of an invocation can resolve to different\r\n    methods.\r\n</p>\r\n<p>\r\n    This rule raises an issue when an invocation resolves to a method declaration with <code>params</code>, but could also resolve to another\r\n    non-<code>params</code> method too.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class MyClass\r\n{\r\n  private void Format(string a, params object[] b) { }\r\n\r\n  private void Format(object a, object b, object c) { }\r\n}\r\n\r\n// ...\r\nMyClass myClass = new MyClass();\r\n\r\nmyClass.Format(\"\", null, null); //Noncompliant, resolves to the first Format with params, but was that intended?\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S103",
      "title": "Lines should not be too long",
      "tags": [
        "convention"
      ],
      "implementations": [
        {
          "key": "S103",
          "language": "C#",
          "title": "Lines should not be too long",
          "description": "<h2 class=\"param-header\">Parameters</h2><dl><dt class=\"param-key\">maximumLineLength</dt><dd><span class=\"param-description\">The maximum authorized line length.</span><span class=\"param-type\">INTEGER</span><span class=\"param-default\">200</span></dd></dl><p>\r\nHaving to scroll horizontally makes it harder to get a quick overview and understanding of any piece of code.\r\n</p>\r\n",
          "severity": "Minor",
          "tags": [
            "convention"
          ]
        }
      ]
    },
    {
      "key": "S818",
      "title": "Literal suffixes should be upper case",
      "tags": [
        "cert",
        "convention",
        "misra",
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S818",
          "language": "C#",
          "title": "Literal suffixes should be upper case",
          "description": "<p>\r\n    Using upper case literal suffixes removes the potential ambiguity between \"1\" (digit 1) and \"l\" (letter el) for declaring literals.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nconst long b = 0l;      // Noncompliant\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nconst long b = 0L;\r\n</pre>\r\n\r\n<h2>See</h2>\r\n<ul>\r\n    <li>MISRA C++:2008, 2-13-4 - Literal suffixes shall be upper case</li>\r\n    <li>MISRA C:2012, 7.3 - The lowercase character \"l\" shall not be used in a literal suffix</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/koAtAQ\">CERT DCL16-C</a> - Use \"L,\" not \"l,\" to indicate a long value</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/n4AtAQ\">CERT DCL16-CPP</a> - Use \"L,\" not \"l,\" to indicate a long value</li>\r\n</ul>\r\n<h2>Code Fixes</h2><ul><li>Make literal suffix upper case</li></ul>",
          "severity": "Minor",
          "tags": [
            "cert",
            "convention",
            "misra",
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S2551",
      "title": "Types and \"this\" should not be used for locking",
      "tags": [
        "bug",
        "multi-threading"
      ],
      "implementations": [
        {
          "key": "S2551",
          "language": "C#",
          "title": "Types and \"this\" should not be used for locking",
          "description": "<p>\r\n    Locking on the current object instance (i.e. <code>this</code>), or on a <code>Type</code> object increases the chance\r\n    of deadlocks because any other thread could acquire (or attempt to acquire) the same lock for another unrelated purpose.\r\n</p>\r\n<p>\r\n    Instead, a new, private <code>object</code> should be created and used for the lock.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic void MyLockingMethod()\r\n{\r\n  lock (this) // Noncompliant\r\n  {\r\n    // ...\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nobject lockObj = new object();\r\n\r\npublic void MyLockingMethod()\r\n{\r\n  lock (lockObj)\r\n  {\r\n    // ...\r\n  }\r\n}\r\n</pre>\r\n",
          "severity": "Critical",
          "tags": [
            "bug",
            "multi-threading"
          ]
        }
      ]
    },
    {
      "key": "S2184",
      "title": "Result of integer division should not be assigned to floating point variable",
      "tags": [
        "bug",
        "cwe",
        "sans-top25-risky",
        "security"
      ],
      "implementations": [
        {
          "key": "S2184",
          "language": "C#",
          "title": "Result of integer division should not be assigned to floating point variable",
          "description": "<p>\r\n    When division is performed on <code>int</code>s, the result will always be an <code>int</code>. You can assign that result to a\r\n    <code>double</code>, <code>float</code> or <code>decimal</code> with automatic type conversion, but having started as an\r\n    <code>int</code>, the result will likely not be what you expect. If the result of <code>int</code> division is assigned to a\r\n    floating-point variable, precision will have been lost before the assignment. Instead, at least one operand should be cast or\r\n    promoted to the final type before the operation takes place.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nstatic void Main()\r\n{\r\n  decimal dec = 3/2; // Noncompliant\r\n  Method(3/2); // Noncompliant\r\n}\r\nstatic void Method(float f) { }\r\n</pre>\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nstatic void Main()\r\n{\r\n  decimal dec = (decimal)3/2;\r\n  Method(3.0F/2);\r\n}\r\nstatic void Method(float f) { }\r\n</pre>\r\n",
          "severity": "Critical",
          "tags": [
            "bug",
            "cwe",
            "sans-top25-risky",
            "security"
          ]
        }
      ]
    },
    {
      "key": "S3052",
      "title": "Members should not be initialized to default values",
      "tags": [
        "finding"
      ],
      "implementations": [
        {
          "key": "S3052",
          "language": "C#",
          "title": "Members should not be initialized to default values",
          "description": "<p>\r\n    The compiler automatically initializes class fields, auto-properties and events to their default values before setting them with any\r\n    initialization values, so there is no need to explicitly set a member to its default value. Further, under the logic that cleaner\r\n    code is better code, it's considered poor style to do so.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass X\r\n{\r\n  public int field = 0; // Noncompliant\r\n  public object o = null; // Noncompliant\r\n  public object MyProperty { get; set; } = null; // Noncompliant\r\n  public event EventHandler MyEvent = null;  // Noncompliant\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nclass X\r\n{\r\n  public int field;\r\n  public object o;\r\n  public object MyProperty { get; set; }\r\n  public event EventHandler MyEvent;\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<code>const</code> fields are ignored.\r\n<h2>Code Fixes</h2><ul><li>Remove redundant initializer</li></ul>",
          "severity": "Minor",
          "tags": [
            "finding"
          ]
        }
      ]
    },
    {
      "key": "S3604",
      "title": "Member initializer values should not be redundant",
      "tags": [
        "finding"
      ],
      "implementations": [
        {
          "key": "S3604",
          "language": "C#",
          "title": "Member initializer values should not be redundant",
          "description": "<p>\r\n    Fields, properties and events can be initialized either inline or in the constructor. Initializing them inline and in the constructor at the\r\n    same time is redundant; the inline initialization will be overridden.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass Person\r\n{\r\n  int age = 42; // Noncompliant\r\n  public Person(int age)\r\n  {\r\n    this.age = age;\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nclass Person\r\n{\r\n  int age;\r\n  public Person(int age)\r\n  {\r\n    this.age = age;\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    This rule doesn't report an issue if not all constructors initialize the field. If the field is initialized inline to its default value, then\r\n    <a class=\"rule-link\" href=\"#version=1.17.0&ruleId=S3052\">Rule S3052</a> already reports an issue on the initialization.\r\n</p>\r\n",
          "severity": "Minor",
          "tags": [
            "finding"
          ]
        }
      ]
    },
    {
      "key": "S1185",
      "title": "Overriding members should do more than simply call the same member in the super class",
      "tags": [
        "clumsy"
      ],
      "implementations": [
        {
          "key": "S1185",
          "language": "C#",
          "title": "Overriding members should do more than simply call the same member in the super class",
          "description": "<p>\r\n    Overriding a member just to call the same member from the base class without performing any other actions is useless and\r\n    misleading. The only time this is justified is in <code>sealed</code> overriding methods, where the effect is to lock in\r\n    the parent class behavior.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic override void Method() // Noncompliant\r\n{\r\n  base.Method();\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic override void Method()\r\n{\r\n  //do something else\r\n}\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Remove redundant override</li></ul>",
          "severity": "Minor",
          "tags": [
            "clumsy"
          ]
        }
      ]
    },
    {
      "key": "S3218",
      "title": "Inner class members should not shadow outer class \"static\" or type members",
      "tags": [
        "design",
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S3218",
          "language": "C#",
          "title": "Inner class members should not shadow outer class \"static\" or type members",
          "description": "<p>\r\n    It's possible to name the members of an inner class the same as the <code>static</code> members of its enclosing class -\r\n    possible, but a bad idea. That's because maintainers may be confused about which members are being used where. Instead the\r\n    inner class' members should be renamed and all the references updated.\r\n</p>\r\n\r\n<h2>Noncompliant Code Sample</h2>\r\n<pre>\r\nclass Outer\r\n{\r\n  public static int A;\r\n\r\n  public class Inner\r\n  {\r\n    public int A; //Noncompliant\r\n    public int MyProp\r\n    {\r\n      get { return A; }  // Returns inner A. Was that intended?\r\n    }\r\n  }\r\n}\r\n</pre>\r\nAfter a rename\r\n<pre>\r\nclass Outer\r\n{\r\n  public static int A;\r\n\r\n  public class Inner\r\n  {\r\n    public int B;\r\n    public int MyProp\r\n    {\r\n      get { return A; }  // Still compiles and runs but functionality has changed\r\n    }\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nclass Outer\r\n{\r\n  public static int A;\r\n\r\n  public class Inner\r\n  {\r\n    public int InnerA;\r\n    public int MyProp\r\n    {\r\n      get { return InnerA; }\r\n    }\r\n  }\r\n}\r\n</pre>",
          "severity": "Major",
          "tags": [
            "design",
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S100",
      "title": "Methods and properties should be named in camel case",
      "tags": [
        "convention"
      ],
      "implementations": [
        {
          "key": "S100",
          "language": "C#",
          "title": "Methods and properties should be named in camel case",
          "description": "<p>\r\n    Shared naming conventions allow teams to collaborate efficiently. This rule checks whether or not method and property names are camel cased.\r\n    To reduce noise, two consecutive upper case characters are allowed unless they form the whole name. So, <code>MyXMethod</code> is compliant,\r\n    but <code>XM</code> on its own is not.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic int doSomething(){...}\r\n</pre>\r\n\r\n<p>should be refactored into:</p>\r\n\r\n<pre>\r\npublic int DoSomething(){...}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    The rule ignores members in types that are marked with <code>ComImportAttribute</code> or <code>InterfaceTypeAttribute</code>.\r\n    <code>extern</code> methods are also excluded from the check. Furthermore, when <code>'_'</code> character is found in a name,\r\n    the camel casing is not enforced.\r\n</p>\r\n<pre>\r\nvoid My_method(){...}   // valid\r\nvoid My_method_(){...}  // invalid, leading and trailing underscores are reported\r\n</pre>\r\n",
          "severity": "Minor",
          "tags": [
            "convention"
          ]
        }
      ]
    },
    {
      "key": "S3427",
      "title": "Method overloads with default parameter values should not overlap",
      "tags": [
        "pitfall",
        "unused"
      ],
      "implementations": [
        {
          "key": "S3427",
          "language": "C#",
          "title": "Method overloads with default parameter values should not overlap",
          "description": "<p>\r\n    The rules for method resolution are complex and perhaps not properly understood by all coders. Having overloads with\r\n    optional parameter values make the matter even harder to understand. An overload with default parameter values can be\r\n    hidden by one without the optional parameters.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class MyClass\r\n{\r\n  void Print(string[] messages) {...}\r\n  void Print(string[] messages, string delimiter = \"\\n\") {...} // Noncompliant; default parameter value is hidden by overload\r\n}\r\n\r\n// ...\r\nMyClass myClass = new MyClass();\r\n\r\nmyClass.Print(new string[3] {\"yes\", \"no\", \"maybe\"});  // which version of Print will be called?\r\n</pre>",
          "severity": "Major",
          "tags": [
            "pitfall",
            "unused"
          ]
        }
      ]
    },
    {
      "key": "S3600",
      "title": "\"params\" should not be introduced on overrides",
      "tags": [
        "confusing"
      ],
      "implementations": [
        {
          "key": "S3600",
          "language": "C#",
          "title": "\"params\" should not be introduced on overrides",
          "description": "<p>\r\n    Adding <code>params</code> to a method override has no effect. The compiler accepts it, but the callers won't be able\r\n    to benefit from the added modifier.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass Base\r\n{\r\n  public virtual void Method(int[] numbers)\r\n  {\r\n    ...\r\n  }\r\n}\r\nclass Derived : Base\r\n{\r\n  public override void Method(params int[] numbers) // Noncompliant, method can't be called with params syntax.\r\n  {\r\n    ...\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nclass Base\r\n{\r\n  public virtual void Method(int[] numbers)\r\n  {\r\n    ...\r\n  }\r\n}\r\nclass Derived : Base\r\n{\r\n  public override void Method(int[] numbers)\r\n  {\r\n    ...\r\n  }\r\n}\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Remove the \"params\" modifier</li></ul>",
          "severity": "Major",
          "tags": [
            "confusing"
          ]
        }
      ]
    },
    {
      "key": "S1006",
      "title": "Method overrides should not change parameter defaults",
      "tags": [
        "cert",
        "misra",
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S1006",
          "language": "C#",
          "title": "Method overrides should not change parameter defaults",
          "description": "<p>\r\n    Default arguments are determined by the static type of the object. If a default argument is different for a parameter in an\r\n    overriding method, the value used in the call will be different when calls are made via the base or derived object, which may\r\n    be contrary to developer expectations.\r\n</p>\r\n<p>\r\n    Default parameter values are useless in explicit interface implementations, because the static type of the object will always\r\n    be the implemented interface. Thus, specifying the default values is useless and confusing.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class Base\r\n{\r\n  public virtual void Write(int i = 42)\r\n  {\r\n    Console.WriteLine(i);\r\n  }\r\n}\r\n\r\npublic class Derived : Base\r\n{\r\n  public override void Write(int i = 5) // Noncompliant\r\n  {\r\n    Console.WriteLine(i);\r\n  }\r\n}\r\n\r\npublic class Program\r\n{\r\n  public static void Main()\r\n  {\r\n    var derived = new Derived();\r\n    derived.Write(); // writes 5\r\n    Print(derived);  // writes 42; was that expected?\r\n  }\r\n  private void Print(Base item)\r\n  {\r\n    item.Write();\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\npublic class Base\r\n{\r\n  public virtual void Write(int i = 42)\r\n  {\r\n    Console.WriteLine(i);\r\n  }\r\n}\r\n\r\npublic class Derived : Base\r\n{\r\n  public override void Write(int i = 42)\r\n  {\r\n    Console.WriteLine(i);\r\n  }\r\n}\r\n\r\npublic class Program\r\n{\r\n  public static void Main()\r\n  {\r\n    var derived = new Derived();\r\n    derived.Write(); // writes 42\r\n    Print(derived);  // writes 42\r\n  }\r\n  private void Print(Base item)\r\n  {\r\n    item.Write();\r\n  }\r\n}\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Synchronize default parameter value</li><li>Remove default parameter value from explicit interface implementation</li></ul>",
          "severity": "Major",
          "tags": [
            "cert",
            "misra",
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S3262",
      "title": "\"params\" should be used on overrides",
      "tags": [
        "confusing"
      ],
      "implementations": [
        {
          "key": "S3262",
          "language": "C#",
          "title": "\"params\" should be used on overrides",
          "description": "<p>\r\n    Overriding methods automatically inherit the <code>params</code> behavior. To ease readability, this modifier should be explicitly used in\r\n    the overriding method as well.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass Base\r\n{\r\n  public virtual void Method(params int[] numbers)\r\n  {\r\n    ...\r\n  }\r\n}\r\nclass Derived : Base\r\n{\r\n  public override void Method(int[] numbers) // Noncompliant, the params is missing.\r\n  {\r\n    ...\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nclass Base\r\n{\r\n  public virtual void Method(params int[] numbers)\r\n  {\r\n    ...\r\n  }\r\n}\r\nclass Derived : Base\r\n{\r\n  public override void Method(params int[] numbers)\r\n  {\r\n    ...\r\n  }\r\n}\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Add the \"params\" modifier</li></ul>",
          "severity": "Minor",
          "tags": [
            "confusing"
          ]
        }
      ]
    },
    {
      "key": "S3450",
      "title": "Parameters with \"[DefaultParameterValue]\" attributes should also be marked with \"[Optional]\"",
      "tags": [
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S3450",
          "language": "C#",
          "title": "Parameters with \"[DefaultParameterValue]\" attributes should also be marked with \"[Optional]\"",
          "description": "<p>\r\n    There is no point in providing a default value for a parameter if callers are required to provide a value for it anyway. Thus,\r\n    <code>[DefaultParameterValue]</code> should always be used in conjunction with <code>[Optional]</code>.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic void MyMethod([DefaultParameterValue(5)] int j) //Noncompliant, useless\r\n{\r\n  Console.WriteLine(j);\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic void MyMethod(int j = 5)\r\n{\r\n  Console.WriteLine(j);\r\n}\r\n</pre>\r\n<p>or</p>\r\n<pre>\r\npublic void MyMethod([DefaultParameterValue(5)][Optional] int j)\r\n{\r\n  Console.WriteLine(j);\r\n}\r\n</pre><h2>Code Fixes</h2><ul><li>Add missing \"Optional\" attribute</li></ul>",
          "severity": "Major",
          "tags": [
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S1172",
      "title": "Unused method parameters should be removed",
      "tags": [
        "misra",
        "unused"
      ],
      "implementations": [
        {
          "key": "S1172",
          "language": "C#",
          "title": "Unused method parameters should be removed",
          "description": "<p>\r\n    Unused parameters are misleading. Whatever the value passed to such parameters is, the behavior will be the same.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvoid DoSomething(int a, int b) // \"b\" is unused\r\n{\r\n  Compute(a);\r\n}\r\n\r\nvoid DoSomething2(int a) // value of \"a\" is unused\r\n{\r\n  a = 10;\r\n  Compute(a);\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvoid DoSomething(int a)\r\n{\r\n  Compute(a);\r\n}\r\n\r\nvoid DoSomething2()\r\n{\r\n  var a = 10;\r\n  Compute(a);\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    <code>virtual</code>, <code>override</code> methods and interface implementations are ignored.\r\n</p>\r\n<pre>\r\noverride void DoSomething(int a, int b) // no issue reported on b\r\n{\r\n  Compute(a);\r\n}\r\n</pre>\r\n\r\n<p>\r\n    Furthermore, the <code>this</code> parameter of extension methods is also ignored.\r\n</p>\r\n<pre>\r\npublic static class Extensions\r\n{\r\n  public static void MyHelper(this HtmlHelper helper) //no issue reported here\r\n  {\r\n    // no use of helper here\r\n  }\r\n}\r\n</pre>\r\n\r\n<p>\r\n    Methods that have attributes defined on them are also ignored.\r\n</p>\r\n<pre>\r\npublic class MyDto\r\n{\r\n  public string Name { get; set; }\r\n\r\n  [OnDeserialized]\r\n  private void OnDeserialized(StreamingContext context)\r\n  {\r\n    // ...\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li>MISRA C++:2008, 0-1-11</li>\r\n    <li>MISRA C:2012, 2.7</li>\r\n</ul>\r\n<h2>Code Fixes</h2><ul><li>Remove unused parameter</li></ul>",
          "severity": "Major",
          "tags": [
            "misra",
            "unused"
          ]
        }
      ]
    },
    {
      "key": "S2681",
      "title": "Multiline blocks should be enclosed in curly braces",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S2681",
          "language": "C#",
          "title": "Multiline blocks should be enclosed in curly braces",
          "description": "<p>\r\nCurly braces can be omitted from a one-line block, such as with an <code>if</code> statement or <code>for</code> loop, but doing so can be misleading and induce bugs.\r\nThis rule raises an issue when the indentation of the lines after a one-line block indicates an intent to include those lines in the block, but the omission of curly braces means the lines will be unconditionally executed once.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif (condition)\r\n  firstActionInBlock();\r\n  secondAction();  // Noncompliant; executed unconditionally\r\nthirdAction();\r\n\r\nstring str = null;\r\nfor (int i = 0; i < array.length; i++)\r\n  str = array[i];\r\n  doTheThing(str);  // Noncompliant; executed only on last array element\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (condition)\r\n{\r\n  firstActionInBlock();\r\n  secondAction();\r\n}\r\nthirdAction();\r\n\r\nstring str = null;\r\nfor (int i = 0; i < array.length; i++)\r\n{\r\n  str = array[i];\r\n  doTheThing(str);\r\n}\r\n</pre>\r\n",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S1659",
      "title": "Multiple variables should not be declared on the same line",
      "tags": [
        "convention"
      ],
      "implementations": [
        {
          "key": "S1659",
          "language": "C#",
          "title": "Multiple variables should not be declared on the same line",
          "description": "<p>\r\n    Declaring multiple variable on one line is difficult to read.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass MyClass\r\n{\r\n  private int a, b; // Noncompliant\r\n\r\n  public void Method()\r\n  {\r\n    int c, d; // Noncompliant\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nclass MyClass\r\n{\r\n  private int a;\r\n  private int b;\r\n\r\n  public void Method()\r\n  {\r\n    int c;\r\n    int d;\r\n  }\r\n}\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Separate declarations</li></ul>",
          "severity": "Minor",
          "tags": [
            "convention"
          ]
        },
        {
          "key": "S1659",
          "language": "VB.NET",
          "title": "Multiple variables should not be declared on the same line",
          "description": "<p>\r\n    Declaring multiple variable on one line is difficult to read.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nModule Module1\r\n  Public Const AAA As Integer = 5, BBB = 42, CCC As String = \"foo\"  ' Noncompliant\r\nEnd Module\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nModule Module1\r\n  Public Const AAA As Integer = 5\r\n  Public Const BBB = 42\r\n  Public Const CCC as String = \"foo\"\r\nEnd Module\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Separate declarations</li></ul>",
          "severity": "Minor",
          "tags": [
            "convention"
          ]
        }
      ]
    },
    {
      "key": "S3265",
      "title": "Non-flags enums should not be used in bitwise operations",
      "tags": [
        "convention"
      ],
      "implementations": [
        {
          "key": "S3265",
          "language": "C#",
          "title": "Non-flags enums should not be used in bitwise operations",
          "description": "<p>\r\n    <code>enum</code>s are usually used to identify distinct elements in a set of values. However <code>enum</code>s can be treated as bit fields and \r\n    bitwise operations can be used on them to combine the values. This is a good way of specifying multiple elements of set with a single value. \r\n    When <code>enum</code>s are used this way, it is a best practice to mark the <code>enum</code> with the <code>FlagsAttribute</code>.\r\n</p>\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nenum Permissions\r\n{\r\n  None = 0,\r\n  Read = 1,\r\n  Write = 2,\r\n  Execute = 4\r\n}\r\n// ...\r\nvar x = Permissions.Read | Permissions.Write;  // Noncompliant; enum is not marked with [Flags]\r\n</pre>\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\n[Flags]\r\nenum Permissions\r\n{\r\n  None = 0,\r\n  Read = 1,\r\n  Write = 2,\r\n  Execute = 4\r\n}\r\n// ...\r\nvar x = Permissions.Read | Permissions.Write;\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Add [Flags] to enum declaration</li></ul>",
          "severity": "Minor",
          "tags": [
            "convention"
          ]
        }
      ]
    },
    {
      "key": "S3459",
      "title": "Unassigned members should be removed",
      "tags": [
        "confusing"
      ],
      "implementations": [
        {
          "key": "S3459",
          "language": "C#",
          "title": "Unassigned members should be removed",
          "description": "<p>\r\n    Fields and auto-properties that are never assigned to hold the default values for their types. They are either pointless code or, more likely,\r\n    mistakes.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass MyClass\r\n{\r\n  private int field; // Noncompliant, shouldn't it be initialized? This way the value is always default(int), 0.\r\n  private int Property { get; set; }  // Noncompliant\r\n  public void Print()\r\n  {\r\n    Console.WriteLine(field); //Will always print 0\r\n    Console.WriteLine(Property); //Will always print 0\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nclass MyClass\r\n{\r\n  private int field;\r\n  private int Property { get; set; } = 42;\r\n  public void Print()\r\n  {\r\n    field++;\r\n    Console.WriteLine(field);\r\n    Console.WriteLine(Property);\r\n  }\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "confusing"
          ]
        }
      ]
    },
    {
      "key": "S2259",
      "title": "Null pointers should not be dereferenced",
      "tags": [
        "bug",
        "cert",
        "cwe",
        "owasp-a1",
        "owasp-a2",
        "owasp-a6",
        "security"
      ],
      "implementations": [
        {
          "key": "S2259",
          "language": "C#",
          "title": "Null pointers should not be dereferenced",
          "description": "<p>\r\n    A reference to <code>null</code> should never be dereferenced/accessed. Doing so will cause a <code>NullReferenceException</code> to\r\n    be thrown. At best, such an exception will cause abrupt program termination. At worst, it could expose debugging information that would\r\n    be useful to an attacker, or it could allow an attacker to bypass security measures.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nobject o = null;\r\nif (condition)\r\n{\r\n  M1(o.ToString()); // Noncompliant, always null\r\n}\r\nelse\r\n{\r\n  o = new object();\r\n}\r\nM2(o.ToString());\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    Calls to extension methods are not reported as those can still operate on a <code>null</code> value.\r\n</p>\r\n\r\n<h2>See</h2>\r\n<ul>\r\n    <li><a href=\"http://cwe.mitre.org/data/definitions/476.html\">MITRE, CWE-476</a> - NULL Pointer Dereference</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/PAw\">CERT, EXP34-C.</a> - Do not dereference null pointers</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/ZwDOAQ\">CERT, EXP01-J.</a> - Do not use a null in a case where an object is required</li>\r\n    <li><a href=\"https://www.owasp.org/index.php/Top_10_2013-A1-Injection\">OWASP Top Ten 2013 Category A1</a> - Injection</li>\r\n    <li><a href=\"https://www.owasp.org/index.php/Top_10_2013-A2-Broken_Authentication_and_Session_Management\">OWASP Top Ten 2013 Category A2</a> - Broken Authentication and Session Management</li>\r\n    <li><a href=\"https://www.owasp.org/index.php/Top_10_2013-A6-Sensitive_Data_Exposure\">OWASP Top Ten 2013 Category A6</a> - Sensitive Data Exposure</li>\r\n</ul>",
          "severity": "Blocker",
          "tags": [
            "bug",
            "cert",
            "cwe",
            "owasp-a1",
            "owasp-a2",
            "owasp-a6",
            "security"
          ]
        }
      ]
    },
    {
      "key": "S1848",
      "title": "Objects should not be created to be dropped immediately without being used",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S1848",
          "language": "C#",
          "title": "Objects should not be created to be dropped immediately without being used",
          "description": "<p>\r\nThere is no good reason to create a new object to not do anything with it. Most of the time, this is due to a missing piece of code and so could lead to an unexpected behavior in production.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif (x < 0)\r\n  new ArgumentException(\"x must be nonnegative\");\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (x < 0)\r\n  throw new ArgumentException(\"x must be nonnegative\");\r\n</pre>\r\n",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S2360",
      "title": "Optional parameters should not be used",
      "tags": [
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S2360",
          "language": "C#",
          "title": "Optional parameters should not be used",
          "description": "<p>\r\n    The overloading mechanism should be used in place of optional parameters for several reasons:\r\n    <ul>\r\n        <li>Optional parameter values are baked into the method call site code, thus, if a default value has been changed, all referencing assemblies need to be rebuilt, otherwise the original values will be used.</li>\r\n        <li>The Common Language Specification (CLS) allows compilers to ignore default parameter values, and thus require the caller to explicitly specify the values.</li>\r\n        <li>The concept of optional argument exists only in VB.Net and C#. In all other languages like C++ or Java, the overloading mechanism is the only way to get the same behavior.</li>\r\n        <li>Optional parameters prevent muddying the definition of the function contract. Here is a simple example: if there are two optional parameters, when one is defined, is the second one still optional or mandatory?</li>\r\n    </ul>\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvoid Notify(string company, string office = \"QJZ\") // Noncompliant\r\n{\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nvoid Notify(string company)\r\n{\r\n  Notify(company, \"QJZ\");\r\n}\r\nvoid Notify(string company, string office = \"QJZ\")\r\n{\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    The rule ignores parameters with caller info attributes.\r\n</p>\r\n",
          "severity": "Major",
          "tags": [
            "pitfall"
          ]
        },
        {
          "key": "S2360",
          "language": "VB.NET",
          "title": "Optional parameters should not be used",
          "description": "<p>\r\n    The overloading mechanism should be used in place of optional parameters for several reasons:\r\n    <ul>\r\n        <li>Optional parameter values are baked into the method call site code, thus, if a default value has been changed, all referencing assemblies need to be rebuilt, otherwise the original values will be used.</li>\r\n        <li>The Common Language Specification (CLS) allows compilers to ignore default parameter values, and thus require the caller to explicitly specify the values.</li>\r\n        <li>The concept of optional argument exists only in VB.Net and C#. In all other languages like C++ or Java, the overloading mechanism is the only way to get the same behavior.</li>\r\n        <li>Optional parameters prevent muddying the definition of the function contract. Here is a simple example: if there are two optional parameters, when one is defined, is the second one still optional or mandatory?</li>\r\n    </ul>\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nSub Notify(ByVal Company As String, Optional ByVal Office As String = \"QJZ\") ' Noncompliant\r\n\r\nEnd Sub\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nSub Notify(ByVal Company As String)\r\n  Notify(Company, \"QJZ\")\r\nEnd Sub\r\n\r\nSub Notify(ByVal Company As String, ByVal Office As String)\r\n\r\nEnd Sub\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    The rule ignores parameters with caller info attributes.\r\n</p>\r\n",
          "severity": "Major",
          "tags": [
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S3466",
      "title": "Optional parameters should be passed to \"base\" calls",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S3466",
          "language": "C#",
          "title": "Optional parameters should be passed to \"base\" calls",
          "description": "<p>\r\n    Generally, writing the least code that will readably do the job is a good thing, so omitting default parameter values seems to \r\n    make sense. Unfortunately, when you omit them from the <code>base</code> call in an override, you're not actually getting the \r\n    job done thoroughly, because you're ignoring the value the caller passed in. The result will likely not be what the caller \r\n    expected.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class BaseClass\r\n{\r\n  public virtual void MyMethod(int i = 1)\r\n  { \r\n    Console.WriteLine(i);\r\n  }\r\n}\r\n\r\npublic class DerivedClass : BaseClass\r\n{\r\n  public override void MyMethod(int i = 1)\r\n  {\r\n    // ... \r\n    base.MyMethod(); // Noncompliant; caller's value is ignored\r\n  }\r\n\r\n  static int Main(string[] args) \r\n  {\r\n    DerivedClass dc = new DerivedClass();\r\n    dc.MyMethod(12);  // prints 1\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class BaseClass\r\n{\r\n  public virtual void MyMethod(int i = 1)\r\n  { \r\n    Console.WriteLine(i);\r\n  }\r\n}\r\n\r\npublic class DerivedClass : BaseClass\r\n{\r\n  public override void MyMethod(int i = 1)\r\n  {\r\n    // ... \r\n    base.MyMethod(i);\r\n  }\r\n\r\n  static int Main(string[] args) \r\n  {\r\n    DerivedClass dc = new DerivedClass();\r\n    dc.MyMethod(12);  // prints 12\r\n  }\r\n}\r\n</pre>",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S3451",
      "title": "\"[DefaultValue]\" should not be used when \"[DefaultParameterValue]\" is meant",
      "tags": [
        "suspicious"
      ],
      "implementations": [
        {
          "key": "S3451",
          "language": "C#",
          "title": "\"[DefaultValue]\" should not be used when \"[DefaultParameterValue]\" is meant",
          "description": "<p>\r\n    The use of <code>[DefaultValue]</code> with <code>[Optional]</code> has no more effect than <code>[Optional]</code> alone. That's because \r\n    <code>[DefaultValue]</code> doesn't actually do anything; it merely indicates the intent for the value. More than likely, \r\n    <code>[DefaultValue]</code> was used in confusion instead of <code>[DefaultParameterValue]</code>.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass MyClass\r\n{\r\n  public void DoStuff([Optional][DefaultValue(4)]int i, int j = 5)  // Noncompliant\r\n  {\r\n    Console.WriteLine(i);\r\n  }\r\n\r\n  public static void Main()\r\n  {\r\n    new MyClass().DoStuff(); // prints 0\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nclass MyClass\r\n{\r\n  public void DoStuff([Optional][DefaultParameterValue(4)]int i, int j = 5) \r\n  {\r\n    Console.WriteLine(i);\r\n  }\r\n\r\n  public static void Main()\r\n  {\r\n    new MyClass().DoStuff(); // prints 4\r\n  }\r\n}\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Change to \"[DefaultParameterValue]\"</li></ul>",
          "severity": "Major",
          "tags": [
            "suspicious"
          ]
        }
      ]
    },
    {
      "key": "S3447",
      "title": "\"[Optional]\" should not be used on \"ref\" or \"out\" parameters",
      "tags": [
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S3447",
          "language": "C#",
          "title": "\"[Optional]\" should not be used on \"ref\" or \"out\" parameters",
          "description": "<p>\r\n    The use of <code>ref</code> or <code>out</code> in combination with <code>[Optional]</code> is both confusing and contradictory.\r\n    <code>[Optional]</code> indicates that the parameter doesn't have to be provided, while out and ref mean that the parameter will be used\r\n    to return data to the caller (<code>ref</code> additionally indicates that the parameter may also be used to pass data into the method).\r\n</p>\r\n<p>\r\n    Thus, making it <code>[Optional]</code> to provide the parameter in which you will be passing back the method results doesn't make sense.\r\n    In fact, the compiler will raise an error on such code. Unfortunately, it raises the error on method calls where the\r\n    <code>[Optional]</code> parameter has been omitted, not the source of the problem, the method declaration.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass MyClass\r\n{\r\n    public void DoStuff([Optional] ref int i) // Noncompliant\r\n    {\r\n        Console.WriteLine(i);\r\n    }\r\n\r\n    public static void Main()\r\n    {\r\n        new MyClass().DoStuff(); // This doesn't compile, CS7036 shows\r\n    }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nclass MyClass\r\n{\r\n  public void DoStuff(ref int i)\r\n  {\r\n    Console.WriteLine(i);\r\n  }\r\n\r\n  public static void Main()\r\n  {\r\n    var i = 42;\r\n    new MyClass().DoStuff(ref i);\r\n  }\r\n}\r\n</pre><h2>Code Fixes</h2><ul><li>Remove \"Optional\" attribute</li></ul>",
          "severity": "Major",
          "tags": [
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S3169",
      "title": "Multiple \"OrderBy\" calls should not be used",
      "tags": [
        "bug",
        "performance"
      ],
      "implementations": [
        {
          "key": "S3169",
          "language": "C#",
          "title": "Multiple \"OrderBy\" calls should not be used",
          "description": "<p>\r\n    There's no point in chaining multiple <code>OrderBy</code> calls in a LINQ; only the last one will be reflected in the result\r\n    because each subsequent call completely reorders the list. Thus, calling <code>OrderBy</code> multiple times is a performance\r\n    issue as well, because all of the sorting will be executed, but only the result of the last sort will be kept.\r\n</p>\r\n<p>\r\n    Instead, use <code>ThenBy</code> for each call after the first.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvar x = personList\r\n  .OrderBy(person => person.Age)\r\n  .OrderBy(person => person.Name)  // Noncompliant\r\n  .ToList();  // x is sorted by Name, not sub-sorted\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvar x = personList\r\n  .OrderBy(person => person.Age)\r\n  .ThenBy(person => person.Name)\r\n  .ToList();\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Change \"OrderBy\" to \"ThenBy\"</li></ul>",
          "severity": "Critical",
          "tags": [
            "bug",
            "performance"
          ]
        }
      ]
    },
    {
      "key": "S1226",
      "title": "Method parameters and caught exceptions should not be reassigned",
      "tags": [
        "misra",
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S1226",
          "language": "C#",
          "title": "Method parameters and caught exceptions should not be reassigned",
          "description": "<p>\r\n    While it is technically correct to assign to parameters from within method bodies, it is better to use temporary variables to store intermediate results.\r\n    This rule will typically detect cases where a constructor parameter is assigned to itself instead of a field of the same name, i.e. when <code>this</code> was forgotten.\r\n    Allowing parameters to be assigned to also reduces the code readability as developers will not be able to know whether the original parameter or some temporary variable is being accessed without going through the whole method.\r\n    Moreover, some developers might also expect assignments of method parameters to be visible from callers, which is not the case and can confuse them.\r\n    All parameters should be treated as <code>readonly</code>.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass MyClass\r\n{\r\n  public string name;\r\n\r\n  public MyClass(string name)\r\n  {\r\n    name = name;                    // Noncompliant - useless identity assignment\r\n  }\r\n\r\n  public int Add(int a, int b)\r\n  {\r\n    a = a + b;                      // Noncompliant\r\n\r\n    /* additional logic */\r\n\r\n    return a;                       // Seems like the parameter is returned as is, what is the point?\r\n  }\r\n\r\n  public static void Main()\r\n  {\r\n    MyClass foo = new MyClass();\r\n    int a = 40;\r\n    int b = 2;\r\n    foo.Add(a, b);                  // Variable \"a\" will still hold 40 after this call\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nclass MyClass\r\n{\r\n  public string name;\r\n\r\n  public MyClass(string name)\r\n  {\r\n    this.name = name;               // Compliant\r\n  }\r\n\r\n  public int Add(int a, int b)\r\n  {\r\n    return a + b;                   // Compliant\r\n  }\r\n\r\n  public static void Main()\r\n  {\r\n    MyClass foo = new MyClass();\r\n    int a = 40;\r\n    int b = 2;\r\n    foo.Add(a, b);\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n<ul>\r\n    <li>MISRA C:2012, 17.8 - A function parameter should not be modified</li>\r\n</ul>\r\n",
          "severity": "Major",
          "tags": [
            "misra",
            "pitfall"
          ]
        },
        {
          "key": "S1226",
          "language": "VB.NET",
          "title": "Method parameters and caught exceptions should not be reassigned",
          "description": "<p>\r\n    While it is technically correct to assign to parameters from within method bodies, it is better to use temporary variables to store intermediate results.\r\n    This rule will typically detect cases where a constructor parameter is assigned to itself instead of a field of the same name, i.e. when <code>Me</code> was forgotten.\r\n    Allowing parameters to be assigned to also reduces the code readability as developers will not be able to know whether the original parameter or some temporary variable is being accessed without going through the whole method.\r\n    Moreover, some developers might also expect assignments of method parameters to be visible from callers, which is not the case and can confuse them.\r\n    All parameters should be treated as <code>ReadOnly</code>.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Foo(ByVal a As Integer)\r\n        a = 42                  ' Noncompliant\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Foo(ByVal a As Integer)\r\n        Dim tmp = a\r\n        tmp = 42                ' Compliant\r\n    End Sub\r\nEnd Module\r\n' or\r\nModule Module1\r\n    Sub Foo(ByRef a As Integer)\r\n        a = 42                  ' Compliant - it is a ByRef parameter\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n\r\n<h2>See</h2>\r\n<ul>\r\n    <li>MISRA C:2012, 17.8 - A function parameter should not be modified</li>\r\n</ul>\r\n",
          "severity": "Major",
          "tags": [
            "misra",
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S927",
      "title": "\"partial\" method parameter names should match",
      "tags": [
        "cert",
        "misra",
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S927",
          "language": "C#",
          "title": "\"partial\" method parameter names should match",
          "description": "<p>\r\n    When the parameters to the implementation of a <code>partial</code> method don't match those\r\n    in the signature declaration, then confusion is almost guaranteed. Either the implementer was\r\n    confused when he renamed, swapped or mangled the parameter names in the implementation, or\r\n    callers will be confused.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npartial class Point\r\n{\r\n  partial void MoveVertically(int z);\r\n}\r\n\r\npartial class Point\r\n{\r\n  int x = 0;\r\n  int y = 0;\r\n  int z = 0;\r\n\r\n  partial void MoveVertically(int y)  // Noncompliant\r\n  {\r\n    this.y = y;\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npartial class Point\r\n{\r\n  partial void MoveVertically(int z);\r\n}\r\n\r\npartial class Point\r\n{\r\n  int x = 0;\r\n  int y = 0;\r\n  int z = 0;\r\n\r\n  partial void MoveVertically(int z)\r\n  {\r\n    this.z = z;\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li>MISRA C:2004, 8.3 - For each function parameter the type given in the declaration and definition shall be identical, and the return types shall also be identical</li>\r\n    <li>MISRA C:2004, 16.4 - The identifiers used in the declaration and definition of a function shall be identical.</li>\r\n    <li>MISRA C++:2008, 8-4-2 - The identifiers used for the parameters in a re-declaration of a function shall be identical to those in the declaration.</li>\r\n    <li>MISRA C:2012, 8.3 - All declarations of an object or function shall use the same names and type qualifiers.</li>\r\n</ul>",
          "severity": "Critical",
          "tags": [
            "cert",
            "misra",
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S2234",
      "title": "Parameters should be passed in the correct order",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S2234",
          "language": "C#",
          "title": "Parameters should be passed in the correct order",
          "description": "<p>\r\n    When the names of parameters in a method call match the names of the method arguments,\r\n    it contributes to clearer, more readable code. However, when the names match, but are\r\n    passed in a different order than the method arguments, it indicates a mistake in the\r\n    parameter order which will likely lead to unexpected results.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic double divide(int divisor, int dividend)\r\n{\r\n  return divisor/dividend;\r\n}\r\n\r\npublic void doTheThing()\r\n{\r\n  int divisor = 15;\r\n  int dividend = 5;\r\n\r\n  double result = divide(dividend, divisor);  // Noncompliant; operation succeeds, but result is unexpected\r\n  //...\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic double divide(int divisor, int dividend)\r\n{\r\n  return divisor/dividend;\r\n}\r\n\r\npublic void doTheThing()\r\n{\r\n  int divisor = 15;\r\n  int dividend = 5;\r\n\r\n  double result = divide(divisor, dividend);\r\n  //...\r\n}\r\n</pre>",
          "severity": "Blocker",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S3251",
      "title": "Implementations should be provided for \"partial\" methods",
      "tags": [
        "suspicious"
      ],
      "implementations": [
        {
          "key": "S3251",
          "language": "C#",
          "title": "Implementations should be provided for \"partial\" methods",
          "description": "<p>\r\n    <code>partial</code> methods allow an increased degree of flexibility in programming a system. Hooks can be added to generated code\r\n    by invoking methods that define their signature, but might not have an implementation yet. But if the implementation is still missing\r\n    when the code makes it to production, the compiler silently removes the call. In the best case scenario, such calls simply represent\r\n    cruft, but in they worst case they are critical, missing functionality, the loss of which will lead to unexpected results at runtime.\r\n</p>\r\n<p>\r\n    This rule raises an issue for partial methods for which no implementation can be found in the assembly.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npartial class C\r\n{\r\n  partial void M(); //Noncompliant\r\n\r\n  void OtherM()\r\n  {\r\n    M(); //Noncompliant. Will be removed.\r\n  }\r\n}\r\n</pre>\r\n",
          "severity": "Minor",
          "tags": [
            "suspicious"
          ]
        }
      ]
    },
    {
      "key": "S1450",
      "title": "Private fields only used as local variables in methods should become local variables",
      "tags": [
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S1450",
          "language": "C#",
          "title": "Private fields only used as local variables in methods should become local variables",
          "description": "<p>\r\n    When the value of a private field is always assigned to in a class' methods before being read, then it is not being used to store class information. Therefore, it should become a local variable in the relevant methods to prevent any misunderstanding.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class Foo\r\n{\r\n  private int singularField;\r\n  public void DoSomething(int x)\r\n  {\r\n    singularField = x + 5;\r\n    if (singularField == 0) { /* ... */ }\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class Foo\r\n{\r\n  public void DoSomething(int x)\r\n  {\r\n    int localVariable = x + 5;\r\n    if (localVariable == 0) { /* ... */ }\r\n  }\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S2372",
      "title": "Exceptions should not be thrown from property getters",
      "tags": [
        "error-handling"
      ],
      "implementations": [
        {
          "key": "S2372",
          "language": "C#",
          "title": "Exceptions should not be thrown from property getters",
          "description": "<p>\r\n    Property getters should be simple operations that are always safe to call. If exceptions need to be thrown, it is best to convert the property to a method.\r\n</p>\r\n<p>\r\n    It is valid to throw exceptions from indexed property getters and from property setters, which are not detected by this rule.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass MyClass\r\n{\r\n  public int Foo\r\n  {\r\n    get\r\n    {\r\n      throw new NotImplementedException();  //Non-Compliant\r\n    }\r\n    set\r\n    {\r\n      // ... some code ...\r\n    }\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nclass MyClass\r\n{\r\n  public void SetFoo(int value)\r\n  {\r\n    // ... some code ...\r\n  }\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "error-handling"
          ]
        },
        {
          "key": "S2372",
          "language": "VB.NET",
          "title": "Exceptions should not be thrown from property getters",
          "description": "<p>\r\n    Property getters should be simple operations that are always safe to call. If exceptions need to be thrown, it is best to convert the property to a method.\r\n</p>\r\n<p>\r\n    It is valid to throw exceptions from indexed property getters and from property setters, which are not detected by this rule.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nModule Module1\r\n    Public Property Foo() As Integer\r\n        Get\r\n            Throw New NotImplementedException  ' Non-Compliant\r\n        End Get\r\n        Set(ByVal value As Integer)\r\n            ' ... some code ...\r\n        End Set\r\n    End Property\r\nEnd Module\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nModule Module1\r\n    Sub SetFoo(ByVal value As Integer)         ' Compliant\r\n        ' ... some code ...\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "error-handling"
          ]
        }
      ]
    },
    {
      "key": "S2292",
      "title": "Trivial properties should be auto-implemented",
      "tags": [
        "clumsy"
      ],
      "implementations": [
        {
          "key": "S2292",
          "language": "C#",
          "title": "Trivial properties should be auto-implemented",
          "description": "<p>\r\n    Trivial properties, which include no logic but setting and getting a backing field should be converted to auto-implemented\r\n    properties, yielding cleaner and more readable code.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class Car\r\n{\r\n  private string _make;\r\n  public string Make // Noncompliant\r\n  {\r\n    get { return _make; }\r\n    set { _make = value; }\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class Car\r\n{\r\n  public string Make { get; set; }\r\n}\r\n</pre>\r\n",
          "severity": "Minor",
          "tags": [
            "clumsy"
          ]
        }
      ]
    },
    {
      "key": "S2376",
      "title": "Write-only properties should not be used",
      "tags": [
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S2376",
          "language": "C#",
          "title": "Write-only properties should not be used",
          "description": "<p>\r\n    Properties with only setters are confusing and counterintuitive. Instead, a property getter should be added if possible, or\r\n    the property should be replaced with a setter method.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass Program\r\n{\r\n    public int Foo  //Non-Compliant\r\n    {\r\n        set\r\n        {\r\n            // ... some code ...\r\n        }\r\n    }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nclass Program\r\n{\r\n    public void SetFoo(int value)\r\n    {\r\n        // ... some code ...\r\n    }\r\n}\r\n</pre>",
          "severity": "Major",
          "tags": [
            "pitfall"
          ]
        },
        {
          "key": "S2376",
          "language": "VB.NET",
          "title": "Write-only properties should not be used",
          "description": "<p>\r\n    Properties with only setters are confusing and counterintuitive. Instead, a property getter should be added if possible, or\r\n    the property should be replaced with a setter method.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nModule Module1\r\n    WriteOnly Property Foo() As Integer ' Non-Compliant\r\n        Set(ByVal value As Integer)\r\n            ' ... some code ...\r\n        End Set\r\n    End Property\r\nEnd Module\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nModule Module1\r\n    Sub SetFoo(ByVal value As Integer)  ' Compliant\r\n        ' ... some code ...\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S2339",
      "title": "Public constant members should not be used",
      "tags": [
        "convention"
      ],
      "implementations": [
        {
          "key": "S2339",
          "language": "C#",
          "title": "Public constant members should not be used",
          "description": "<p>\r\n    Constant members are copied at compile time to the call sites, instead of being fetched at runtime.\r\n</p>\r\n<p>\r\n    As an example, say you have a library with a constant <code>Version</code> member set to <code>1.0</code>, and a\r\n    client application linked to it. This library is then updated and <code>Version</code> is set to <code>2.0</code>.\r\n    Unfortunately, even after the old DLL is replaced by the new one, <code>Version</code> will still be <code>1.0</code>\r\n    for the client application. In order to see <code>2.0</code>, the client application would need to be rebuilt\r\n    against the new version of the library.\r\n</p>\r\n<p>\r\n    This means that you should use constants to hold values that by definition will never change, such as <code>Zero</code>.\r\n    In practice, those cases are uncommon, and therefore it is generally better to avoid constant members.\r\n</p>\r\n<p>\r\n    This rule only reports issues on public constant fields, which can be reached from outside the defining assembly.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class Foo\r\n{\r\n    public const double Version = 1.0;           // Noncompliant\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\npublic class Foo\r\n{\r\n    public static double Version\r\n    {\r\n      get { return 1.0; }\r\n    }\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "convention"
          ]
        },
        {
          "key": "S2339",
          "language": "VB.NET",
          "title": "Public constant members should not be used",
          "description": "<p>\r\n    Constant members are copied at compile time to the call sites, instead of being fetched at runtime.\r\n</p>\r\n<p>\r\n    As an example, say you have a library with a constant <code>Version</code> member set to <code>1.0</code>, and a\r\n    client application linked to it. This library is then updated and <code>Version</code> is set to <code>2.0</code>.\r\n    Unfortunately, even after the old DLL is replaced by the new one, <code>Version</code> will still be <code>1.0</code>\r\n    for the client application. In order to see <code>2.0</code>, the client application would need to be rebuilt\r\n    against the new version of the library.\r\n</p>\r\n<p>\r\n    This means that you should use constants to hold values that by definition will never change, such as <code>Zero</code>.\r\n    In practice, those cases are uncommon, and therefore it is generally better to avoid constant members.\r\n</p>\r\n<p>\r\n    This rule only reports issues on public constant fields, which can be reached from outside the defining assembly.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nPublic Class Foo\r\n    Public Const Version = 1.0           ' Noncompliant\r\nEnd Class\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nPublic Class Foo\r\n    Public Shared ReadOnly Property Version = 1.0 ' Compliant\r\nEnd Class\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "convention"
          ]
        }
      ]
    },
    {
      "key": "S2368",
      "title": "Public methods should not have multidimensional array parameters",
      "tags": [
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S2368",
          "language": "C#",
          "title": "Public methods should not have multidimensional array parameters",
          "description": "<p>\r\n    Exposing methods with multidimensional array parameters require developers to have advanced knowledge about the language in\r\n    order to be able to use them. Moreover, what exactly to pass to such parameters is not intuitive. Therefore, such methods\r\n    should not be exposed, but can be used internally.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class Program\r\n{\r\n    public void WriteMatrix(int[][] matrix) // Non-Compliant\r\n    {\r\n    }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\npublic class Matrix\r\n{\r\n    // ...\r\n}\r\n\r\npublic class Program\r\n{\r\n    public void WriteMatrix(Matrix matrix) // Compliant\r\n    {\r\n    }\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "pitfall"
          ]
        },
        {
          "key": "S2368",
          "language": "VB.NET",
          "title": "Public methods should not have multidimensional array parameters",
          "description": "<p>\r\n    Exposing methods with multidimensional array parameters require developers to have advanced knowledge about the language in\r\n    order to be able to use them. Moreover, what exactly to pass to such parameters is not intuitive. Therefore, such methods\r\n    should not be exposed, but can be used internally.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nModule Module1\r\n    Sub WriteMatrix(ByVal matrix As Integer()()) ' Non-Compliant\r\n        ' ...\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nClass Matrix\r\n    ' ...\r\nEnd Class\r\n\r\nModule Module1\r\n    Sub WriteMatrix(ByVal matrix As Matrix)      ' Compliant\r\n        ' ...\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S3603",
      "title": "Methods with \"Pure\" attribute should return a value",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S3603",
          "language": "C#",
          "title": "Methods with \"Pure\" attribute should return a value",
          "description": "<p>\r\n    Marking a method with the <code>[Pure]</code> attribute specifies that the method doesn't make any visible changes; thus,\r\n    the method should return a result, otherwise the call to the method should be equal to no-operation. So <code>[Pure]</code>\r\n    on a <code>void</code> method is either a mistake, or the method doesn't do any meaningful task.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass Person\r\n{\r\n  private int age;\r\n  [Pure] // Noncompliant. In this case the method makes a possibly visible state change\r\n  void ConfigureAge(int age)\r\n  {\r\n    ...\r\n    this.age = age;\r\n  }\r\n  ...\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nclass Person\r\n{\r\n  private int age;\r\n\r\n  void ConfigureAge(int age)\r\n  {\r\n    ...\r\n    this.age = age;\r\n  }\r\n  ...\r\n}\r\n</pre>\r\n",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S3253",
      "title": "Constructor and destructor declarations should not be redundant",
      "tags": [
        "clumsy",
        "finding"
      ],
      "implementations": [
        {
          "key": "S3253",
          "language": "C#",
          "title": "Constructor and destructor declarations should not be redundant",
          "description": "<p>\r\n    Since the compiler will automatically invoke the base type's no-argument constructor, there's no need to specify its invocation\r\n    explicitly. Also, when only a single <code>public</code> parameterless constructor is defined in a class, then that constructor\r\n    can be removed because the compiler would generate it automatically. Similarly, empty <code>static</code> constructors and empty\r\n    destructors are also wasted keystrokes.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass X\r\n{\r\n  public X() { } // Noncompliant\r\n  static X() { }  // Noncompliant\r\n  ~X() { } // Noncompliant\r\n\r\n  ...\r\n}\r\n\r\nclass Y : X\r\n{\r\n  public Y(int parameter) : base() // Noncompliant\r\n  {\r\n    /* does something with the parameter */\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nclass X\r\n{\r\n  ...\r\n}\r\n\r\nclass Y : X\r\n{\r\n  public Y(int parameter)\r\n  {\r\n    /* does something with the parameter */\r\n  }\r\n}\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Remove \"base()\" call</li><li>Remove constructor</li><li>Remove destructor</li></ul>",
          "severity": "Minor",
          "tags": [
            "clumsy",
            "finding"
          ]
        }
      ]
    },
    {
      "key": "S3254",
      "title": "Default parameter values should not be passed as arguments",
      "tags": [
        "clumsy",
        "finding"
      ],
      "implementations": [
        {
          "key": "S3254",
          "language": "C#",
          "title": "Default parameter values should not be passed as arguments",
          "description": "<p>\r\n    Specifying the default parameter values in a method call is redundant. Such values should be omitted in the interests of readability.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic void M(int x, int y = 5, int z = 7) { /* ... */ }\r\n\r\n// ...\r\nM(1, 5); //Noncompliant, y has the default value\r\nM(1, z: 7); //Noncompliant, z has the default value\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic void M(int x, int y=5, int z = 7) { /* ... */ }\r\n\r\n// ...\r\nM(1);\r\nM(1);\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Remove redundant arguments</li><li>Remove redundant arguments with adding named arguments</li></ul>",
          "severity": "Minor",
          "tags": [
            "clumsy",
            "finding"
          ]
        }
      ]
    },
    {
      "key": "S1905",
      "title": "Redundant casts should not be used",
      "tags": [
        "clumsy"
      ],
      "implementations": [
        {
          "key": "S1905",
          "language": "C#",
          "title": "Redundant casts should not be used",
          "description": "<p>\r\n    Unnecessary casting expressions make the code harder to read and understand.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic int Example(int i)\r\n{\r\n  return (int) (i + 42); // Noncompliant\r\n}\r\npublic IEnumerable&lt;int&gt; ExampleCollection(IEnumerable&lt;int&gt; coll)\r\n{\r\n  return coll.Reverse().OfType&lt;int&gt;(); // Noncompliant\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic int Example(int i)\r\n{\r\n  return i + 42;\r\n}\r\npublic IEnumerable&lt;int&gt; ExampleCollection(IEnumerable&lt;int&gt; coll)\r\n{\r\n  return coll.Reverse();\r\n}\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Remove redundant cast</li></ul>",
          "severity": "Minor",
          "tags": [
            "clumsy"
          ]
        }
      ]
    },
    {
      "key": "S3440",
      "title": "Variables should not be checked against the values they're about to be assigned",
      "tags": [
        "confusing"
      ],
      "implementations": [
        {
          "key": "S3440",
          "language": "C#",
          "title": "Variables should not be checked against the values they're about to be assigned",
          "description": "<p>\r\n    There's no point in checking a variable against the value you're about to assign it. Save the cycles and lines of code, and simply perform the assignment.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif (x != a)  // Noncompliant; why bother?\r\n{\r\n  x = a;\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nx = a;\r\n</pre><h2>Code Fixes</h2><ul><li>Remove redundant conditional</li></ul>",
          "severity": "Minor",
          "tags": [
            "confusing"
          ]
        }
      ]
    },
    {
      "key": "S3257",
      "title": "Declarations and initializations should be as concise as possible",
      "tags": [
        "clumsy",
        "finding"
      ],
      "implementations": [
        {
          "key": "S3257",
          "language": "C#",
          "title": "Declarations and initializations should be as concise as possible",
          "description": "<p>\r\n    Unnecessarily verbose declarations and initializations make it harder to read the code, and should be simplified.\r\n</p>\r\n<p>\r\n    Specifically the following should be omitted when they can be inferred:\r\n    <ul>\r\n        <li>array element type</li>\r\n        <li>array size</li>\r\n        <li><code>new DelegateType</code></li>\r\n        <li><code>new Nullable&lt;Type&gt;</code></li>\r\n        <li>object or collection initializers (<code>{}</code>)</li>\r\n        <li>type of lambda expression parameters</li>\r\n        <li>parameter declarations of anonymous methods when the parameters are not used.</li>\r\n    </ul>\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvar l = new List&lt;int&gt;() {}; // Noncompliant, {} can be removed\r\nvar o = new object() {}; // Noncompliant, {} can be removed\r\n\r\nvar ints = new int[] {1, 2, 3}; // Noncompliant, int can be omitted\r\nints = new int[3] {1, 2, 3}; // Noncompliant, the size specification can be removed\r\n\r\nint? i = new int?(5); // Noncompliant new int? could be omitted, it can be inferred from the declaration, and there's implicit conversion from T to T?\r\nvar j = new int?(5);\r\n\r\nFunc&lt;int, int&gt; f1 = (int i) => 1; //Noncompliant, can be simplified\r\n\r\nclass Class\r\n{\r\n  private event EventHandler MyEvent;\r\n\r\n  public Class()\r\n  {\r\n    MyEvent += new EventHandler((a,b) => { }); // Noncompliant, needlessly verbose\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvar l = new List&lt;int&gt;();\r\nvar o = new object();\r\n\r\nvar ints = new [] {1, 2, 3};\r\nints = new [] {1, 2, 3};\r\n\r\nint? i = 5;\r\nvar j = new int?(5);\r\n\r\nFunc&lt;int, int&gt; f1 = (i) => 1;\r\n\r\nclass Class\r\n{\r\n  private event EventHandler MyEvent;\r\n\r\n  public Class()\r\n  {\r\n    MyEvent += (a,b) => { };\r\n  }\r\n}\r\n</pre><h2>Code Fixes</h2><ul><li>Remove redundant array size</li><li>Remove redundant array type</li><li>Remove redundant type declaration</li><li>Remove redundant explicit delegate creation</li><li>Remove redundant explicit nullable creation</li><li>Remove redundant object initializer</li><li>Remove redundant parameter list</li></ul>",
          "severity": "Minor",
          "tags": [
            "clumsy",
            "finding"
          ]
        }
      ]
    },
    {
      "key": "S1939",
      "title": "Inheritance list should not be redundant",
      "tags": [
        "clumsy"
      ],
      "implementations": [
        {
          "key": "S1939",
          "language": "C#",
          "title": "Inheritance list should not be redundant",
          "description": "<p>\r\n    An inheritance list entry is redundant if:\r\n    <ul>\r\n        <li>It is <code>Object</code> - all classes extend <code>Object</code> implicitly.</li>\r\n        <li>It is <code>int</code> for an <code>enum</code></li>\r\n        <li>It is a base class of another listed inheritance.</li>\r\n    </ul>\r\n    Such redundant declarations should be removed because they needlessly clutter the code and can be confusing.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class MyClass : Object  // Noncompliant\r\n\r\nenum MyEnum : int  // Noncompliant\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class MyClass\r\n\r\nenum MyEnum\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Remove redundant declaration</li></ul>",
          "severity": "Minor",
          "tags": [
            "clumsy"
          ]
        }
      ]
    },
    {
      "key": "S3626",
      "title": "Jump statements should not be redundant",
      "tags": [
        "clumsy",
        "finding"
      ],
      "implementations": [
        {
          "key": "S3626",
          "language": "C#",
          "title": "Jump statements should not be redundant",
          "description": "<p>\r\n    Jump statements, such as <code>return</code>, <code>yield break</code>,<code>goto</code>, and <code>continue</code> let you change the default flow of\r\n    program execution, but jump statements that direct the control flow to the original direction are just a waste of keystrokes.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvoid Foo()\r\n{\r\n  goto A; // Noncompliant\r\n  A:\r\n  while (condition1)\r\n  {\r\n    if (condition2)\r\n    {\r\n      continue; // Noncompliant\r\n    }\r\n    else\r\n    {\r\n      DoTheThing();\r\n    }\r\n  }\r\n  return; // Noncompliant; this is a void method\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvoid Foo()\r\n{\r\n  while (condition1)\r\n  {\r\n    if (!condition2)\r\n    {\r\n      DoTheThing();\r\n    }\r\n  }\r\n}\r\n</pre>\r\n",
          "severity": "Minor",
          "tags": [
            "clumsy",
            "finding"
          ]
        }
      ]
    },
    {
      "key": "S2333",
      "title": "Redundant modifiers should be removed",
      "tags": [
        "unused",
        "finding"
      ],
      "implementations": [
        {
          "key": "S2333",
          "language": "C#",
          "title": "Redundant modifiers should be removed",
          "description": "<p>\r\n    Unnecessary keywords simply clutter the code and should be removed. Specifically:\r\n    <ul>\r\n        <li><code>partial</code> on type declarations that are completely defined in one place</li>\r\n        <li><code>sealed</code> on members of <code>sealed</code> classes</li>\r\n        <li><code>unsafe</code> method or block inside construct already marked with <code>unsafe</code>, or when there are no <code>unsafe</code>\r\n        constructs in the block</li>\r\n        <li><code>checked</code> and <code>unchecked</code> blocks with no integral-type arithmetic operations</li>\r\n    </ul>\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic partial class MyClass // Noncompliant\r\n{\r\n  public virtual void Method()\r\n  {\r\n  }\r\n}\r\n\r\npublic sealed class MyOtherClass : MyClass\r\n{\r\n  public sealed override void Method() // Noncompliant\r\n  {\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class MyClass\r\n{\r\n  public virtual void Method()\r\n  {\r\n  }\r\n}\r\n\r\npublic sealed class MyOtherClass : MyClass\r\n{\r\n  public override void Method()\r\n  {\r\n  }\r\n}\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Remove redundant \"unsafe\" modifier</li><li>Remove redundant \"checked\" and \"unchecked\"modifier</li><li>Remove redundant \"partial\" modifier</li><li>Remove redundant \"sealed\" modifier</li></ul>",
          "severity": "Minor",
          "tags": [
            "unused",
            "finding"
          ]
        }
      ]
    },
    {
      "key": "S3610",
      "title": "Nullable type comparison should not be redundant",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S3610",
          "language": "C#",
          "title": "Nullable type comparison should not be redundant",
          "description": "<p>\r\n    Calling <code>GetType()</code> on a nullable object returns the underlying value type. Thus, comparing the returned\r\n    <code>Type</code> object to <code>typeof(Nullable&lt;SomeType&gt;)</code> doesn't make sense. The comparison either throws an\r\n    exception or the result can be known at compile time.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nint? nullable = 42;\r\nbool comparison = nullable.GetType() == typeof(Nullable&lt;int&gt;); // Noncompliant, always false\r\ncomparison = nullable.GetType() != typeof(Nullable&lt;int&gt;); // Noncompliant, always true\r\n\r\nnullable = null;\r\ncomparison = nullable.GetType() != typeof(Nullable&lt;int&gt;); // Noncompliant, calling GetType on a null always throws an exception\r\n</pre>\r\n",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S3235",
      "title": "Redundant parentheses should not be used",
      "tags": [
        "unused",
        "finding"
      ],
      "implementations": [
        {
          "key": "S3235",
          "language": "C#",
          "title": "Redundant parentheses should not be used",
          "description": "<p>\r\n    Redundant parentheses are simply wasted keystrokes, and should be removed.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\n[MyAttribute()] //Noncompliant\r\nclass MyClass\r\n{\r\n  public int MyProperty { get; set; }\r\n  public static MyClass CreateNew(int propertyValue)\r\n  {\r\n    return new MyClass() //Noncompliant\r\n    {\r\n      MyProperty = propertyValue\r\n    };\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\n[MyAttribute]\r\nclass MyClass\r\n{\r\n  public int MyProperty { get; set; }\r\n  public static MyClass CreateNew(int propertyValue)\r\n  {\r\n    return new MyClass\r\n    {\r\n      MyProperty = propertyValue\r\n    };\r\n  }\r\n}\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Remove redundant parentheses</li></ul>",
          "severity": "Minor",
          "tags": [
            "unused",
            "finding"
          ]
        }
      ]
    },
    {
      "key": "S3441",
      "title": "Redundant property names should be omitted in anonymous classes",
      "tags": [
        "clumsy",
        "finding"
      ],
      "implementations": [
        {
          "key": "S3441",
          "language": "C#",
          "title": "Redundant property names should be omitted in anonymous classes",
          "description": "<p>\r\n    When an anonymous type's properties are copied from properties or variables with the same names, it yields cleaner code to\r\n    omit the new type's property name and the assignment operator.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvar X = 5;\r\n\r\nvar anon = new\r\n{\r\n  X = X, //Noncompliant, the new object would have the same property without the \"X =\" part.\r\n  Y = \"my string\"\r\n};\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvar X = 5;\r\n\r\nvar anon = new\r\n{\r\n  X,\r\n  Y = \"my string\"\r\n};\r\n</pre><h2>Code Fixes</h2><ul><li>Remove redundant explicit property names</li></ul>",
          "severity": "Minor",
          "tags": [
            "clumsy",
            "finding"
          ]
        }
      ]
    },
    {
      "key": "S3456",
      "title": "\"string.ToCharArray()\" should not be called redundantly",
      "tags": [
        "clumsy"
      ],
      "implementations": [
        {
          "key": "S3456",
          "language": "C#",
          "title": "\"string.ToCharArray()\" should not be called redundantly",
          "description": "<p>\r\n    <code>ToCharArray</code> can be omitted when the operation on the array could have been done directly on the string, such as when\r\n    iterating over the characters in a string, and when accessing a character in a string via an array index. In those cases, explicit\r\n    <code>ToCharArray</code> calls should be omitted.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nstring str = \"some string\";\r\nforeach (var c in str.ToCharArray()) // Noncompliant\r\n{\r\n  // ...\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nstring str = \"some string\";\r\nforeach (var c in str)\r\n{\r\n  // ...\r\n}\r\n</pre><h2>Code Fixes</h2><ul><li>Remove redundant \"ToCharArray\" call</li></ul>",
          "severity": "Major",
          "tags": [
            "clumsy"
          ]
        }
      ]
    },
    {
      "key": "S1858",
      "title": "\"ToString()\" calls should not be redundant",
      "tags": [
        "clumsy",
        "finding"
      ],
      "implementations": [
        {
          "key": "S1858",
          "language": "C#",
          "title": "\"ToString()\" calls should not be redundant",
          "description": "<p>\r\n    Invoking a method designed to return a string representation of an object which is already a string is a waste of\r\n    keystrokes. Similarly, explicitly invoking <code>ToString()</code> when the compiler would do it implicitly is also\r\n    needless code-bloat.\r\n</p>\r\n<p>\r\n    This rule raises an issue when <code>ToString()</code> is invoked:\r\n    <ul>\r\n        <li>on a <code>string</code></li>\r\n        <li>on a non-<code>string</code> operand to concatenation</li>\r\n        <li>on an argument to <code>string.Format</code></li>\r\n    </ul>\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvar s = \"foo\";\r\nvar t = \"fee fie foe \" + s.ToString();  // Noncompliant\r\nvar someObject = new object();\r\nvar u = \"\" + someObject.ToString(); // Noncompliant\r\nvar v = string.Format(\"{0}\", someObject.ToString()); // Noncompliant\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvar s = \"foo\";\r\nvar t = \"fee fie foe \" + s;\r\nvar someObject = new object();\r\nvar u = \"\" + someObject;\r\nvar v = string.Format(\"{0}\", someObject);\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>The rule does not report on value types, where leaving off the <code>ToString()</code> call would result in automatic boxing.</p>\r\n<pre>\r\nvar v = string.Format(\"{0}\", 1.ToString());\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Remove redundant \"ToString\" call</li></ul>",
          "severity": "Minor",
          "tags": [
            "clumsy",
            "finding"
          ]
        }
      ]
    },
    {
      "key": "S1698",
      "title": "\"==\" should not be used when \"Equals\" is overridden",
      "tags": [
        "cert",
        "cwe"
      ],
      "implementations": [
        {
          "key": "S1698",
          "language": "C#",
          "title": "\"==\" should not be used when \"Equals\" is overridden",
          "description": "<p>\r\n    Using the equality <code>==</code> and inequality <code>!=</code> operators to compare two objects generally works. The operators\r\n    can be overloaded, and therefore the comparison can resolve to the appropriate method. However, when the operators are used on\r\n    interface instances, then <code>==</code> resolves to reference equality, which may result in unexpected behavior if implementing\r\n    classes override <code>Equals</code>. Similarly, when a class overrides <code>Equals</code>, but instances are compared with\r\n    non-overloaded <code>==</code>, there is a high chance that value comparison was meant instead of the reference one.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic interface IMyInterface\r\n{\r\n}\r\n\r\npublic class MyClass : IMyInterface\r\n{\r\n    public override bool Equals(object obj)\r\n    {\r\n        //...\r\n    }\r\n}\r\n\r\npublic class Program\r\n{\r\n    public static void Method(IMyInterface instance1, IMyInterface instance2)\r\n    {\r\n        if (instance1 == instance2) // Noncompliant, will do reference equality check, but was that intended? MyClass overrides Equals.\r\n        {\r\n            Console.WriteLine(\"Equal\");\r\n        }\r\n    }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic interface IMyInterface\r\n{\r\n}\r\n\r\npublic class MyClass : IMyInterface\r\n{\r\n    public override bool Equals(object obj)\r\n    {\r\n        //...\r\n    }\r\n}\r\n\r\npublic class Program\r\n{\r\n    public static void Method(IMyInterface instance1, IMyInterface instance2)\r\n    {\r\n        if (object.Equals(instance1, instance2)) // object.Equals checks for null and then calls the instance based Equals, so MyClass.Equals\r\n        {\r\n            Console.WriteLine(\"Equal\");\r\n        }\r\n    }\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    The rule does not report on comparisons of <code>System.Type</code> instances and on comparisons inside <code>Equals</code> overrides.\r\n</p>\r\n",
          "severity": "Major",
          "tags": [
            "cert",
            "cwe"
          ]
        }
      ]
    },
    {
      "key": "S2995",
      "title": "\"Object.ReferenceEquals\" should not be used for value types",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S2995",
          "language": "C#",
          "title": "\"Object.ReferenceEquals\" should not be used for value types",
          "description": "<p>\r\n    Using <code>Object.ReferenceEquals</code> to compare the references of two value types simply won't return the\r\n    expected results most of the time because such types are passed by value, not by reference.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class MyClass\r\n{\r\n  private MyStruct myStruct;\r\n\r\n  public void DoSomething(MyStruct s1) {\r\n    int a = 1;\r\n    int b = 1;\r\n\r\n    if (Object.ReferenceEquals(myStruct, s1))  // Noncompliant; this can never be true\r\n    {\r\n      // ...\r\n    }\r\n    else if (Object.ReferenceEquals(a,b)) // Noncompliant\r\n    {\r\n      // ...\r\n    }\r\n  }\r\n}\r\n</pre>\r\n",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S2201",
      "title": "Return values should not be ignored when function calls don't have any side effects",
      "tags": [
        "bug",
        "cert",
        "misra"
      ],
      "implementations": [
        {
          "key": "S2201",
          "language": "C#",
          "title": "Return values should not be ignored when function calls don't have any side effects",
          "description": "<p>\r\n    When the call to a function doesn't have any side effects, what is the point of making the call if the results are\r\n    ignored? In such case, either the function call is useless and should be dropped or the source code doesn't behave\r\n    as expected.\r\n</p>\r\n<p>\r\n    To prevent generating any false-positives, this rule triggers an issues only when the results of the following methods\r\n    are ignored:\r\n    <ul>\r\n        <li>LINQ method,</li>\r\n        <li><code>[Pure]</code> method,</li>\r\n        <li>any method on <code>string</code>, <code>int</code>, ...,\r\n        <code>System.Collections.Immutable.ImmutableArray&lt;T&gt;</code>, <code>ImmutableHashSet&lt;T&gt;</code>, ...</li>\r\n    </ul>\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\ncoll.Where(i => i &gt; 5).Select(i => i*i); // Noncompliant\r\n\"this string\".Equals(\"other string\"); // Noncompliant\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvar res = coll.Where(i => i &gt; 5).Select(i => i*i); // Noncompliant\r\nvar isEqual = \"this string\".Equals(\"other string\"); // Noncompliant\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    This rule doesn't report issues on method calls with <code>out</code> or <code>ref</code> arguments.\r\n</p>\r\n\r\n<h2>See</h2>\r\n<p>\r\n    <ul>\r\n        <li>MISRA C:2012, 17.7 - The value returned by a function having non-void return type shall be used</li>\r\n        <li><a href=\"https://www.securecoding.cert.org/confluence/x/9YIRAQ\">CERT, EXP12-C.</a> - Do not ignore values returned by functions</li>\r\n        <li><a href=\"https://www.securecoding.cert.org/confluence/x/eoAyAQ\">CERT, EXP12-CPP.</a> - Do not ignore values returned by functions or methods</li>\r\n        <li><a href=\"https://www.securecoding.cert.org/confluence/x/9gEqAQ\">CERT, EXP00-J.</a> - Do not ignore values returned by methods</li>\r\n    </ul>\r\n</p>",
          "severity": "Critical",
          "tags": [
            "bug",
            "cert",
            "misra"
          ]
        }
      ]
    },
    {
      "key": "S2757",
      "title": "\"=+\" should not be used instead of \"+=\"",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S2757",
          "language": "C#",
          "title": "\"=+\" should not be used instead of \"+=\"",
          "description": "<p>\r\n    The use of operators pairs (<code>=+</code>, <code>=-</code> or <code>=!</code>) where the reversed, single operator\r\n    was meant (<code>+=</code>, <code>-=</code> or <code>!=</code>) will compile and run, but not produce the expected results.\r\n</p>\r\n<p>\r\n    This rule raises an issue when <code>=+</code>, <code>=-</code> and <code>=!</code> are used, but ignores the operators\r\n    when they're spaced out: <code>= +</code>, <code>= -</code>, <code>= !</code>.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nint target = -5;\r\nint num = 3;\r\n\r\ntarget =- num; // Noncompliant; target = -3. Is that really what's meant?\r\ntarget =+ num; // Noncompliant; target = 3\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nint target = -5;\r\nint num = 3;\r\n\r\ntarget = -num; // Compliant; intent to assign inverse value of num is clear\r\ntarget += num;\r\n</pre>",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S1109",
      "title": "A close curly brace should be located at the beginning of a line",
      "tags": [
        "convention"
      ],
      "implementations": [
        {
          "key": "S1109",
          "language": "C#",
          "title": "A close curly brace should be located at the beginning of a line",
          "description": "<p>\r\nShared coding conventions make it possible for a team to efficiently collaborate. This rule makes it mandatory to place a close curly brace at the beginning of a line.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif(condition)\r\n{\r\n  doSomething();}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif(condition)\r\n{\r\n  doSomething();\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>When blocks are inlined (open and close curly braces on the same line), no issue is triggered.</p>\r\n<pre>\r\nif(condition) { doSomething(); }\r\n</pre>\r\n",
          "severity": "Minor",
          "tags": [
            "convention"
          ]
        }
      ]
    },
    {
      "key": "S1656",
      "title": "Variables should not be self-assigned",
      "tags": [
        "bug",
        "cert"
      ],
      "implementations": [
        {
          "key": "S1656",
          "language": "C#",
          "title": "Variables should not be self-assigned",
          "description": "<p>\r\nThere is no reason to re-assign a variable to itself. Either this statement is redundant and should be removed, or the re-assignment is a mistake and some other value or variable was intended for the assignment instead.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic void setName(string name)\r\n{\r\n    name = name;\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic void setName(string name)\r\n{\r\n    this.name = name;\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li> <a href=\"https://www.securecoding.cert.org/confluence/x/NYA5\">CERT, MSC12-C</a> - Detect and remove code that has no effect</li>\r\n    <li> <a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP</a> - Detect and remove code that has no effect</li>\r\n</ul>",
          "severity": "Critical",
          "tags": [
            "bug",
            "cert"
          ]
        }
      ]
    },
    {
      "key": "S3449",
      "title": "Right operands of shift operators should be integers",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S3449",
          "language": "C#",
          "title": "Right operands of shift operators should be integers",
          "description": "<p>\r\n    Numbers can be shifted with the <code>&lt;&lt;</code> and <code>&gt;&gt;</code> operators, but the right operand of the operation needs to be \r\n    an <code>int</code> or a type that has an implicit conversion to <code>int</code>. However, with <code>dynamic</code>, the compiler's type \r\n    checking is turned off, so you can pass anything to a shift operator and have it compile. And if the argument can't be converted to \r\n    <code>int</code> at runtime, then a <code>RuntimeBinderException</code> will be raised.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\ndynamic d = 5;\r\nvar x = d &gt;&gt; 5.4; // Noncompliant\r\nx = d &gt;&gt; null; // Noncompliant\r\nx &lt;&lt;= new object(); // Noncompliant\r\n</pre>\r\n",
          "severity": "Blocker",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S1697",
      "title": "Short-circuit logic should be used to prevent null pointer dereferences in conditionals",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S1697",
          "language": "C#",
          "title": "Short-circuit logic should be used to prevent null pointer dereferences in conditionals",
          "description": "<p>\r\nWhen either the equality operator in a null test or the logical operator that follows it is reversed, the code has the appearance of safely null-testing the object before dereferencing it.\r\nUnfortunately the effect is just the opposite - the object is null-tested and then dereferenced only if it is null, leading to a guaranteed null pointer dereference.\r\n</p>\r\n\r\n<h2>Noncompliant Code Sample</h2>\r\n<pre>\r\nif (str == null &amp;&amp; str.Length == 0)\r\n{\r\n  Console.WriteLine(\"String is empty\");\r\n}\r\n\r\nif (str != null || str.Length > 0)\r\n{\r\n  Console.WriteLine(\"String is not empty\");\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (str == null || str.Length == 0)\r\n{\r\n  Console.WriteLine(\"String is empty\");\r\n}\r\n\r\nif (str != null &amp;&amp; str.Length > 0)\r\n{\r\n  Console.WriteLine(\"String is not empty\");\r\n}\r\n</pre>",
          "severity": "Blocker",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S2437",
      "title": "Silly bit operations should not be performed",
      "tags": [
        "suspicious"
      ],
      "implementations": [
        {
          "key": "S2437",
          "language": "C#",
          "title": "Silly bit operations should not be performed",
          "description": "<p>\r\n    Certain bit operations are just silly and should not be performed because their results are predictable.\r\n</p>\r\n<p>\r\n    Specifically, using <code>&amp; -1</code> with any value will always result in the original value, as will\r\n    <code>anyValue ^ 0</code> and <code>anyValue | 0</code>.\r\n</p>\r\n<h2>Code Fixes</h2><ul><li>Remove bitwise operation</li></ul>",
          "severity": "Major",
          "tags": [
            "suspicious"
          ]
        }
      ]
    },
    {
      "key": "S122",
      "title": "Statements should be on separate lines",
      "tags": [
        "convention"
      ],
      "implementations": [
        {
          "key": "S122",
          "language": "C#",
          "title": "Statements should be on separate lines",
          "description": "<p>\r\n    For better readability, do not put more than one statement on a single line.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nif(someCondition) doSomething();\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nif(someCondition) {\r\n  doSomething();\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    Anonymous functions containing a single statement are ignored. Block statements are not considered either.\r\n</p>\r\n<pre>\r\nFunc&lt;object, bool&gt; item1 = o =&gt; { return true; }; // Compliant\r\nFunc&lt;object, bool&gt; item1 = o =&gt; { var r = false; return r; }; // Noncompliant\r\n</pre>",
          "severity": "Minor",
          "tags": [
            "convention"
          ]
        },
        {
          "key": "S122",
          "language": "VB.NET",
          "title": "Statements should be on separate lines",
          "description": "<p>\r\n    For better readability, do not put more than one statement on a single line.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n        Dim a = 0 : Dim b = 0  ' Noncompliant\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n        Dim a = 0              ' Compliant\r\n        Dim b = 0              ' Compliant\r\n    End Sub\r\nEnd Module\r\n</pre>",
          "severity": "Minor",
          "tags": [
            "convention"
          ]
        }
      ]
    },
    {
      "key": "S2743",
      "title": "Static fields should not be used in generic types",
      "tags": [],
      "implementations": [
        {
          "key": "S2743",
          "language": "C#",
          "title": "Static fields should not be used in generic types",
          "description": "<p>\r\n    A static field in a generic type is not shared among instances of different closed constructed types, thus <code>LengthLimitedSingletonCollection&lt;int&gt;.instances</code>\r\n    and <code>LengthLimitedSingletonCollection&lt;string&gt;.instances</code> will point to different objects, even though <code>instances</code> is seemingly shared among all\r\n    <code>LengthLimitedSingletonCollection&lt;&gt;</code> generic classes.\r\n</p>\r\n<p>\r\n    If you need to have a static field shared among instances with different generic arguments, define a non-generic base class to store your static members, then set your generic type to inherit from the base class.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class LengthLimitedSingletonCollection&lt;T&gt; where T : new()\r\n{\r\n  protected const int MaxAllowedLength = 5;\r\n  protected static Dictionary&lt;Type, object&gt; instances = new Dictionary&lt;Type, object&gt;(); // Noncompliant\r\n  public static T GetInstance()\r\n  {\r\n    object instance;\r\n    if (!instances.TryGetValue(typeof(T), out instance))\r\n    {\r\n      if (instances.Count >= MaxAllowedLength)\r\n      {\r\n        throw new Exception();\r\n      }\r\n      instance = new T();\r\n      instances.Add(typeof(T), instance);\r\n    }\r\n    return (T)instance;\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class SingletonCollectionBase\r\n{\r\n  protected static Dictionary&lt;Type, object&gt; instances = new Dictionary&lt;Type, object&gt;();\r\n}\r\npublic class LengthLimitedSingletonCollection&lt;T&gt; : SingletonCollectionBase where T : new()\r\n{\r\n  protected const int MaxAllowedLength = 5;\r\n  public static T GetInstance()\r\n  {\r\n    object instance;\r\n    if (!instances.TryGetValue(typeof(T), out instance))\r\n    {\r\n      if (instances.Count >= MaxAllowedLength)\r\n      {\r\n        throw new Exception();\r\n      }\r\n      instance = new T();\r\n      instances.Add(typeof(T), instance);\r\n    }\r\n    return (T)instance;\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Exception</h2>\r\n<p>\r\n    If the static field or property uses a type parameter, then the developer is assumed to understand that the static member is not shared among the closed constructed types.\r\n</p>\r\n<pre>\r\npublic class Cache&lt;T&gt;\r\n{\r\n  private static Dictionary&lt;string, T&gt; CacheDictionary { get; set; } // Compliant\r\n}\r\n</pre>\r\n",
          "severity": "Critical",
          "tags": []
        }
      ]
    },
    {
      "key": "S3263",
      "title": "Static fields should appear in the order they must be initialized",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S3263",
          "language": "C#",
          "title": "Static fields should appear in the order they must be initialized",
          "description": "<p>\r\n    Static field initializers are executed in the order in which they appear in the class from top to bottom. Thus,\r\n    placing a static field in a class above the field or fields required for its initialization will yield unexpected\r\n    results.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass MyClass\r\n{\r\n  public static int X = Y; // Noncompliant; Y at this time is still assigned default(int), i.e. 0\r\n  public static int Y = 42;\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nclass MyClass\r\n{\r\n  public static int Y = 42;\r\n  public static int X = Y;\r\n}\r\n</pre>\r\nor\r\n<pre>\r\nclass MyClass\r\n{\r\n  public static int X;\r\n  public static int Y = 42;\r\n\r\n  static MyClass()\r\n  {\r\n    X = Y;\r\n  }\r\n}\r\n</pre>",
          "severity": "Blocker",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S2223",
      "title": "Non-constant static fields should not be visible",
      "tags": [
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S2223",
          "language": "C#",
          "title": "Non-constant static fields should not be visible",
          "description": "<p>\r\n    A <code>static</code> field that is neither constant nor read-only is not thread-safe. Correctly accessing\r\n    these fields from different threads needs synchronization with <code>lock</code>s. Improper synchronization\r\n    may lead to unexpected results, thus publicly visible static fields are best suited for storing non-changing\r\n    data shared by many consumers. To enforce this intent, these fields should be marked <code>readonly</code> or\r\n    converted to a constant.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class Math\r\n{\r\n  public static double Pi = 3.14;  // Noncompliant\r\n}\r\n</pre>\r\nor\r\n<pre>\r\npublic class Shape\r\n{\r\n  public static Shape Empty = new EmptyShape();  // Noncompliant\r\n\r\n  private class EmptyShape : Shape\r\n  {\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class Math\r\n{\r\n  public const double Pi = 3.14;\r\n}\r\n</pre>\r\nor\r\n<pre>\r\npublic class Shape\r\n{\r\n  public static readonly Shape Empty = new EmptyShape();\r\n\r\n  private class EmptyShape : Shape\r\n  {\r\n  }\r\n}\r\n</pre>",
          "severity": "Major",
          "tags": [
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S2696",
      "title": "Instance members should not write to \"static\" fields",
      "tags": [
        "multi-threading"
      ],
      "implementations": [
        {
          "key": "S2696",
          "language": "C#",
          "title": "Instance members should not write to \"static\" fields",
          "description": "<p>\r\n    Correctly updating a <code>static</code> field from a non-static method is tricky to get right and could easily lead to\r\n    bugs if there are multiple class instances and/or multiple threads in play.\r\n</p>\r\n<p>\r\n    This rule raises an issue each time a <code>static</code> field is updated from a non-static method or property.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class MyClass\r\n{\r\n  private static int count = 0;\r\n\r\n  public void DoSomething()\r\n  {\r\n    //...\r\n    count++;  // Noncompliant\r\n  }\r\n}\r\n</pre>\r\n",
          "severity": "Critical",
          "tags": [
            "multi-threading"
          ]
        }
      ]
    },
    {
      "key": "S2674",
      "title": "The length returned from a stream read should be checked",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S2674",
          "language": "C#",
          "title": "The length returned from a stream read should be checked",
          "description": "<p>\r\n    You cannot assume that any given stream reading call will fill the <code>byte[]</code> passed in to the method with\r\n    the number of bytes requested. Instead, you must check the value returned by the read method to see how many bytes\r\n    were read. Fail to do so, and you introduce a bug that is both harmful and difficult to reproduce.\r\n</p>\r\n<p>\r\n    This rule raises an issue when a <code>Stream.Read</code> or a <code>Stream.ReadAsync</code> method is called, but\r\n    the return value is not checked.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic void DoSomething(string fileName)\r\n{\r\n  using (var stream = File.Open(fileName, FileMode.Open))\r\n  {\r\n    var result = new byte[stream.Length];\r\n    stream.Read(result, 0, (int)stream.Length); // Noncompliant\r\n    // ... do something with result\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic void DoSomething(string fileName)\r\n{\r\n  using (var stream = File.Open(fileName, FileMode.Open))\r\n  {\r\n    var buffer = new byte[1024];\r\n    using (var ms = new MemoryStream())\r\n    {\r\n        int read;\r\n        while ((read = stream.Read(buffer, 0, buffer.Length)) > 0)\r\n        {\r\n            ms.Write(buffer, 0, read);\r\n        }\r\n        // ... do something with ms\r\n    }\r\n  }\r\n}\r\n</pre>",
          "severity": "Blocker",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S1643",
      "title": "Strings should not be concatenated using \"+\" in a loop",
      "tags": [
        "performance"
      ],
      "implementations": [
        {
          "key": "S1643",
          "language": "C#",
          "title": "Strings should not be concatenated using \"+\" in a loop",
          "description": "<p>\r\n    <code>StringBuilder</code> is more efficient than string concatenation, especially when the operator is repeated over and over as in loops.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nstring str = \"\";\r\nfor (int i = 0; i &lt; arrayOfStrings.Length; ++i)\r\n{\r\n  str = str + arrayOfStrings[i];\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nStringBuilder bld = new StringBuilder();\r\nfor (int i = 0; i &lt; arrayOfStrings.Length; ++i)\r\n{\r\n  bld.Append(arrayOfStrings[i]);\r\n}\r\nstring str = bld.ToString();\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "performance"
          ]
        },
        {
          "key": "S1643",
          "language": "VB.NET",
          "title": "Strings should not be concatenated using \"+\" in a loop",
          "description": "<p>\r\n    <code>StringBuilder</code> is more efficient than string concatenation, especially when the operator is repeated over and over as in loops.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n        Dim foo = \"\"\r\n        foo &amp;= \"Result: \"       ' Compliant - outside of loop\r\n\r\n        For i = 1 To 9\r\n            foo &amp;= i            ' Noncompliant\r\n        Next\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n        Dim foo = New System.Text.StringBuilder\r\n        foo.Append(\"Result: \")  ' Compliant\r\n\r\n        For i = 1 To 9\r\n            foo.Append(i)       ' Compliant\r\n        Next\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "performance"
          ]
        }
      ]
    },
    {
      "key": "S2275",
      "title": "Format strings should be passed the correct number of arguments",
      "tags": [
        "bug",
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S2275",
          "language": "C#",
          "title": "Format strings should be passed the correct number of arguments",
          "description": "<p>\r\n    Use fewer arguments than are expected in your format string, and you'll get an error at runtime. Use more arguments than are\r\n    expected, and you probably won't get the output you expect. Either way, it's a bug.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvar s1 = string.Format(\"{0} {1} {2}\", 1, 2); // Noncompliant; too few arguments\r\nvar s2 = string.Format(\"{0}\", 10, 11); // Noncompliant; too many arguments\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\n// Pass the expected number of arguments\r\nvar s1 = string.Format(\"{0} {1} {2}\", 1, 2, 3);\r\nvar s2 = string.Format(\"{0}\", 10);\r\n</pre>\r\nor\r\n<pre>\r\n// Fix the format string\r\nvar s1 = string.Format(\"{0} {1}\", 1, 2);\r\nvar s2 = string.Format(\"{0} {1}\", 10, 11);\r\n</pre>\r\n",
          "severity": "Critical",
          "tags": [
            "bug",
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S3457",
      "title": "\"string.Format()\" should not be called without placeholders",
      "tags": [
        "confusing"
      ],
      "implementations": [
        {
          "key": "S3457",
          "language": "C#",
          "title": "\"string.Format()\" should not be called without placeholders",
          "description": "<p>\r\n    There's no need to incur the overhead of a formatting call when the string to be formatted contains no formatting symbols.\r\n    Instead, simply use the original input string.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvar s = string.Format(\"some text\");\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvar s = \"some text\";\r\n</pre><h2>Code Fixes</h2><ul><li>Remove useless \"string.Format\" call</li></ul>",
          "severity": "Minor",
          "tags": [
            "confusing"
          ]
        }
      ]
    },
    {
      "key": "S1449",
      "title": "Culture should be specified for \"string\" operations",
      "tags": [
        "cert",
        "unpredictable"
      ],
      "implementations": [
        {
          "key": "S1449",
          "language": "C#",
          "title": "Culture should be specified for \"string\" operations",
          "description": "<p>\r\n    <code>string.ToLower()</code>, <code>ToUpper</code>, <code>IndexOf</code>, <code>LastIndexOf</code>, and <code>Compare</code> are \r\n    all culture-dependent, as are some (floating point number and <code>DateTime</code>-related) calls to <code>ToString</code>. Fortunately, all have\r\n    variants which accept an argument specifying the culture or formatter to use. Leave that argument off and the call will use the\r\n    system default culture, possibly creating problems with international characters.\r\n</p>\r\n<p>\r\n    <code>string.CompareTo()</code> is also culture specific, but has no overload that takes a culture information, so instead it's better to use \r\n    <code>CompareOrdinal</code>, or <code>Compare</code> with culture.\r\n</p>\r\n<p>\r\n    Calls without a culture may work fine in the system's \"home\" environment, but break in ways that are extremely difficult to\r\n    diagnose for customers who use different encodings. Such bugs can be nearly, if not completely, impossible to reproduce when it's\r\n    time to fix them.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvar lowered = someString.ToLower(); //Noncompliant\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvar lowered = someString.ToLower(CultureInfo.InvariantCulture);\r\n</pre>\r\nor\r\n<pre>\r\nvar lowered = someString.ToLowerInvariant();\r\n</pre>\r\n\r\n<h2>See</h2>\r\n<ul>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/EwAiAg\">CERT, STR02-J.</a> - Specify an appropriate locale when comparing locale-dependent data</li>\r\n</ul>\r\n",
          "severity": "Major",
          "tags": [
            "cert",
            "unpredictable"
          ]
        }
      ]
    },
    {
      "key": "S3234",
      "title": "\"GC.SuppressFinalize\" should not be invoked for types without destructors",
      "tags": [
        "confusing",
        "unused"
      ],
      "implementations": [
        {
          "key": "S3234",
          "language": "C#",
          "title": "\"GC.SuppressFinalize\" should not be invoked for types without destructors",
          "description": "<p>\r\n    <code>GC.SuppressFinalize</code> asks the Common Language Runtime not to call the finalizer of an object. This is useful when\r\n    implementing the dispose pattern where object finalization is already handled in <code>IDisposable.Dispose</code>. However, it\r\n    has no effect if there is no finalizer defined in the object's type, so using it in such cases is just confusing.\r\n</p>\r\n<p>\r\n    This rule raises an issue when <code>GC.SuppressFinalize</code> is called for objects of <code>sealed</code> types without a finalizer.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nsealed class MyClass\r\n{\r\n  public void Method()\r\n  {\r\n    ...\r\n    GC.SuppressFinalize(this); //Noncompliant\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nsealed class MyClass\r\n{\r\n  public void Method()\r\n  {\r\n    ...\r\n  }\r\n}\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Remove useless \"SuppressFinalize\" call</li></ul>",
          "severity": "Minor",
          "tags": [
            "confusing",
            "unused"
          ]
        }
      ]
    },
    {
      "key": "S3458",
      "title": "Empty \"case\" clauses that fall through to the \"default\" should be omitted",
      "tags": [
        "clumsy",
        "finding"
      ],
      "implementations": [
        {
          "key": "S3458",
          "language": "C#",
          "title": "Empty \"case\" clauses that fall through to the \"default\" should be omitted",
          "description": "<p>\r\n    Empty <code>case</code> clauses that fall through to the <code>default</code> are useless. Whether or not such a <code>case</code>\r\n    is present, the <code>default</code> clause will be invoked. Such <code>case</code>s simply clutter the code, and should be removed.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nswitch(ch)\r\n{\r\n  case 'a' :\r\n    handleA();\r\n    break;\r\n  case 'b' :\r\n    handleB();\r\n    break;\r\n  case 'c' :  // Noncompliant\r\n  default:\r\n    handleTheRest();\r\n    break;\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nswitch(ch)\r\n{\r\n  case 'a' :\r\n    handleA();\r\n    break;\r\n  case 'b' :\r\n    handleB();\r\n    break;\r\n  default:\r\n    handleTheRest();\r\n    break;\r\n}\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Remove useless \"case\"</li></ul>",
          "severity": "Minor",
          "tags": [
            "clumsy",
            "finding"
          ]
        }
      ]
    },
    {
      "key": "S1301",
      "title": "\"switch\" statements should have at least 3 \"case\" clauses",
      "tags": [
        "misra"
      ],
      "implementations": [
        {
          "key": "S1301",
          "language": "C#",
          "title": "\"switch\" statements should have at least 3 \"case\" clauses",
          "description": "<p>\r\n    <code>switch</code> statements are useful when there are many different cases depending on the value of the same expression.\r\n</p>\r\n<p>\r\n    For just one or two cases however, the code will be more readable with <code>if</code> statements.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nswitch (variable)\r\n{\r\n  case 0:\r\n    doSomething();\r\n    break;\r\n  default:\r\n    doSomethingElse();\r\n    break;\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (variable == 0)\r\n{\r\n  doSomething();\r\n} else\r\n{\r\n  doSomethingElse();\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n<ul>\r\n    <li>MISRA C:2004, 15.5 - Every switch statement shall have at least one case clause.</li>\r\n    <li>MISRA C++:2008, 6-4-8 - Every switch statement shall have at least one case-clause.</li>\r\n    <li>MISRA C:2012, 16.6 - Every switch statement shall have at least two switch-clauses</li>\r\n</ul>",
          "severity": "Minor",
          "tags": [
            "misra"
          ]
        }
      ]
    },
    {
      "key": "S3532",
      "title": "Empty \"default\" clauses in a \"switch\" should be removed",
      "tags": [
        "clumsy",
        "unused",
        "finding"
      ],
      "implementations": [
        {
          "key": "S3532",
          "language": "C#",
          "title": "Empty \"default\" clauses in a \"switch\" should be removed",
          "description": "<p>\r\n    The <code>default</code> clause should take appropriate action. Having an empty <code>default</code> is a waste of keystrokes.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nenum Fruit\r\n{\r\n  Apple,\r\n  Orange,\r\n  Banana\r\n}\r\n\r\nvoid PrintName(Fruit fruit)\r\n{\r\n  switch(fruit)\r\n  {\r\n    case Fruit.Apple:\r\n      Console.WriteLine(\"apple\");\r\n      break;\r\n    default:  //Noncompliant\r\n      break;\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nenum Fruit\r\n{\r\n  Apple,\r\n  Orange,\r\n  Banana\r\n}\r\n\r\nvoid PrintName(Fruit fruit)\r\n{\r\n  switch(fruit)\r\n  {\r\n    case Fruit.Apple:\r\n      Console.WriteLine(\"apple\");\r\n      break;\r\n    default:\r\n      throw new NotSupportedException();\r\n  }\r\n}\r\n</pre>\r\n<p>or</p>\r\n<pre>\r\nvoid PrintName(Fruit fruit)\r\n{\r\n  switch(fruit)\r\n  {\r\n    case Fruit.Apple:\r\n      Console.WriteLine(\"apple\");\r\n      break;\r\n  }\r\n}\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Remove empty \"default\" clause</li></ul>",
          "severity": "Minor",
          "tags": [
            "clumsy",
            "unused",
            "finding"
          ]
        }
      ]
    },
    {
      "key": "S131",
      "title": "\"switch/Select\" statements should end with a \"default/Case Else\" clause",
      "tags": [
        "cert",
        "cwe",
        "misra"
      ],
      "implementations": [
        {
          "key": "S131",
          "language": "C#",
          "title": "\"switch/Select\" statements should end with a \"default/Case Else\" clause",
          "description": "<p>\r\n    The requirement for a final <code>default</code> clause is defensive programming. The clause should either take\r\n    appropriate action, or contain a suitable comment as to why no action is taken. Even when the <code>switch</code>\r\n    covers all current values of an <code>enum</code>, a <code>default</code> case should still be used because there is\r\n    no guarantee that the <code>enum</code> won't be extended.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nint foo = 42;\r\nswitch (foo) // Noncompliant\r\n{\r\n  case 0:\r\n    Console.WriteLine(\"foo = 0\");\r\n    break;\r\n  case 42:\r\n    Console.WriteLine(\"foo = 42\");\r\n    break;\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nint foo = 42;\r\nswitch (foo) // Compliant\r\n{\r\n  case 0:\r\n    Console.WriteLine(\"foo = 0\");\r\n    break;\r\n  case 42:\r\n    Console.WriteLine(\"foo = 42\");\r\n    break;\r\n  default:\r\n    throw new InvalidOperationException(\"Unexpected value foo = \" + foo);\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li>MISRA C:2004, 15.0 - The MISRA C switch syntax shall be used.</li>\r\n    <li>MISRA C:2004, 15.3 - The final clause of a switch statement shall be the default clause</li>\r\n    <li>MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement.</li>\r\n    <li>MISRA C++:2008, 6-4-6 - The final clause of a switch statement shall be the default-clause</li>\r\n    <li>MISRA C:2012, 16.1 - All switch statements shall be well-formed</li>\r\n    <li>MISRA C:2012, 16.4 - Every switch statement shall have a default label</li>\r\n    <li>MISRA C:2012, 16.5 - A default label shall appear as either the first or the last switch label of a switch statement</li>\r\n    <li><a href=\"http://cwe.mitre.org/data/definitions/478.html\">MITRE, CWE-478</a> - Missing Default Case in Switch Statement</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/YgE\">CERT, MSC01-C</a> - Strive for logical completeness</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/JoIyAQ\">CERT, MSC01-CPP</a> - Strive for logical completeness</li>\r\n</ul>",
          "severity": "Major",
          "tags": [
            "cert",
            "cwe",
            "misra"
          ]
        },
        {
          "key": "S131",
          "language": "VB.NET",
          "title": "\"switch/Select\" statements should end with a \"default/Case Else\" clause",
          "description": "<p>\r\n    The requirement for a final <code>Case Else</code> clause is defensive programming. The clause should either take\r\n    appropriate action, or contain a suitable comment as to why no action is taken. Even when the <code>Select</code>\r\n    covers all current values of an <code>Enum</code>, a <code>Case Else</code> case should still be used because there is\r\n    no guarantee that the <code>Enum</code> won't be extended.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nSelect Case param ' Noncompliant - Case Else clause is missing\r\n  Case 0\r\n    DoSomething()\r\n  Case 1\r\n    DoSomethingElse()\r\nEnd Select\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nSelect Case param\r\n  Case 0\r\n    DoSomething()\r\n  Case 1\r\n    DoSomethingElse()\r\n  Case Else ' Compliant\r\n    DoSomethingElse()\r\nEnd Select\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li>MISRA C:2004, 15.0 - The MISRA C switch syntax shall be used.</li>\r\n    <li>MISRA C:2004, 15.3 - The final clause of a switch statement shall be the default clause</li>\r\n    <li>MISRA C++:2008, 6-4-3 - A switch statement shall be a well-formed switch statement.</li>\r\n    <li>MISRA C++:2008, 6-4-6 - The final clause of a switch statement shall be the default-clause</li>\r\n    <li>MISRA C:2012, 16.1 - All switch statements shall be well-formed</li>\r\n    <li>MISRA C:2012, 16.4 - Every switch statement shall have a default label</li>\r\n    <li>MISRA C:2012, 16.5 - A default label shall appear as either the first or the last switch label of a switch statement</li>\r\n    <li><a href=\"http://cwe.mitre.org/data/definitions/478.html\">MITRE, CWE-478</a> - Missing Default Case in Switch Statement</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/YgE\">CERT, MSC01-C</a> - Strive for logical completeness</li>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/JoIyAQ\">CERT, MSC01-CPP</a> - Strive for logical completeness</li>\r\n</ul>",
          "severity": "Major",
          "tags": [
            "cert",
            "cwe",
            "misra"
          ]
        }
      ]
    },
    {
      "key": "S105",
      "title": "Tabulation characters should not be used",
      "tags": [
        "convention"
      ],
      "implementations": [
        {
          "key": "S105",
          "language": "C#",
          "title": "Tabulation characters should not be used",
          "description": "<p>\r\nDevelopers should not need to configure the tab width of their text editors in order to be able to read source code.\r\nSo the use of tabulation character must be banned.\r\n</p>\r\n",
          "severity": "Minor",
          "tags": [
            "convention"
          ]
        },
        {
          "key": "S105",
          "language": "VB.NET",
          "title": "Tabulation characters should not be used",
          "description": "<p>\r\nDevelopers should not need to configure the tab width of their text editors in order to be able to read source code.\r\nSo the use of tabulation character must be banned.\r\n</p>\r\n",
          "severity": "Minor",
          "tags": [
            "convention"
          ]
        }
      ]
    },
    {
      "key": "S3216",
      "title": "\"ConfigureAwait(false)\" should be used",
      "tags": [
        "multi-threading",
        "suspicious"
      ],
      "implementations": [
        {
          "key": "S3216",
          "language": "C#",
          "title": "\"ConfigureAwait(false)\" should be used",
          "description": "<p>\r\n    After an <code>await</code>ed <code>Task</code> has executed, you can continue execution in the original, calling\r\n    thread or any arbitrary thread. Unless the rest of the code needs the context from which the <code>Task</code> was\r\n    spawned, <code>Task.ConfigureAwait(false)</code> should be used to keep execution in the <code>Task</code> thread\r\n    to avoid the need of context switching and the possibility of deadlocks.\r\n</p>\r\n<p>\r\n    This rule raises an issue when code in a class library <code>await</code>s a <code>Task</code> and continues\r\n    execution in the original calling thread.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvar response = await httpClient.GetAsync(url);  // Noncompliant\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvar response = await httpClient.GetAsync(url).ConfigureAwait(false);\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "multi-threading",
            "suspicious"
          ]
        }
      ]
    },
    {
      "key": "S2758",
      "title": "The ternary operator should not return the same value regardless of the condition",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S2758",
          "language": "C#",
          "title": "The ternary operator should not return the same value regardless of the condition",
          "description": "<p>\r\n    When the second and third operands of a ternary operator are the same, the operator will always\r\n    return the same value regardless of the condition. Either the operator itself is pointless, or a\r\n    mistake was made in coding it.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic boolean canVote(Person person)\r\n{\r\n  return person.getAge > 18 ? true : true; // Noncompliant; is this what was intended?\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic boolean canVote(Person person)\r\n{\r\n  return person.getAge > 18 ? true : false;\r\n}\r\n</pre><h2>Code Fixes</h2><ul><li>Remove the ternary operator</li></ul>",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S3005",
      "title": "\"ThreadStatic\" should not be used on non-static fields",
      "tags": [
        "bug",
        "unused"
      ],
      "implementations": [
        {
          "key": "S3005",
          "language": "C#",
          "title": "\"ThreadStatic\" should not be used on non-static fields",
          "description": "<p>\r\n    When a non-<code>static</code> class field is annotated with <code>ThreadStatic</code>, the code seems to show that the\r\n    field can have different values for different calling threads, but that's not the case, since the <code>ThreadStatic</code>\r\n    attribute is simply ignored on non-<code>static</code> fields.\r\n</p>\r\n<p>\r\n    So <code>ThreadStatic</code> should either be removed or replaced with a use of the <code>ThreadLocal&lt;T&gt;</code> class,\r\n    which gives a similar behavior for non-<code>static</code> fields.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class MyClass\r\n{\r\n  [ThreadStatic]  // Noncompliant\r\n  private int count = 0;\r\n\r\n  // ...\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class MyClass\r\n{\r\n  private int count = 0;\r\n\r\n  // ...\r\n}\r\n</pre>\r\nor\r\n<pre>\r\npublic class MyClass\r\n{\r\n  private readonly ThreadLocal&lt;int&gt; count = new ThreadLocal&lt;int&gt;();\r\n  public int Count\r\n  {\r\n    get { return count.Value; }\r\n    set { count.Value = value; }\r\n  }\r\n  // ...\r\n}\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Remove \"ThreadStatic\" attribute</li></ul>",
          "severity": "Critical",
          "tags": [
            "bug",
            "unused"
          ]
        }
      ]
    },
    {
      "key": "S2996",
      "title": "\"ThreadStatic\" fields should not be initialized",
      "tags": [
        "bug",
        "multi-threading"
      ],
      "implementations": [
        {
          "key": "S2996",
          "language": "C#",
          "title": "\"ThreadStatic\" fields should not be initialized",
          "description": "<p>\r\n    When an object has a field annotated with <code>ThreadStatic</code>, that field is shared within a given thread,\r\n    but unique across threads. Since a class' static initializer is only invoked for the\r\n    first thread created, it also means that only the first thread will have the expected initial values.\r\n</p>\r\n<p>\r\n    Instead, allow such fields to be initialized to their default values or make the initialization lazy.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class Foo\r\n{\r\n  [ThreadStatic]\r\n  public static object PerThreadObject = new object(); // Noncompliant. Will be null in all the threads except the first one.\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class Foo\r\n{\r\n  [ThreadStatic]\r\n  public static object _perThreadObject;\r\n  public static object PerThreadObject\r\n  {\r\n    get\r\n    {\r\n      if (_perThreadObject == null)\r\n      {\r\n        _perThreadObject = new object();\r\n      }\r\n      return _perThreadObject;\r\n    }\r\n  }\r\n}\r\n</pre>\r\n",
          "severity": "Critical",
          "tags": [
            "bug",
            "multi-threading"
          ]
        }
      ]
    },
    {
      "key": "S1479",
      "title": "\"switch\" statements should not have too many \"case\" clauses",
      "tags": [
        "brain-overload"
      ],
      "implementations": [
        {
          "key": "S1479",
          "language": "C#",
          "title": "\"switch\" statements should not have too many \"case\" clauses",
          "description": "<h2 class=\"param-header\">Parameters</h2><dl><dt class=\"param-key\">maximum</dt><dd><span class=\"param-description\">Maximum number of case</span><span class=\"param-type\">INTEGER</span><span class=\"param-default\">30</span></dd></dl><p>\r\n  When <code>switch</code> statements have a large set of <code>case</code> clauses, it is usually an attempt to map two sets of data. A real map structure would be more readable and maintainable, and should be used instead.\r\n</p>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    No issue is reported on <code>switch</code> statements that work on <code>enum</code>s.\r\n</p>\r\n",
          "severity": "Major",
          "tags": [
            "brain-overload"
          ]
        }
      ]
    },
    {
      "key": "S107",
      "title": "Methods should not have too many parameters",
      "tags": [
        "brain-overload"
      ],
      "implementations": [
        {
          "key": "S107",
          "language": "C#",
          "title": "Methods should not have too many parameters",
          "description": "<h2 class=\"param-header\">Parameters</h2><dl><dt class=\"param-key\">max</dt><dd><span class=\"param-description\">Maximum authorized number of parameters</span><span class=\"param-type\">INTEGER</span><span class=\"param-default\">7</span></dd></dl><p>\r\nA long parameter list can indicate that a new structure should be created to wrap the numerous parameters or that the function is doing too many things.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<p>The following code snippet illustrates this rule with a maximum number of 4 parameters:</p>\r\n<pre>\r\npublic void doSomething(int param1, int param2, int param3, string param4, long param5)\r\n{\r\n...\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic void doSomething(int param1, int param2, int param3, string param4)\r\n{\r\n...\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "brain-overload"
          ]
        }
      ]
    },
    {
      "key": "S2225",
      "title": "\"ToString()\" method should not return null",
      "tags": [
        "bug",
        "cwe"
      ],
      "implementations": [
        {
          "key": "S2225",
          "language": "C#",
          "title": "\"ToString()\" method should not return null",
          "description": "<p>\r\n    Calling <code>ToString()</code> on an object should always return a string. Returning <code>null</code> instead contravenes the method's implicit contract.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic override string ToString ()\r\n{\r\n  if (this.collection.Count == 0)\r\n  {\r\n    return null; // Noncompliant\r\n  }\r\n  else\r\n  {\r\n    // ...\r\n\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic override string ToString ()\r\n{\r\n  if (this.collection.Count == 0)\r\n  {\r\n    return \"\";\r\n  }\r\n  else\r\n  {\r\n    // ...\r\n\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li><a href=\"http://cwe.mitre.org/data/definitions/476.html\">MITRE CWE-476</a> - NULL Pointer Dereference</li>\r\n</ul>\r\n",
          "severity": "Critical",
          "tags": [
            "bug",
            "cwe"
          ]
        }
      ]
    },
    {
      "key": "S3443",
      "title": "Type examining methods should be avoided on \"System.Type\" instances",
      "tags": [
        "suspicious"
      ],
      "implementations": [
        {
          "key": "S3443",
          "language": "C#",
          "title": "Type examining methods should be avoided on \"System.Type\" instances",
          "description": "<p>\r\n    If you call <code>GetType()</code> on a <code>Type</code> variable, the return value will always be <code>typeof(System.Type)</code>. So there's no real \r\n    point in making that call. The same applies to passing a type argument to <code>IsInstanceOfType</code>. In both cases the results are entirely \r\n    predictable.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nvar type = typeof(int);\r\nvar ttype = type.GetType(); //Noncompliant, always typeof(System.Type)\r\n\r\nvar s = \"abc\";\r\n\r\nif (s.GetType().IsInstanceOfType(typeof(string))) //Noncompliant; false\r\n{ /* ... */ }\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nvar s = \"abc\";\r\n\r\nif (s.GetType().IsInstanceOfType(\"ssss\"))\r\n{ /* ... */ }\r\n</pre>",
          "severity": "Major",
          "tags": [
            "suspicious"
          ]
        }
      ]
    },
    {
      "key": "S2761",
      "title": "Doubled prefix operators \"!!\" and \"~~\" should not be used",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S2761",
          "language": "C#",
          "title": "Doubled prefix operators \"!!\" and \"~~\" should not be used",
          "description": "<p>\r\n    Calling the <code>!</code> or <code>~</code> prefix operator twice does nothing: the second invocation undoes the first.\r\n    Such mistakes are typically caused by accidentally double-tapping the key in question without noticing.\r\n</p>\r\n<p>\r\n    Either this is a bug, if the operator was actually meant to be called once, or misleading if done on purpose.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nint v1 = 0;\r\nbool v2 = false;\r\n\r\nvar v3 = !!v1; // Noncompliant\r\nvar v4 = ~~v2; // Noncompliant\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nint v1 = 0;\r\nbool v2 = false;\r\n\r\nvar v3 = !v1;\r\nvar v4 = ~v2;\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Remove repeated prefix operator(s)</li></ul>",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S3264",
      "title": "Events should be invoked",
      "tags": [
        "unused"
      ],
      "implementations": [
        {
          "key": "S3264",
          "language": "C#",
          "title": "Events should be invoked",
          "description": "<p>\r\n    Events that are not invoked anywhere are dead code, and there's no good reason to keep them in the source.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass UninvokedEventSample\r\n{\r\n    private event Action&lt;object, EventArgs&gt; Happened; //Noncompliant\r\n    public void RegisterEventHandler(Action&lt;object, EventArgs&gt; handler)\r\n    {\r\n        Happened += handler; //we register some event handlers\r\n    }\r\n    public void RaiseEvent()\r\n    {\r\n        if (Happened != null)\r\n        {\r\n            // Happened(this, null); // the event is never triggered, because this line is commented out.\r\n        }\r\n    }\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "unused"
          ]
        }
      ]
    },
    {
      "key": "S1144",
      "title": "Unused private types or members should be removed",
      "tags": [
        "unused"
      ],
      "implementations": [
        {
          "key": "S1144",
          "language": "C#",
          "title": "Unused private types or members should be removed",
          "description": "<p>\r\n    Private types or members that are never executed or referenced are dead code: unnecessary, inoperative code that\r\n    should be removed. Cleaning out dead code decreases the size of the maintained codebase, making it easier to\r\n    understand the program and preventing bugs from being introduced.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic class Foo\r\n{\r\n  private void UnusedPrivateMethod() {...} // Noncompliant\r\n\r\n  private class UnusedClass {...} // Noncompliant\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic class Foo\r\n{\r\n  private Foo()\r\n  {\r\n    UsedPrivateMethod();\r\n  }\r\n\r\n  private void UsedPrivateMethod()\r\n  {\r\n    var c = new UsedClass();\r\n  }\r\n\r\n  private class UsedClass {...}\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    This rule doesn't raise any issue on empty constructors and attributed members.\r\n</p><h2>Code Fixes</h2><ul><li>Remove unused member</li></ul>",
          "severity": "Major",
          "tags": [
            "unused"
          ]
        }
      ]
    },
    {
      "key": "S3241",
      "title": "Methods should not return values that are never used",
      "tags": [
        "cert",
        "design",
        "unused"
      ],
      "implementations": [
        {
          "key": "S3241",
          "language": "C#",
          "title": "Methods should not return values that are never used",
          "description": "<p>\r\n    Private methods are clearly intended for use only within their own scope. When such methods return values that are never used by any of their callers, then\r\n    clearly there is no need to actually make the return, and it should be removed in the interests of efficiency and clarity.\r\n</p>\r\n\r\n<h2>See</h2>\r\n<ul>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/SIIyAQ\">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect</li>\r\n</ul>\r\n",
          "severity": "Major",
          "tags": [
            "cert",
            "design",
            "unused"
          ]
        }
      ]
    },
    {
      "key": "S121",
      "title": "Control structures should use curly braces",
      "tags": [
        "cert",
        "cwe",
        "misra",
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S121",
          "language": "C#",
          "title": "Control structures should use curly braces",
          "description": "<p>\r\n  While not technically incorrect, the omission of curly braces can be misleading, and may lead to the introduction of errors during maintenance.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\n// the two statements seems to be attached to the if statement, but that is only true for the first one:\r\nif (condition)\r\n  executeSomething();\r\n  checkSomething();\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nif (condition)\r\n{\r\n  executeSomething();\r\n  checkSomething();\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li>MISRA C:2004, 14.8 - The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement</li>\r\n    <li>MISRA C:2004, 14.9 - An if (expression) construct shall be followed by a compound statement. The else keyword shall be followed by either a compound statement, or another if statement</li>\r\n    <li>MISRA C++:2008, 6-3-1 - The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement</li>\r\n    <li>MISRA C++:2008, 6-4-1 - An if (condition) construct shall be followed by a compound statement. The else keyword shall be followed by either a compound statement, or another if statement</li>\r\n    <li>MISRA C:2012, 15.6 - The body of an iteration-statement or a selection-statement shall be a compound-statement</li>\r\n    <li> <a href=\"https://www.securecoding.cert.org/confluence/x/1QGMAg\">CERT, EXP19-C</a> - Use braces for the body of an if, for, or while statement</li>\r\n    <li> <a href=\"http://cwe.mitre.org/data/definitions/483.html\">MITRE, CWE-483</a> - Incorrect Block Delimitation</li>\r\n</ul>\r\n",
          "severity": "Major",
          "tags": [
            "cert",
            "cwe",
            "misra",
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S3237",
      "title": "\"value\" parameters should be used",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S3237",
          "language": "C#",
          "title": "\"value\" parameters should be used",
          "description": "<p>\r\n    In property and indexer <code>set</code> methods, and in event <code>add</code> and <code>remove</code> methods, the implicit\r\n    <code>value</code> parameter holds the value the accessor was called with. Not using the <code>value</code> means that the\r\n    accessor ignores the caller's intent which could cause unexpected results at runtime.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nprivate int count;\r\npublic int Count\r\n{\r\n  get { return count; }\r\n  set { count = 42; } // Noncompliant\r\n}\r\n</pre>\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nprivate int count;\r\npublic int Count\r\n{\r\n  get { return count; }\r\n  set { count = value; }\r\n}\r\n</pre>\r\nor\r\n<pre>\r\npublic int Count\r\n{\r\n  get { return count; }\r\n  set { throw new InvalidOperationException(); }\r\n}\r\n</pre>\r\n",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S2123",
      "title": "Values should not be uselessly incremented",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S2123",
          "language": "C#",
          "title": "Values should not be uselessly incremented",
          "description": "<p>\r\n    A value that is incremented or decremented and then not stored is at best wasted code and at worst a bug.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic int pickNumber()\r\n{\r\n  int i = 0;\r\n  int j = 0;\r\n\r\n  i = i++; // Noncompliant; i is still zero\r\n\r\n  return j++; // Noncompliant; 0 returned\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic int pickNumber()\r\n{\r\n  int i = 0;\r\n  int j = 0;\r\n\r\n  i++;\r\n  return ++j;\r\n}\r\n</pre>\r\n",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S1117",
      "title": "Local variables should not shadow class fields",
      "tags": [
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S1117",
          "language": "C#",
          "title": "Local variables should not shadow class fields",
          "description": "<p>\r\n    Shadowing fields with a local variable is a bad practice that reduces code readability: It makes it confusing to know whether the\r\n    field or the variable is being used.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nclass Foo\r\n{\r\n  public int myField;\r\n\r\n  public void DoSomething()\r\n  {\r\n    int myField = 0;  // Noncompliant\r\n    ...\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>See</h2>\r\n<ul>\r\n    <li><a href=\"https://www.securecoding.cert.org/confluence/x/2ADEAw\">CERT, DCL51-J.</a> - Do not shadow or obscure identifiers in subscopes</li>\r\n</ul>",
          "severity": "Major",
          "tags": [
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S1481",
      "title": "Unused local variables should be removed",
      "tags": [
        "unused"
      ],
      "implementations": [
        {
          "key": "S1481",
          "language": "C#",
          "title": "Unused local variables should be removed",
          "description": "<p>\r\nIf a local variable is declared but not used, it is dead code and should be removed. Doing so will improve maintainability because developers will not wonder what the variable is used for.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\npublic int numberOfMinutes(int hours)\r\n{\r\n  int seconds = 0;   // seconds is never used\r\n  return hours * 60;\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\npublic int numberOfMinutes(int hours)\r\n{\r\n  return hours * 60;\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    Unused locally created resources in a <code>using</code> statement are not reported.\r\n</p>\r\n<pre>\r\nusing(var t = new Timer()) // t never used, but compliant.\r\n{\r\n  //...\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "unused"
          ]
        }
      ]
    },
    {
      "key": "S2290",
      "title": "Field-like events should not be virtual",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S2290",
          "language": "C#",
          "title": "Field-like events should not be virtual",
          "description": "<p>\r\n    Field-like events are events that do not have explicit <code>add</code> and <code>remove</code> methods. The compiler\r\n    generates a <code>private</code> <code>delegate</code> field to back the event, as well as generating the implicit\r\n    <code>add</code> and <code>remove</code> methods.\r\n</p>\r\n<p>\r\n    When a <code>virtual</code> field-like <code>event</code> is overridden by another field-like <code>event</code>,\r\n    the behavior of the C# compiler is to generate a new <code>private</code> <code>delegate</code> field in the derived\r\n    class, separate from the parent's field. This results in multiple and separate events being created, which is rarely\r\n    what's actually intended.\r\n</p>\r\n<p>\r\n    To prevent this, remove the <code>virtual</code> designation from the parent class event.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nabstract class Car\r\n{\r\n  public virtual event EventHandler OnRefueled; // Noncompliant\r\n\r\n  public void Refuel()\r\n  {\r\n    // This OnRefueld will always be null\r\n     if (OnRefueled != null)\r\n     {\r\n       OnRefueled(this, null);\r\n     }\r\n  }\r\n}\r\n\r\nclass R2 : Car\r\n{\r\n  public override event EventHandler OnRefueled;\r\n}\r\n\r\nclass Program\r\n{\r\n  static void Main(string[] args)\r\n  {\r\n    var r2 = new R2();\r\n    r2.OnRefueled += new EventHandler((o, a) =>\r\n    {\r\n      Console.WriteLine(\"This event will never be called\");\r\n    });\r\n    r2.Refuel();\r\n  }\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nabstract class Car\r\n{\r\n  public event EventHandler OnRefueled; // Compliant\r\n\r\n  public void Refuel()\r\n  {\r\n    if (OnRefueled != null)\r\n    {\r\n      OnRefueled(this, null);\r\n    }\r\n  }\r\n}\r\n\r\nclass R2 : Car {}\r\n\r\nclass Program\r\n{\r\n  static void Main(string[] args)\r\n  {\r\n    var r2 = new R2();\r\n    r2.OnRefueled += new EventHandler((o, a) =>\r\n    {\r\n      Console.WriteLine(\"This event will be called\");\r\n    });\r\n    r2.Refuel();\r\n  }\r\n}\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Remove \"virtual\" keyword</li></ul>",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S3597",
      "title": "\"ServiceContract\" and \"OperationContract\" attributes should be used together",
      "tags": [
        "suspicious"
      ],
      "implementations": [
        {
          "key": "S3597",
          "language": "C#",
          "title": "\"ServiceContract\" and \"OperationContract\" attributes should be used together",
          "description": "<p>\r\n    The <code>ServiceContract</code> attribute specifies that a class or interface defines the communication contract of a Windows Communication Foundation\r\n    (WCF) service. The service operations of this class or interface are defined by <code>OperationContract</code> attributes added to methods. It doesn't\r\n    make sense to define a contract without any service operations; thus, in a <code>ServiceContract</code> class or interface at least one method should be\r\n    annotated with <code>OperationContract</code>. Similarly, WCF only serves <code>OperationContract</code> methods that are defined inside\r\n    <code>ServiceContract</code> classes or interfaces; thus, this rule also checks that <code>ServiceContract</code> is added to the containing type of\r\n    <code>OperationContract</code> methods.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\n[ServiceContract]\r\ninterface IMyService // Noncompliant\r\n{\r\n  int MyServiceMethod();\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\n[ServiceContract]\r\ninterface IMyService\r\n{\r\n  [OperationContract]\r\n  int MyServiceMethod();\r\n}\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "suspicious"
          ]
        }
      ]
    },
    {
      "key": "S3598",
      "title": "One-way \"OperationContract\" methods should have \"void\" return type",
      "tags": [
        "bug"
      ],
      "implementations": [
        {
          "key": "S3598",
          "language": "C#",
          "title": "One-way \"OperationContract\" methods should have \"void\" return type",
          "description": "<p>\r\n    When declaring a Windows Communication Foundation (WCF) <code>OperationContract</code> method one-way, that service method won't return any result, not\r\n    even an underlying empty confirmation message. These are fire-and-forget methods that are useful in event-like communication. Specifying a return type\r\n    therefore does not make sense.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\n[ServiceContract]\r\ninterface IMyService\r\n{\r\n  [OperationContract(IsOneWay = true)]\r\n  int SomethingHappened(int parameter); // Noncompliant\r\n}\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\n[ServiceContract]\r\ninterface IMyService\r\n{\r\n  [OperationContract(IsOneWay = true)]\r\n  void SomethingHappened(int parameter);\r\n}\r\n</pre>\r\n\r\n<h2>Exceptions</h2>\r\n<p>\r\n    The rule doens't report if <code>OperationContractAttribute.AsyncPattern</code> is set to <code>true</code>.\r\n</p>\r\n",
          "severity": "Critical",
          "tags": [
            "bug"
          ]
        }
      ]
    },
    {
      "key": "S2355",
      "title": "Array literals should be used instead of array creation expressions",
      "tags": [
        "clumsy"
      ],
      "implementations": [
        {
          "key": "S2355",
          "language": "VB.NET",
          "title": "Array literals should be used instead of array creation expressions",
          "description": "<p>\r\n    Array literals are more compact than array creation expressions.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n        Dim foo = New String() {\"a\", \"b\", \"c\"} ' Noncompliant\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n        Dim foo = {\"a\", \"b\", \"c\"}              ' Compliant\r\n    End Sub\r\nEnd Module\r\n</pre><h2>Code Fixes</h2><ul><li>Use an array literal</li></ul>",
          "severity": "Major",
          "tags": [
            "clumsy"
          ]
        }
      ]
    },
    {
      "key": "S1197",
      "title": "Array designators \"()\" should be on the type, not the variable",
      "tags": [
        "convention"
      ],
      "implementations": [
        {
          "key": "S1197",
          "language": "VB.NET",
          "title": "Array designators \"()\" should be on the type, not the variable",
          "description": "<p>\r\n    Array designators should always be located on the type for better code readability. Otherwise, developers must look both at the\r\n    type and the variable name to know whether or not a variable is an array.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n        Dim foo() As String ' Noncompliant\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n        Dim foo As String() ' Compliant\r\n    End Sub\r\nEnd Module\r\n</pre><h2>Code Fixes</h2><ul><li>Move the array designator to the type</li></ul>",
          "severity": "Minor",
          "tags": [
            "convention"
          ]
        }
      ]
    },
    {
      "key": "S2351",
      "title": "Arrays should be initialized using the \"... = {}\" syntax",
      "tags": [
        "clumsy"
      ],
      "implementations": [
        {
          "key": "S2351",
          "language": "VB.NET",
          "title": "Arrays should be initialized using the \"... = {}\" syntax",
          "description": "<p>\r\n    The <code>... = {}</code> syntax is more compact, more readable and less error-prone.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n        Dim foo(1) As String      ' Noncompliant\r\n        foo(0) = \"foo\"\r\n        foo(1) = \"bar\"\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n        Dim foo = {\"foo\", \"bar\"}  ' Compliant\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "clumsy"
          ]
        }
      ]
    },
    {
      "key": "S1147",
      "title": "\"End\" statements should not be used",
      "tags": [
        "cwe",
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S1147",
          "language": "VB.NET",
          "title": "\"End\" statements should not be used",
          "description": "<p>\r\n    <code>End</code> statements exit the control flow of the program in an unstructured way. This statement stops code\r\n    execution immediately without executing <code>Dispose</code> or <code>Finalize</code> methods, or executing\r\n    <code>Finally</code> blocks. Therefore, it should be avoided.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Print(ByVal str As String)\r\n       Try\r\n            ...\r\n            End       ' Noncompliant\r\n        Finally\r\n            ' do something important here\r\n            ...\r\n        End Try\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n\r\n<h2>See</h2>\r\n\r\n<ul>\r\n    <li><a href=\"http://cwe.mitre.org/data/definitions/382\">MITRE, CWE-382</a> - J2EE Bad Practices: Use of System.exit()</li>\r\n</ul>\r\n",
          "severity": "Major",
          "tags": [
            "cwe",
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S2349",
      "title": "Event names should not have \"Before\" or \"After\" as a prefix or suffix",
      "tags": [
        "convention"
      ],
      "implementations": [
        {
          "key": "S2349",
          "language": "VB.NET",
          "title": "Event names should not have \"Before\" or \"After\" as a prefix or suffix",
          "description": "<p>\r\n    \"After\" and \"Before\" prefixes or suffixes should not be used to indicate pre and post events. The concepts of before and\r\n    after should be given to events using the present and past tense.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nClass Foo\r\n    Event BeforeClose() ' Noncompliant\r\n    Event AfterClose()  ' Noncompliant\r\nEnd Class\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nClass Foo\r\n    Event Closing()     ' Compliant\r\n    Event Closed()      ' Compliant\r\nEnd Class\r\n</pre>\r\n",
          "severity": "Minor",
          "tags": [
            "convention"
          ]
        }
      ]
    },
    {
      "key": "S3385",
      "title": "\"Exit\" statements should not be used",
      "tags": [
        "bad-practice",
        "brain-overload"
      ],
      "implementations": [
        {
          "key": "S3385",
          "language": "VB.NET",
          "title": "\"Exit\" statements should not be used",
          "description": "<p>\r\n    Other than <code>Exit Select</code>, using an <code>Exit</code> statement is never a good idea.\r\n</p>\r\n<p>\r\n    <code>Exit Do</code>, <code>Exit For</code>, <code>Exit Try</code>, and <code>Exit While</code> will all result in unstructured control flow,\r\n    i.e. spaghetti code.\r\n</p>\r\n<p>\r\n    <code>Exit Function</code>, <code>Exit Property</code>, and <code>Exit Sub</code> are all poor, less-readable substitutes for a simple\r\n    return, and if used with code that should return a value (<code>Exit Function</code> and in some cases Exit <code>Property</code>) they\r\n    could result in a <code>NullReferenceException</code>.\r\n</p>\r\n<p>\r\n    This rule raises an issue for all uses of <code>Exit</code> except <code>Exit Select</code>and <code>Exit Do</code> statements in loops\r\n    without condition.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nPublic Class Sample\r\n  Dim condition As Boolean\r\n  Public Sub MySub()\r\n    If condition Then\r\n      Exit Sub                  ' Noncompliant\r\n    End If\r\n    For index = 1 To 10\r\n      If index = 5 Then\r\n          Exit For               ' Noncompliant\r\n      End If\r\n      ' ...\r\n    Next\r\n  End Sub\r\n  Function MyFunction() As Object\r\n    ' ...\r\n    MyFunction = 42\r\n    Exit Function              ' Noncompliant\r\n  End Function\r\nEnd Class\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nPublic Class Sample\r\n  Dim condition As Boolean\r\n\r\n  Public Sub MySub()\r\n    If condition Then\r\n        Return\r\n    End If\r\n\r\n    For index = 1 To 4\r\n        ' ...\r\n    Next\r\n  End Sub\r\n  Function MyFunction() As Object\r\n    ' ...\r\n    Return 42\r\n  End Function\r\nEnd Class\r\n</pre>",
          "severity": "Major",
          "tags": [
            "bad-practice",
            "brain-overload"
          ]
        }
      ]
    },
    {
      "key": "S2352",
      "title": "Indexed properties with more than one parameter should not be used",
      "tags": [
        "clumsy"
      ],
      "implementations": [
        {
          "key": "S2352",
          "language": "VB.NET",
          "title": "Indexed properties with more than one parameter should not be used",
          "description": "<p>\r\n    Indexed properties are meant to represent access to a logical collection. When multiple parameters are required,\r\n    this design guideline may be violated, and refactoring the property into a method is preferable.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nModule Module1\r\n    ReadOnly Property Sum(ByVal a As Integer, ByVal b As Integer) ' Non-Compliant\r\n        Get\r\n            Return a + b\r\n        End Get\r\n    End Property\r\nEnd Module\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nModule Module1\r\n    Function Sum(ByVal a As Integer, ByVal b As Integer)          ' Compliant\r\n        Return a + b\r\n    End Function\r\nEnd Module\r\n</pre>\r\n\r\n",
          "severity": "Major",
          "tags": [
            "clumsy"
          ]
        }
      ]
    },
    {
      "key": "S2354",
      "title": "Line continuations should not be used",
      "tags": [
        "convention"
      ],
      "implementations": [
        {
          "key": "S2354",
          "language": "VB.NET",
          "title": "Line continuations should not be used",
          "description": "<p>\r\n    To improve the code readability, the explicit line continuation character, <code>_</code>, should not be used. Instead, it is\r\n    better to break lines after an operator.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n        ' Noncompliant\r\n        Console.WriteLine(\"Hello\" _\r\n                          &amp; \"world\")\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n\r\n        Console.WriteLine(\"Hello\" &amp;\r\n                          \"world\")\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n",
          "severity": "Minor",
          "tags": [
            "convention"
          ]
        }
      ]
    },
    {
      "key": "S2358",
      "title": "\"IsNot\" should be used instead of \"Not ... Is ...\"",
      "tags": [
        "clumsy"
      ],
      "implementations": [
        {
          "key": "S2358",
          "language": "VB.NET",
          "title": "\"IsNot\" should be used instead of \"Not ... Is ...\"",
          "description": "<p>\r\n    The <code>... IsNot ...</code> syntax is more compact and more readable than the <code>Not ... Is ...</code> syntax.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n        Dim a = Not \"a\" Is Nothing ' Noncompliant\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n        Dim a = \"a\" IsNot Nothing  ' Compliant\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Replace \"Not...Is...\" with \"IsNot\".</li></ul>",
          "severity": "Major",
          "tags": [
            "clumsy"
          ]
        }
      ]
    },
    {
      "key": "S2359",
      "title": "\"On Error\" statements should not be used",
      "tags": [
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S2359",
          "language": "VB.NET",
          "title": "\"On Error\" statements should not be used",
          "description": "<p>\r\n    Prefer the use of <code>Try ... Catch</code> blocks instead of <code>On Error</code> statements.\r\n</p>\r\n<p>\r\n    Visual Basic .NET and Visual Basic 2005 offer structured exception handling that provides a powerful, more readable\r\n    alternative to On Error Goto error handling, which is available in previous versions of Microsoft Visual Basic.\r\n    Structured exception handling is more powerful because it allows you to nest error handlers inside other error handlers\r\n    within the same procedure. Furthermore, structured exception handling uses a block syntax similar to the\r\n    <code>If...Else...End If</code> statement. This makes Visual Basic .NET and Visual Basic 2005 code more readable and\r\n    easier to maintain.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nSub DivideByZero()\r\n  On Error GoTo nextstep\r\n  Dim result As Integer\r\n  Dim num As Integer\r\n  num = 100\r\n  result = num / 0\r\nnextstep:\r\n  System.Console.WriteLine(\"Error\")\r\nEnd Sub\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n\r\n<pre>\r\nSub DivideByZero()\r\n  Try\r\n    Dim result As Integer\r\n    Dim num As Integer\r\n    num = 100\r\n    result = num / 0\r\n  Catch\r\n    System.Console.WriteLine(\"Error\")\r\n  End Try\r\nEnd Sub\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S2365",
      "title": "Properties should not be based on arrays",
      "tags": [
        "performance"
      ],
      "implementations": [
        {
          "key": "S2365",
          "language": "VB.NET",
          "title": "Properties should not be based on arrays",
          "description": "<p>\r\n    Most developers expect property access to be as efficient as field access. However, if a property returns an array, it must return a\r\n    deep copy of the original array or risk having the object's internal state altered unexpectedly.\r\n</p>\r\n<p>\r\n    However, making a deep copy, especially when the array is large, is much slower than a simple field access. Therefore, such properties\r\n    should be refactored into methods.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nModule Module1\r\n    ' Internal state\r\n    Dim array = {\"apple\", \"banana\", \"orange\", \"pineapple\", \"strawberry\"}\r\n\r\n    ReadOnly Property Foo() As String() ' Noncompliant\r\n        Get\r\n            Dim copy = array.Clone      ' Expensive call\r\n            Return copy\r\n        End Get\r\n    End Property\r\nEnd Module\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nModule Module1\r\n    ' Internal state\r\n    Dim array = {\"apple\", \"banana\", \"orange\", \"pineapple\", \"strawberry\"}\r\n\r\n    Function GetFoo() As String()       ' Compliant\r\n        Dim copy = array.Clone\r\n        Return copy\r\n    End Function\r\nEnd Module\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "performance"
          ]
        }
      ]
    },
    {
      "key": "S2350",
      "title": "\"Exit Select\" statements should not be used redundantly",
      "tags": [
        "clumsy"
      ],
      "implementations": [
        {
          "key": "S2350",
          "language": "VB.NET",
          "title": "\"Exit Select\" statements should not be used redundantly",
          "description": "<p>\r\n    Visual Basic .NET, unlike many other programming languages, has no \"fall-through\" for its <code>Select</code> cases. Each case\r\n    already has an implicit <code>Exit Select</code> as its last instruction. It therefore is redundant to explicitly add one.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n        Dim x = 0\r\n        Select Case x\r\n            Case 0\r\n                Console.WriteLine(\"0\")\r\n                Exit Select                ' Noncompliant\r\n            Case Else\r\n                Console.WriteLine(\"Not 0\")\r\n                Exit Select                ' Noncompliant\r\n        End Select\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n        Dim x = 0\r\n        Select Case x\r\n            Case 0                         ' Compliant\r\n                Console.WriteLine(\"0\")\r\n            Case Else                      ' Compliant\r\n                Console.WriteLine(\"Not 0\")\r\n        End Select\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n",
          "severity": "Minor",
          "tags": [
            "clumsy"
          ]
        }
      ]
    },
    {
      "key": "S2340",
      "title": "\"Do\" loops should not be used without a \"While\" or \"Until\" condition",
      "tags": [
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S2340",
          "language": "VB.NET",
          "title": "\"Do\" loops should not be used without a \"While\" or \"Until\" condition",
          "description": "<p>\r\n    A <code>Do ... Loop</code> without a <code>While</code> or <code>Until</code> condition must be terminated by an\r\n    unstructured <code>Exit Do</code> statement. It is safer and more readable to use structured loops instead.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n        Dim i = 1\r\n\r\n        Do                        ' Non-Compliant\r\n            If i = 10 Then\r\n                Exit Do\r\n            End If\r\n\r\n            Console.WriteLine(i)\r\n\r\n            i = i + 1\r\n        Loop\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n        For i = 1 To 9            ' Compliant\r\n            Console.WriteLine(i)\r\n        Next\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n",
          "severity": "Major",
          "tags": [
            "pitfall"
          ]
        }
      ]
    },
    {
      "key": "S1645",
      "title": "The \"&\" operator should be used to concatenate strings",
      "tags": [
        "suspicious"
      ],
      "implementations": [
        {
          "key": "S1645",
          "language": "VB.NET",
          "title": "The \"&\" operator should be used to concatenate strings",
          "description": "<p>\r\n    Consistently using the <code>&amp;</code> operator for string concatenation make the developer intentions clear.\r\n    <code>&amp;</code>, unlike <code>+</code>, will convert its operands to strings and perform an actual concatenation.\r\n    <code>+</code> on the other hand can be an addition, or a concatenation, depending on the operand types.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n        Console.WriteLine(\"1\" + 2) ' Noncompliant - will display \"3\"\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n        Console.WriteLine(1 &amp; 2)   ' Compliant - will display \"12\"\r\n        Console.WriteLine(1 + 2)   ' Compliant - but will display \"3\"\r\n        Console.WriteLine(\"1\" &amp; 2) ' Compliant - will display \"12\"\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n<h2>Code Fixes</h2><ul><li>Change to \"&\"</li></ul>",
          "severity": "Major",
          "tags": [
            "suspicious"
          ]
        }
      ]
    },
    {
      "key": "S2374",
      "title": "Signed types should be preferred to unsigned ones",
      "tags": [
        "pitfall"
      ],
      "implementations": [
        {
          "key": "S2374",
          "language": "VB.NET",
          "title": "Signed types should be preferred to unsigned ones",
          "description": "<p>\r\n    Unsigned integers have different arithmetic operators than signed ones - operators that few developers understand.\r\n    Therefore, signed types should be preferred where possible.\r\n</p>\r\n\r\n<h2>Noncompliant Code Example</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n        Dim foo1 As UShort   ' Noncompliant\r\n        Dim foo2 As UInteger ' Noncompliant\r\n        Dim foo3 As ULong    ' Noncompliant\r\n    End Sub\r\nEnd Module\r\n</pre>\r\n\r\n<h2>Compliant Solution</h2>\r\n<pre>\r\nModule Module1\r\n    Sub Main()\r\n        Dim foo1 As Short\r\n        Dim foo2 As Integer\r\n        Dim foo3 As Long\r\n    End Sub\r\nEnd Module\r\n</pre>",
          "severity": "Major",
          "tags": [
            "pitfall"
          ]
        }
      ]
    }
  ]
}